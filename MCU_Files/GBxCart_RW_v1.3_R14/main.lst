   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.3
   4:setup.c       ****  Firmware version: R13
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 26/03/2019
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define VOLTAGE_SELECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 144:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 145:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 146:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
 147:setup.c       **** 
 148:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 149:setup.c       **** 
 150:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 151:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 152:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 153:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 154:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 155:setup.c       **** 
 156:setup.c       **** #define D0D1_NOT_SWAPPED 0
 157:setup.c       **** #define D0D1_SWAPPED 1
 158:setup.c       **** 
 159:setup.c       **** // General commands
 160:setup.c       **** #define SEND_ACK '1'
 161:setup.c       **** #define CART_MODE 'C'
 162:setup.c       **** #define SET_INPUT 'I'
 163:setup.c       **** #define SET_OUTPUT 'O'
 164:setup.c       **** #define SET_OUTPUT_LOW 'L'
 165:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 166:setup.c       **** #define READ_INPUT 'D'
 167:setup.c       **** #define RESET_COMMON_LINES 'M'
 168:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 169:setup.c       **** #define READ_PCB_VERSION 'h'
 170:setup.c       **** #define VOLTAGE_3_3V '3'
 171:setup.c       **** #define VOLTAGE_5V '5'
 172:setup.c       **** 
 173:setup.c       **** #define RESET_AVR '*'
 174:setup.c       **** #define RESET_VALUE 0x7E5E1
 175:setup.c       **** 
 176:setup.c       **** 
 177:setup.c       **** char receivedBuffer[256];
 178:setup.c       **** char receivedChar;
 179:setup.c       **** uint8_t eepromBuffer[8];
 180:setup.c       **** uint8_t flashChipIdBuffer[2];
 181:setup.c       **** 
 182:setup.c       **** char flashWriteWePin;
 183:setup.c       **** uint16_t flashWriteCycle[3][2];
 184:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 185:setup.c       **** uint8_t lastBankAccessed = 0;
 186:setup.c       **** 
 187:setup.c       **** uint8_t cartMode = GBA_MODE;
 188:setup.c       **** 
 189:setup.c       **** // Receive USART data
 190:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 190 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 191:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 191 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 192:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 192 0
  26 0004 8CB1      		in r24,0xc
 193:setup.c       **** }
  27               		.loc 1 193 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 194:setup.c       **** 
 195:setup.c       **** // Transmit USART data
 196:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 196 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 197:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 197 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 198:setup.c       **** 	UDR = data;
  47               		.loc 1 198 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 199:setup.c       **** }
 200:setup.c       **** 
 201:setup.c       **** // Read 1-256 bytes from the USART 
 202:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 202 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB121:
 203:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 203 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 203 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 204:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 204 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE121:
 205:setup.c       **** 	}
 206:setup.c       **** }
 106               		.loc 1 206 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 207:setup.c       **** 
 208:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 209:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 209 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 210:setup.c       **** 	int x = 0;
 211:setup.c       **** 	while (1) {
 212:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 212 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 213:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 213 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 214:setup.c       **** 			break;
 215:setup.c       **** 		}
 216:setup.c       **** 		x++;
 217:setup.c       **** 	}
 218:setup.c       **** }
 148               		.loc 1 218 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 219:setup.c       **** 
 220:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 221:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 221 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 222:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 222 0
 167 0050 3A9A      		sbi 0x7,2
 223:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 223 0
 169 0052 949A      		sbi 0x12,4
 224:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 224 0
 171 0054 959A      		sbi 0x12,5
 225:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 225 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 226:setup.c       **** }
 227:setup.c       **** 
 228:setup.c       **** 
 229:setup.c       **** 
 230:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 231:setup.c       **** 
 232:setup.c       **** // Set Gameboy mode
 233:setup.c       **** void gb_mode(void) {
 182               		.loc 1 233 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 234:setup.c       **** 	// Set inputs
 235:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 235 0
 189 005a 15BA      		out 0x15,__zero_reg__
 236:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 236 0
 191 005c 14BA      		out 0x14,__zero_reg__
 237:setup.c       **** 	
 238:setup.c       **** 	// Set outputs
 239:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 239 0
 193 005e 18BA      		out 0x18,__zero_reg__
 240:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 240 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 241:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 241 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 242:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 242 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 243:setup.c       **** }
 244:setup.c       **** 
 245:setup.c       **** // Set the 16 bit address on A15-0
 246:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 246 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 247:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 247 0
 217 006a 9BBB      		out 0x1b,r25
 248:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 248 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 249:setup.c       **** }
 250:setup.c       **** 
 251:setup.c       **** // Set the address and read a byte from the 8 bit data line
 252:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 252 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 253:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 253 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 254:setup.c       **** 	
 255:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 255 0
 239 0072 9498      		cbi 0x12,4
 256:setup.c       **** 	rdPin_low;
 240               		.loc 1 256 0
 241 0074 9598      		cbi 0x12,5
 257:setup.c       **** 	
 258:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 258 0
 243               	/* #APP */
 244               	 ;  258 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 259:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 259 0
 248               	 ;  259 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 260:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 260 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 261:setup.c       **** 	
 262:setup.c       **** 	rdPin_high;
 255               		.loc 1 262 0
 256 007c 959A      		sbi 0x12,5
 263:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 263 0
 258 007e 949A      		sbi 0x12,4
 264:setup.c       **** 	
 265:setup.c       **** 	return data;
 266:setup.c       **** }
 259               		.loc 1 266 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 267:setup.c       **** 
 268:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 269:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 269 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 270:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 270 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 271:setup.c       **** 	
 272:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 272 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 273:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 273 0
 292 0090 D5BB      		out 0x15,r29
 274:setup.c       **** 	
 275:setup.c       **** 	// Pulse WR and mREQ if the type matches
 276:setup.c       **** 	wrPin_low;
 293               		.loc 1 276 0
 294 0092 9698      		cbi 0x12,6
 277:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 277 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 278:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 278 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 279:setup.c       **** 	}
 280:setup.c       **** 	
 281:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 281 0
 302               	/* #APP */
 303               	 ;  281 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 282:setup.c       **** 	
 283:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 283 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 284:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 284 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 285:setup.c       **** 	}
 286:setup.c       **** 	wrPin_high;
 313               		.loc 1 286 0
 314 00a2 969A      		sbi 0x12,6
 287:setup.c       **** 	
 288:setup.c       **** 	// Clear data outputs and set data pins as inputs
 289:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 289 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 290:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 290 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 291:setup.c       **** }
 320               		.loc 1 291 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 292:setup.c       **** 
 293:setup.c       **** 
 294:setup.c       **** 
 295:setup.c       **** // ****** Gameboy Advance functions ****** 
 296:setup.c       **** 
 297:setup.c       **** // Set GBA mode
 298:setup.c       **** void gba_mode(void) {
 333               		.loc 1 298 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 299:setup.c       **** 	// Set outputs for reading ROM addresses as default
 300:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 300 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 301:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 301 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 302:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 302 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 303:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 303 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 304:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 304 0
 349 00b8 8ABB      		out 0x1a,r24
 305:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 305 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 306:setup.c       **** }
 307:setup.c       **** 
 308:setup.c       **** // Set the 24 bit address on A23-0
 309:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 309 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 310:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 310 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 311:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 311 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 312:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 312 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 313:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 313 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 314:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 314 0
 385 00cc 2ABB      		out 0x1a,r18
 315:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 315 0
 387 00ce 27BB      		out 0x17,r18
 316:setup.c       **** 	
 317:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 317 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 318:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 318 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 319:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 319 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 320:setup.c       **** }
 402               		.loc 1 320 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 321:setup.c       **** 
 322:setup.c       **** 
 323:setup.c       **** 
 324:setup.c       **** // ---------- ROM/SRAM ----------
 325:setup.c       **** 
 326:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 327:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 327 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 328:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 328 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 329:setup.c       **** 	
 330:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 330 0
 424 00ec 9498      		cbi 0x12,4
 331:setup.c       **** 	
 332:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 332 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 333:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 333 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 334:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 334 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 335:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 335 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 336:setup.c       **** 	
 337:setup.c       **** 	rdPin_low;
 433               		.loc 1 337 0
 434 00f6 9598      		cbi 0x12,5
 338:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 338 0
 436               	/* #APP */
 437               	 ;  338 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 339:setup.c       **** 	
 340:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 340 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 341:setup.c       **** 	
 342:setup.c       **** 	rdPin_high;
 445               		.loc 1 342 0
 446 00fe 959A      		sbi 0x12,5
 343:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 343 0
 448 0100 949A      		sbi 0x12,4
 344:setup.c       **** 	
 345:setup.c       **** 	return data;
 449               		.loc 1 345 0
 450 0102 90E0      		ldi r25,0
 346:setup.c       **** }
 451               		.loc 1 346 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 347:setup.c       **** 
 348:setup.c       **** // Set the address and read a byte from the 8 bit data line
 349:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 349 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 350:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 350 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 351:setup.c       **** 	
 352:setup.c       **** 	rdPin_low;
 471               		.loc 1 352 0
 472 010a 9598      		cbi 0x12,5
 353:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 473               		.loc 1 353 0
 474 010c 3A98      		cbi 0x7,2
 354:setup.c       **** 	
 355:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 355 0
 476               	/* #APP */
 477               	 ;  355 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 356:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 356 0
 481               	 ;  356 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 357:setup.c       **** 	
 358:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 358 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 359:setup.c       **** 	
 360:setup.c       **** 	cs2Pin_high;
 488               		.loc 1 360 0
 489 0114 3A9A      		sbi 0x7,2
 361:setup.c       **** 	rdPin_high;
 490               		.loc 1 361 0
 491 0116 959A      		sbi 0x12,5
 362:setup.c       **** 	
 363:setup.c       **** 	return data;
 364:setup.c       **** }
 492               		.loc 1 364 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 365:setup.c       **** 
 366:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 367:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 367 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 368:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 368 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 369:setup.c       **** 	
 370:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 370 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 371:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 371 0
 520 0124 C5BB      		out 0x15,r28
 372:setup.c       **** 	
 373:setup.c       **** 	// Pulse WR
 374:setup.c       **** 	wrPin_low;
 521               		.loc 1 374 0
 522 0126 9698      		cbi 0x12,6
 375:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 523               		.loc 1 375 0
 524 0128 3A98      		cbi 0x7,2
 376:setup.c       **** 	
 377:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 377 0
 526               	/* #APP */
 527               	 ;  377 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 378:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 378 0
 531               	 ;  378 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 379:setup.c       **** 	
 380:setup.c       **** 	cs2Pin_high;
 534               		.loc 1 380 0
 535               	/* #NOAPP */
 536 012e 3A9A      		sbi 0x7,2
 381:setup.c       **** 	wrPin_high;
 537               		.loc 1 381 0
 538 0130 969A      		sbi 0x12,6
 382:setup.c       **** 	
 383:setup.c       **** 	// Clear data outputs and set data pins as inputs
 384:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 384 0
 540 0132 15BA      		out 0x15,__zero_reg__
 385:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 385 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 386:setup.c       **** }
 544               		.loc 1 386 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 387:setup.c       **** 
 388:setup.c       **** 
 389:setup.c       **** 
 390:setup.c       **** // ---------- EEPROM ----------
 391:setup.c       **** 
 392:setup.c       **** // Set address/data all high (includes AD0/A23)
 393:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 393 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 394:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 394 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 395:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 395 0
 565 013e 8ABB      		out 0x1a,r24
 396:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 396 0
 567 0140 84BB      		out 0x14,r24
 397:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 397 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 398:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 398 0
 572 0146 8BBB      		out 0x1b,r24
 399:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 399 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 400:setup.c       **** }
 401:setup.c       **** 
 402:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 403:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 403 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 404:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 404 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 405:setup.c       **** 	
 406:setup.c       **** 	int8_t x = 0;
 407:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 407 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 408:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 408 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 409:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 409 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 410:setup.c       **** 		}
 411:setup.c       **** 		else {
 412:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 413:setup.c       **** 		}
 414:setup.c       **** 		x = 15;
 603               		.loc 1 414 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 415:setup.c       **** 	}
 416:setup.c       **** 	else {
 417:setup.c       **** 		if (command == EEPROM_READ) {
 418:setup.c       **** 			address |= (1<<7) | (1<<6);
 419:setup.c       **** 		}
 420:setup.c       **** 		else {
 421:setup.c       **** 			address |= (1<<7);
 422:setup.c       **** 		}
 423:setup.c       **** 		x = 7;
 424:setup.c       **** 	}
 425:setup.c       **** 	
 426:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 427:setup.c       **** 	while (x >= 0) {
 428:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 428 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 412:setup.c       **** 		}
 613               		.loc 1 412 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 417:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 417 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 418:setup.c       **** 		}
 621               		.loc 1 418 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 421:setup.c       **** 		}
 626               		.loc 1 421 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 423:setup.c       **** 	}
 630               		.loc 1 423 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 429:setup.c       **** 			ad0Pin_high;
 430:setup.c       **** 		}
 431:setup.c       **** 		else {
 432:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 432 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 433:setup.c       **** 		}
 434:setup.c       **** 		
 435:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 435 0
 639 0174 9698      		cbi 0x12,6
 436:setup.c       **** 		asm ("nop");
 640               		.loc 1 436 0
 641               	/* #APP */
 642               	 ;  436 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 437:setup.c       **** 		asm ("nop");
 645               		.loc 1 437 0
 646               	 ;  437 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 438:setup.c       **** 		wrPin_high; 
 649               		.loc 1 438 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 439:setup.c       **** 		asm ("nop");
 652               		.loc 1 439 0
 653               	/* #APP */
 654               	 ;  439 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 440:setup.c       **** 		asm ("nop");
 657               		.loc 1 440 0
 658               	 ;  440 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 427:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 427 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 428:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 428 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 429:setup.c       **** 		}
 682               		.loc 1 429 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 441:setup.c       **** 		
 442:setup.c       **** 		x--;
 443:setup.c       **** 	}
 444:setup.c       **** 	
 445:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 446:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 446 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 447:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 447 0
 690 01a4 C098      		cbi 0x18,0
 448:setup.c       **** 		asm ("nop");
 691               		.loc 1 448 0
 692               	/* #APP */
 693               	 ;  448 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 449:setup.c       **** 		wrPin_low;
 696               		.loc 1 449 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 450:setup.c       **** 		asm ("nop");
 699               		.loc 1 450 0
 700               	/* #APP */
 701               	 ;  450 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 451:setup.c       **** 		asm ("nop");
 704               		.loc 1 451 0
 705               	 ;  451 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 452:setup.c       **** 		
 453:setup.c       **** 		wrPin_high;
 708               		.loc 1 453 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 454:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 454 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 455:setup.c       **** 	}
 456:setup.c       **** }
 457:setup.c       **** 
 458:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 459:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 459 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 460:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 460 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 461:setup.c       **** 	
 462:setup.c       **** 	// Set AD0 pin as input
 463:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 463 0
 734 01b8 C098      		cbi 0x18,0
 464:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 464 0
 736 01ba B898      		cbi 0x17,0
 465:setup.c       **** 	
 466:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 466 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB122:
 467:setup.c       **** 	
 468:setup.c       **** 	// Ignore first 4 bits
 469:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 470:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 470 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 471:setup.c       **** 		asm ("nop");
 746               		.loc 1 471 0 discriminator 3
 747               	/* #APP */
 748               	 ;  471 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 472:setup.c       **** 		asm ("nop");
 751               		.loc 1 472 0 discriminator 3
 752               	 ;  472 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 473:setup.c       **** 		rdPin_high; 
 755               		.loc 1 473 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 474:setup.c       **** 		asm ("nop");
 758               		.loc 1 474 0 discriminator 3
 759               	/* #APP */
 760               	 ;  474 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 475:setup.c       **** 		asm ("nop");
 763               		.loc 1 475 0 discriminator 3
 764               	 ;  475 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 469:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 469 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE122:
 776               	.LBB123:
 777               	.LBB124:
 778               	.LBB125:
 476:setup.c       **** 	}
 477:setup.c       **** 	
 478:setup.c       **** 	// Read out 64 bits
 479:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 480:setup.c       **** 		uint8_t data = 0;
 481:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 482:setup.c       **** 			rdPin_low; // CLK
 483:setup.c       **** 			asm ("nop");
 484:setup.c       **** 			asm ("nop");
 485:setup.c       **** 			rdPin_high;
 486:setup.c       **** 			
 487:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 488:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 488 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE125:
 785               	.LBE124:
 786               	.LBE123:
 466:setup.c       **** 	
 787               		.loc 1 466 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB128:
 794               	.LBB127:
 795               	.LBB126:
 482:setup.c       **** 			asm ("nop");
 796               		.loc 1 482 0
 797 01de 9598      		cbi 0x12,5
 483:setup.c       **** 			asm ("nop");
 798               		.loc 1 483 0
 799               	/* #APP */
 800               	 ;  483 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 484:setup.c       **** 			rdPin_high;
 803               		.loc 1 484 0
 804               	 ;  484 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 485:setup.c       **** 			
 807               		.loc 1 485 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 487:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 487 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 488 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE126:
 489:setup.c       **** 			}
 490:setup.c       **** 		}
 491:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 491 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE127:
 479:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 479 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE128:
 492:setup.c       **** 	}
 493:setup.c       **** 	
 494:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 494 0
 841 0206 949A      		sbi 0x12,4
 495:setup.c       **** 	
 496:setup.c       **** 	// Set AD0 pin as output
 497:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 497 0
 843 0208 C09A      		sbi 0x18,0
 498:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 498 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 499:setup.c       **** }
 500:setup.c       **** 
 501:setup.c       **** // Write 8 bytes to the EEPROM address
 502:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 502 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 503:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 503 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 502:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 502 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB129:
 876               	.LBB130:
 504:setup.c       **** 	
 505:setup.c       **** 	// Write 64 bits
 506:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 507:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 508:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 508 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 509:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 509 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 510:setup.c       **** 			}
 511:setup.c       **** 			else {
 512:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 512 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 513:setup.c       **** 			}
 514:setup.c       **** 			
 515:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 515 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 516:setup.c       **** 			asm ("nop");
 899               		.loc 1 516 0 discriminator 2
 900               	/* #APP */
 901               	 ;  516 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 517:setup.c       **** 			asm ("nop");
 904               		.loc 1 517 0 discriminator 2
 905               	 ;  517 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 518:setup.c       **** 			wrPin_high; 
 908               		.loc 1 518 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 519:setup.c       **** 			asm ("nop");
 911               		.loc 1 519 0 discriminator 2
 912               	/* #APP */
 913               	 ;  519 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 520:setup.c       **** 			asm ("nop");
 916               		.loc 1 520 0 discriminator 2
 917               	 ;  520 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE130:
 506:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 506 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE129:
 521:setup.c       **** 		}
 522:setup.c       **** 	}
 523:setup.c       **** 	
 524:setup.c       **** 	// Last bit low
 525:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 525 0
 935 0250 C098      		cbi 0x18,0
 526:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 526 0
 937 0252 9698      		cbi 0x12,6
 527:setup.c       **** 	asm ("nop");
 938               		.loc 1 527 0
 939               	/* #APP */
 940               	 ;  527 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 528:setup.c       **** 	asm ("nop");
 943               		.loc 1 528 0
 944               	 ;  528 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 529:setup.c       **** 	wrPin_high; 
 947               		.loc 1 529 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 530:setup.c       **** 	asm ("nop");
 950               		.loc 1 530 0
 951               	/* #APP */
 952               	 ;  530 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 531:setup.c       **** 	asm ("nop");
 955               		.loc 1 531 0
 956               	 ;  531 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 532:setup.c       **** 	
 533:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 533 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 534:setup.c       **** }
 535:setup.c       **** 
 536:setup.c       **** 
 537:setup.c       **** 
 538:setup.c       **** // ---------- FLASH ----------
 539:setup.c       **** 
 540:setup.c       **** // Set the address and data for the write byte cycle to the flash
 541:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 541 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 542:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 542 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 543:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 543 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 544:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 544 0
 989 026c C5BB      		out 0x15,r28
 545:setup.c       **** 	
 546:setup.c       **** 	wrPin_low;
 990               		.loc 1 546 0
 991 026e 9698      		cbi 0x12,6
 547:setup.c       **** 	cs2Pin_low;
 992               		.loc 1 547 0
 993 0270 3A98      		cbi 0x7,2
 548:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 548 0
 995               	/* #APP */
 996               	 ;  548 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 549:setup.c       **** 	wrPin_high;
 999               		.loc 1 549 0
 1000               	/* #NOAPP */
 1001 0274 969A      		sbi 0x12,6
 550:setup.c       **** 	cs2Pin_high;
 1002               		.loc 1 550 0
 1003 0276 3A9A      		sbi 0x7,2
 1004               	/* epilogue start */
 551:setup.c       **** }
 1005               		.loc 1 551 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 552:setup.c       **** 
 553:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 554:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 554 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 555:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 555 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 556:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 556 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 557:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 557 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB131:
 1049               	.LBB132:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE132:
 1060               	.LBE131:
 558:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 559:setup.c       **** 	
 560:setup.c       **** 	// Set data as inputs
 561:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 561 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 562:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 562 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 563:setup.c       **** 	
 564:setup.c       **** 	// Read and transmit the 2 bytes
 565:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 565 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 566:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 566 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 567:setup.c       **** 	
 568:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 568 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 569:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 569 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 570:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 570 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB133:
 1098               	.LBB134:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE134:
 1109               	.LBE133:
 571:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 572:setup.c       **** }
 1110               		.loc 1 572 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 573:setup.c       **** 
 574:setup.c       **** // Switch banks on the Flash
 575:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 575 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 576:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 576 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 577:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 577 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 578:setup.c       **** 	
 579:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 579 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 580:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 580 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 581:setup.c       **** }
 1157               		.loc 1 581 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 580:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 580 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 582:setup.c       **** 
 583:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 584:setup.c       **** // Takes 25ms after last command to erase sector
 585:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 585 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 586:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 586 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 587:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 587 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 588:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 588 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 589:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 589 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 590:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 590 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 591:setup.c       **** 	
 592:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 592 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB135:
 1222               	.LBB136:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE136:
 1233               	.LBE135:
 593:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 594:setup.c       **** }
 1234               		.loc 1 594 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 595:setup.c       **** 
 596:setup.c       **** // Write a single byte to the Flash address
 597:setup.c       **** // Takes 20us to program Flash
 598:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 598 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 599:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 599 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 600:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 600 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 601:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 601 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 602:setup.c       **** 	
 603:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 603 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB137:
 1292               	.LBB138:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE138:
 1301               	.LBE137:
 604:setup.c       **** 	_delay_us(20); // Wait byte program time
 605:setup.c       **** }
 1302               		.loc 1 605 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 606:setup.c       **** 
 607:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 608:setup.c       **** // Takes 20ms for write cycle
 609:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 609 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 610:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 610 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 611:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 611 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 612:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 612 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB139:
 613:setup.c       **** 	
 614:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 615:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 616:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 616 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 616 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 615:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 615 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE139:
 1400               	.LBB140:
 1401               	.LBB141:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE141:
 1412               	.LBE140:
 617:setup.c       **** 	}
 618:setup.c       **** 	_delay_ms(20); // Wait sector program time
 619:setup.c       **** }
 1413               		.loc 1 619 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 620:setup.c       **** 
 621:setup.c       **** 
 622:setup.c       **** 
 623:setup.c       **** // ---------- GB FLASH CARTS ----------
 624:setup.c       **** 
 625:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 626:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 626 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 627:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 627 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 628:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 628 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 629:setup.c       **** 	
 630:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 630 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 631:setup.c       **** 	
 632:setup.c       **** 	rdPin_low;
 1443               		.loc 1 632 0
 1444 03fe 9598      		cbi 0x12,5
 633:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 633 0
 1446               	/* #APP */
 1447               	 ;  633 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 634:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 634 0
 1451               	 ;  634 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 635:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 635 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 636:setup.c       **** 	rdPin_high;
 1458               		.loc 1 636 0
 1459 0406 959A      		sbi 0x12,5
 637:setup.c       **** 	
 638:setup.c       **** 	return data;
 639:setup.c       **** }
 1460               		.loc 1 639 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_write_bus_cycle
 1467               	gb_flash_write_bus_cycle:
 1468               	.LFB37:
 640:setup.c       **** 
 641:setup.c       **** // Set the address and data for the write byte cycle to the flash
 642:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 642 0
 1470               		.cfi_startproc
 1471               	.LVL116:
 1472 040a CF93      		push r28
 1473               	.LCFI25:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 1 */
 1479               	.L__stack_usage = 1
 1480 040c C62F      		mov r28,r22
 643:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1481               		.loc 1 643 0
 1482 040e 2FEF      		ldi r18,lo8(-1)
 1483 0410 24BB      		out 0x14,r18
 644:setup.c       **** 	set_16bit_address(address);
 1484               		.loc 1 644 0
 1485 0412 00D0      		rcall set_16bit_address
 1486               	.LVL117:
 645:setup.c       **** 	PORT_DATA7_0 = data;
 1487               		.loc 1 645 0
 1488 0414 C5BB      		out 0x15,r28
 646:setup.c       **** 	
 647:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1489               		.loc 1 647 0
 1490 0416 8091 0000 		lds r24,flashWriteWePin
 1491 041a 8134      		cpi r24,lo8(65)
 1492 041c 01F4      		brne .L70
 648:setup.c       **** 		audioPin_low; // WE low
 1493               		.loc 1 648 0
 1494 041e 3998      		cbi 0x7,1
 649:setup.c       **** 		asm volatile("nop");
 1495               		.loc 1 649 0
 1496               	/* #APP */
 1497               	 ;  649 "setup.c" 1
 1498 0420 0000      		nop
 1499               	 ;  0 "" 2
 650:setup.c       **** 		asm volatile("nop");
 1500               		.loc 1 650 0
 1501               	 ;  650 "setup.c" 1
 1502 0422 0000      		nop
 1503               	 ;  0 "" 2
 651:setup.c       **** 		asm volatile("nop");
 1504               		.loc 1 651 0
 1505               	 ;  651 "setup.c" 1
 1506 0424 0000      		nop
 1507               	 ;  0 "" 2
 652:setup.c       **** 		audioPin_high; // WE high
 1508               		.loc 1 652 0
 1509               	/* #NOAPP */
 1510 0426 399A      		sbi 0x7,1
 1511 0428 00C0      		rjmp .L71
 1512               	.L70:
 653:setup.c       **** 	}
 654:setup.c       **** 	else { // WR pin
 655:setup.c       **** 		wrPin_low; // WE low
 1513               		.loc 1 655 0
 1514 042a 9698      		cbi 0x12,6
 656:setup.c       **** 		asm volatile("nop");
 1515               		.loc 1 656 0
 1516               	/* #APP */
 1517               	 ;  656 "setup.c" 1
 1518 042c 0000      		nop
 1519               	 ;  0 "" 2
 657:setup.c       **** 		asm volatile("nop");
 1520               		.loc 1 657 0
 1521               	 ;  657 "setup.c" 1
 1522 042e 0000      		nop
 1523               	 ;  0 "" 2
 658:setup.c       **** 		asm volatile("nop");
 1524               		.loc 1 658 0
 1525               	 ;  658 "setup.c" 1
 1526 0430 0000      		nop
 1527               	 ;  0 "" 2
 659:setup.c       **** 		wrPin_high; // WE high
 1528               		.loc 1 659 0
 1529               	/* #NOAPP */
 1530 0432 969A      		sbi 0x12,6
 1531               	.L71:
 660:setup.c       **** 	}
 661:setup.c       **** 	
 662:setup.c       **** 	// Clear data outputs and set data pins as inputs
 663:setup.c       **** 	PORT_DATA7_0 = 0;
 1532               		.loc 1 663 0
 1533 0434 15BA      		out 0x15,__zero_reg__
 664:setup.c       **** 	DDR_DATA7_0 = 0;
 1534               		.loc 1 664 0
 1535 0436 14BA      		out 0x14,__zero_reg__
 1536               	/* epilogue start */
 665:setup.c       **** }
 1537               		.loc 1 665 0
 1538 0438 CF91      		pop r28
 1539               	.LVL118:
 1540 043a 0895      		ret
 1541               		.cfi_endproc
 1542               	.LFE37:
 1544               	.global	gb_flash_write_byte
 1546               	gb_flash_write_byte:
 1547               	.LFB38:
 666:setup.c       **** 
 667:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 668:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1548               		.loc 1 668 0
 1549               		.cfi_startproc
 1550               	.LVL119:
 1551 043c 1F93      		push r17
 1552               	.LCFI26:
 1553               		.cfi_def_cfa_offset 3
 1554               		.cfi_offset 17, -2
 1555 043e CF93      		push r28
 1556               	.LCFI27:
 1557               		.cfi_def_cfa_offset 4
 1558               		.cfi_offset 28, -3
 1559 0440 DF93      		push r29
 1560               	.LCFI28:
 1561               		.cfi_def_cfa_offset 5
 1562               		.cfi_offset 29, -4
 1563               	/* prologue: function */
 1564               	/* frame size = 0 */
 1565               	/* stack size = 3 */
 1566               	.L__stack_usage = 3
 1567 0442 EC01      		movw r28,r24
 1568 0444 162F      		mov r17,r22
 669:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1569               		.loc 1 669 0
 1570 0446 6091 0000 		lds r22,flashWriteCycle+2
 1571               	.LVL120:
 1572 044a 8091 0000 		lds r24,flashWriteCycle
 1573 044e 9091 0000 		lds r25,flashWriteCycle+1
 1574               	.LVL121:
 1575 0452 00D0      		rcall gb_flash_write_bus_cycle
 1576               	.LVL122:
 670:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1577               		.loc 1 670 0
 1578 0454 6091 0000 		lds r22,flashWriteCycle+6
 1579 0458 8091 0000 		lds r24,flashWriteCycle+4
 1580 045c 9091 0000 		lds r25,flashWriteCycle+4+1
 1581 0460 00D0      		rcall gb_flash_write_bus_cycle
 1582               	.LVL123:
 671:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1583               		.loc 1 671 0
 1584 0462 6091 0000 		lds r22,flashWriteCycle+10
 1585 0466 8091 0000 		lds r24,flashWriteCycle+8
 1586 046a 9091 0000 		lds r25,flashWriteCycle+8+1
 1587 046e 00D0      		rcall gb_flash_write_bus_cycle
 1588               	.LVL124:
 672:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1589               		.loc 1 672 0
 1590 0470 612F      		mov r22,r17
 1591 0472 CE01      		movw r24,r28
 1592 0474 00D0      		rcall gb_flash_write_bus_cycle
 1593               	.LVL125:
 1594               	.LBB142:
 1595               	.LBB143:
 1596               		.loc 2 276 0
 1597 0476 8AE1      		ldi r24,lo8(26)
 1598 0478 8A95      	1:	dec r24
 1599 047a 01F4      		brne 1b
 1600 047c 00C0      		rjmp .
 1601               	.LVL126:
 1602               	.LBE143:
 1603               	.LBE142:
 673:setup.c       **** 	_delay_us(10); // Wait byte program time
 674:setup.c       **** 	
 675:setup.c       **** 	// Set data pins inputs
 676:setup.c       **** 	PORT_DATA7_0 = 0;
 1604               		.loc 1 676 0
 1605 047e 15BA      		out 0x15,__zero_reg__
 677:setup.c       **** 	DDR_DATA7_0 = 0;
 1606               		.loc 1 677 0
 1607 0480 14BA      		out 0x14,__zero_reg__
 678:setup.c       **** 	
 679:setup.c       **** 	// Verify data
 680:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1608               		.loc 1 680 0
 1609 0482 CE01      		movw r24,r28
 1610 0484 00D0      		rcall gb_flash_read_byte
 1611               	.LVL127:
 1612               	.L73:
 681:setup.c       **** 	while (data != dataVerify) {
 1613               		.loc 1 681 0
 1614 0486 8117      		cp r24,r17
 1615 0488 01F0      		breq .L75
 682:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1616               		.loc 1 682 0
 1617 048a CE01      		movw r24,r28
 1618               	.LVL128:
 1619 048c 00D0      		rcall gb_flash_read_byte
 1620               	.LVL129:
 1621               	.LBB144:
 1622               	.LBB145:
 1623               		.loc 2 276 0
 1624 048e 9DE0      		ldi r25,lo8(13)
 1625 0490 9A95      	1:	dec r25
 1626 0492 01F4      		brne 1b
 1627 0494 0000      		nop
 1628 0496 00C0      		rjmp .L73
 1629               	.LVL130:
 1630               	.L75:
 1631               	/* epilogue start */
 1632               	.LBE145:
 1633               	.LBE144:
 683:setup.c       **** 		_delay_us(5);
 684:setup.c       **** 	}
 685:setup.c       **** }
 1634               		.loc 1 685 0
 1635 0498 DF91      		pop r29
 1636 049a CF91      		pop r28
 1637               	.LVL131:
 1638 049c 1F91      		pop r17
 1639               	.LVL132:
 1640 049e 0895      		ret
 1641               		.cfi_endproc
 1642               	.LFE38:
 1644               	.global	gb_flash_write_byte_bank1_commands
 1646               	gb_flash_write_byte_bank1_commands:
 1647               	.LFB39:
 686:setup.c       **** 
 687:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 688:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 689:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1648               		.loc 1 689 0
 1649               		.cfi_startproc
 1650               	.LVL133:
 1651 04a0 FF92      		push r15
 1652               	.LCFI29:
 1653               		.cfi_def_cfa_offset 3
 1654               		.cfi_offset 15, -2
 1655 04a2 0F93      		push r16
 1656               	.LCFI30:
 1657               		.cfi_def_cfa_offset 4
 1658               		.cfi_offset 16, -3
 1659 04a4 1F93      		push r17
 1660               	.LCFI31:
 1661               		.cfi_def_cfa_offset 5
 1662               		.cfi_offset 17, -4
 1663 04a6 CF93      		push r28
 1664               	.LCFI32:
 1665               		.cfi_def_cfa_offset 6
 1666               		.cfi_offset 28, -5
 1667 04a8 DF93      		push r29
 1668               	.LCFI33:
 1669               		.cfi_def_cfa_offset 7
 1670               		.cfi_offset 29, -6
 1671               	/* prologue: function */
 1672               	/* frame size = 0 */
 1673               	/* stack size = 5 */
 1674               	.L__stack_usage = 5
 1675 04aa EC01      		movw r28,r24
 1676 04ac 162F      		mov r17,r22
 690:setup.c       **** 	// Set bank 1
 691:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1677               		.loc 1 691 0
 1678 04ae FF24      		clr r15
 1679 04b0 FA94      		dec r15
 1680 04b2 F4BA      		out 0x14,r15
 1681               	.LVL134:
 1682               	.LBB146:
 1683               	.LBB147:
 247:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1684               		.loc 1 247 0
 1685 04b4 01E2      		ldi r16,lo8(33)
 1686 04b6 0BBB      		out 0x1b,r16
 248:setup.c       **** }
 1687               		.loc 1 248 0
 1688 04b8 18BA      		out 0x18,__zero_reg__
 1689               	.LVL135:
 1690               	.LBE147:
 1691               	.LBE146:
 692:setup.c       **** 	set_16bit_address(0x2100);
 693:setup.c       **** 	PORT_DATA7_0 = 1;
 1692               		.loc 1 693 0
 1693 04ba 81E0      		ldi r24,lo8(1)
 1694               	.LVL136:
 1695 04bc 85BB      		out 0x15,r24
 694:setup.c       **** 	wrPin_low; // Pulse WR
 1696               		.loc 1 694 0
 1697 04be 9698      		cbi 0x12,6
 695:setup.c       **** 	asm volatile("nop");
 1698               		.loc 1 695 0
 1699               	/* #APP */
 1700               	 ;  695 "setup.c" 1
 1701 04c0 0000      		nop
 1702               	 ;  0 "" 2
 696:setup.c       **** 	wrPin_high;
 1703               		.loc 1 696 0
 1704               	/* #NOAPP */
 1705 04c2 969A      		sbi 0x12,6
 697:setup.c       **** 	
 698:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1706               		.loc 1 698 0
 1707 04c4 6091 0000 		lds r22,flashWriteCycle+2
 1708               	.LVL137:
 1709 04c8 8091 0000 		lds r24,flashWriteCycle
 1710 04cc 9091 0000 		lds r25,flashWriteCycle+1
 1711 04d0 00D0      		rcall gb_flash_write_bus_cycle
 1712               	.LVL138:
 699:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1713               		.loc 1 699 0
 1714 04d2 6091 0000 		lds r22,flashWriteCycle+6
 1715 04d6 8091 0000 		lds r24,flashWriteCycle+4
 1716 04da 9091 0000 		lds r25,flashWriteCycle+4+1
 1717 04de 00D0      		rcall gb_flash_write_bus_cycle
 1718               	.LVL139:
 700:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1719               		.loc 1 700 0
 1720 04e0 6091 0000 		lds r22,flashWriteCycle+10
 1721 04e4 8091 0000 		lds r24,flashWriteCycle+8
 1722 04e8 9091 0000 		lds r25,flashWriteCycle+8+1
 1723 04ec 00D0      		rcall gb_flash_write_bus_cycle
 1724               	.LVL140:
 701:setup.c       **** 	
 702:setup.c       **** 	
 703:setup.c       **** 	// Set bank back
 704:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1725               		.loc 1 704 0
 1726 04ee F4BA      		out 0x14,r15
 1727               	.LVL141:
 1728               	.LBB148:
 1729               	.LBB149:
 247:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1730               		.loc 1 247 0
 1731 04f0 0BBB      		out 0x1b,r16
 248:setup.c       **** }
 1732               		.loc 1 248 0
 1733 04f2 18BA      		out 0x18,__zero_reg__
 1734               	.LVL142:
 1735               	.LBE149:
 1736               	.LBE148:
 705:setup.c       **** 	set_16bit_address(0x2100);
 706:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1737               		.loc 1 706 0
 1738 04f4 8091 0000 		lds r24,lastBankAccessed
 1739 04f8 85BB      		out 0x15,r24
 707:setup.c       **** 	wrPin_low; // Pulse WR
 1740               		.loc 1 707 0
 1741 04fa 9698      		cbi 0x12,6
 708:setup.c       **** 	asm volatile("nop");
 1742               		.loc 1 708 0
 1743               	/* #APP */
 1744               	 ;  708 "setup.c" 1
 1745 04fc 0000      		nop
 1746               	 ;  0 "" 2
 709:setup.c       **** 	wrPin_high;
 1747               		.loc 1 709 0
 1748               	/* #NOAPP */
 1749 04fe 969A      		sbi 0x12,6
 710:setup.c       **** 	
 711:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1750               		.loc 1 711 0
 1751 0500 612F      		mov r22,r17
 1752 0502 CE01      		movw r24,r28
 1753 0504 00D0      		rcall gb_flash_write_bus_cycle
 1754               	.LVL143:
 1755               	.LBB150:
 1756               	.LBB151:
 1757               		.loc 2 276 0
 1758 0506 8AE1      		ldi r24,lo8(26)
 1759 0508 8A95      	1:	dec r24
 1760 050a 01F4      		brne 1b
 1761 050c 00C0      		rjmp .
 1762               	.LVL144:
 1763               	.LBE151:
 1764               	.LBE150:
 712:setup.c       **** 	_delay_us(10); // Wait byte program time
 713:setup.c       **** 	
 714:setup.c       **** 	// Set data pins inputs
 715:setup.c       **** 	PORT_DATA7_0 = 0;
 1765               		.loc 1 715 0
 1766 050e 15BA      		out 0x15,__zero_reg__
 716:setup.c       **** 	DDR_DATA7_0 = 0;
 1767               		.loc 1 716 0
 1768 0510 14BA      		out 0x14,__zero_reg__
 717:setup.c       **** 	
 718:setup.c       **** 	// Verify data
 719:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1769               		.loc 1 719 0
 1770 0512 CE01      		movw r24,r28
 1771 0514 00D0      		rcall gb_flash_read_byte
 1772               	.LVL145:
 1773               	.L77:
 720:setup.c       **** 	while (data != dataVerify) {
 1774               		.loc 1 720 0
 1775 0516 8117      		cp r24,r17
 1776 0518 01F0      		breq .L79
 721:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1777               		.loc 1 721 0
 1778 051a CE01      		movw r24,r28
 1779               	.LVL146:
 1780 051c 00D0      		rcall gb_flash_read_byte
 1781               	.LVL147:
 1782               	.LBB152:
 1783               	.LBB153:
 1784               		.loc 2 276 0
 1785 051e 9DE0      		ldi r25,lo8(13)
 1786 0520 9A95      	1:	dec r25
 1787 0522 01F4      		brne 1b
 1788 0524 0000      		nop
 1789 0526 00C0      		rjmp .L77
 1790               	.LVL148:
 1791               	.L79:
 1792               	/* epilogue start */
 1793               	.LBE153:
 1794               	.LBE152:
 722:setup.c       **** 		_delay_us(5);
 723:setup.c       **** 	}
 724:setup.c       **** }
 1795               		.loc 1 724 0
 1796 0528 DF91      		pop r29
 1797 052a CF91      		pop r28
 1798               	.LVL149:
 1799 052c 1F91      		pop r17
 1800               	.LVL150:
 1801 052e 0F91      		pop r16
 1802 0530 FF90      		pop r15
 1803 0532 0895      		ret
 1804               		.cfi_endproc
 1805               	.LFE39:
 1807               	.global	gba_flash_write_bus_cycle
 1809               	gba_flash_write_bus_cycle:
 1810               	.LFB40:
 725:setup.c       **** 
 726:setup.c       **** 
 727:setup.c       **** 
 728:setup.c       **** // ---------- GBA FLASH CARTS ----------
 729:setup.c       **** 
 730:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 731:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1811               		.loc 1 731 0
 1812               		.cfi_startproc
 1813               	.LVL151:
 1814 0534 0F93      		push r16
 1815               	.LCFI34:
 1816               		.cfi_def_cfa_offset 3
 1817               		.cfi_offset 16, -2
 1818 0536 1F93      		push r17
 1819               	.LCFI35:
 1820               		.cfi_def_cfa_offset 4
 1821               		.cfi_offset 17, -3
 1822               	/* prologue: function */
 1823               	/* frame size = 0 */
 1824               	/* stack size = 2 */
 1825               	.L__stack_usage = 2
 732:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 1826               		.loc 1 732 0
 1827 0538 8C01      		movw r16,r24
 1828 053a 2227      		clr r18
 1829 053c 3327      		clr r19
 1830 053e 05BB      		out 0x15,r16
 733:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 1831               		.loc 1 733 0
 1832 0540 072F      		mov r16,r23
 1833 0542 182F      		mov r17,r24
 1834 0544 292F      		mov r18,r25
 1835 0546 3327      		clr r19
 1836 0548 0BBB      		out 0x1b,r16
 734:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 1837               		.loc 1 734 0
 1838 054a 68BB      		out 0x18,r22
 735:setup.c       **** 	
 736:setup.c       **** 	cs_mreqPin_low;
 1839               		.loc 1 736 0
 1840 054c 9498      		cbi 0x12,4
 737:setup.c       **** 	
 738:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1841               		.loc 1 738 0
 1842 054e 5BBB      		out 0x1b,r21
 739:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1843               		.loc 1 739 0
 1844 0550 48BB      		out 0x18,r20
 740:setup.c       **** 	
 741:setup.c       **** 	wrPin_low;
 1845               		.loc 1 741 0
 1846 0552 9698      		cbi 0x12,6
 742:setup.c       **** 	asm volatile("nop");
 1847               		.loc 1 742 0
 1848               	/* #APP */
 1849               	 ;  742 "setup.c" 1
 1850 0554 0000      		nop
 1851               	 ;  0 "" 2
 743:setup.c       **** 	asm volatile("nop");
 1852               		.loc 1 743 0
 1853               	 ;  743 "setup.c" 1
 1854 0556 0000      		nop
 1855               	 ;  0 "" 2
 744:setup.c       **** 	asm volatile("nop");
 1856               		.loc 1 744 0
 1857               	 ;  744 "setup.c" 1
 1858 0558 0000      		nop
 1859               	 ;  0 "" 2
 745:setup.c       **** 	wrPin_high;
 1860               		.loc 1 745 0
 1861               	/* #NOAPP */
 1862 055a 969A      		sbi 0x12,6
 746:setup.c       **** 	cs_mreqPin_high;
 1863               		.loc 1 746 0
 1864 055c 949A      		sbi 0x12,4
 1865               	/* epilogue start */
 747:setup.c       **** }
 1866               		.loc 1 747 0
 1867 055e 1F91      		pop r17
 1868 0560 0F91      		pop r16
 1869 0562 0895      		ret
 1870               		.cfi_endproc
 1871               	.LFE40:
 1873               	.global	gba_flash_write_cycle_start_swapped
 1875               	gba_flash_write_cycle_start_swapped:
 1876               	.LFB41:
 748:setup.c       **** 
 749:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 750:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 1877               		.loc 1 750 0
 1878               		.cfi_startproc
 1879               	/* prologue: function */
 1880               	/* frame size = 0 */
 1881               	/* stack size = 0 */
 1882               	.L__stack_usage = 0
 751:setup.c       **** 	// Set outputs
 752:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 1883               		.loc 1 752 0
 1884 0564 8FEF      		ldi r24,lo8(-1)
 1885 0566 84BB      		out 0x14,r24
 753:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 1886               		.loc 1 753 0
 1887 0568 8ABB      		out 0x1a,r24
 754:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 1888               		.loc 1 754 0
 1889 056a 87BB      		out 0x17,r24
 755:setup.c       **** 	
 756:setup.c       **** 	// 0x555, 0xA9
 757:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1890               		.loc 1 757 0
 1891 056c 15BA      		out 0x15,__zero_reg__
 758:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1892               		.loc 1 758 0
 1893 056e 95E0      		ldi r25,lo8(5)
 1894 0570 9BBB      		out 0x1b,r25
 759:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1895               		.loc 1 759 0
 1896 0572 85E5      		ldi r24,lo8(85)
 1897 0574 88BB      		out 0x18,r24
 760:setup.c       **** 	cs_mreqPin_low;
 1898               		.loc 1 760 0
 1899 0576 9498      		cbi 0x12,4
 761:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1900               		.loc 1 761 0
 1901 0578 1BBA      		out 0x1b,__zero_reg__
 762:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 1902               		.loc 1 762 0
 1903 057a 29EA      		ldi r18,lo8(-87)
 1904 057c 28BB      		out 0x18,r18
 763:setup.c       **** 	wrPin_low;
 1905               		.loc 1 763 0
 1906 057e 9698      		cbi 0x12,6
 764:setup.c       **** 	asm volatile("nop");
 1907               		.loc 1 764 0
 1908               	/* #APP */
 1909               	 ;  764 "setup.c" 1
 1910 0580 0000      		nop
 1911               	 ;  0 "" 2
 765:setup.c       **** 	asm volatile("nop");
 1912               		.loc 1 765 0
 1913               	 ;  765 "setup.c" 1
 1914 0582 0000      		nop
 1915               	 ;  0 "" 2
 766:setup.c       **** 	asm volatile("nop");
 1916               		.loc 1 766 0
 1917               	 ;  766 "setup.c" 1
 1918 0584 0000      		nop
 1919               	 ;  0 "" 2
 767:setup.c       **** 	wrPin_high;
 1920               		.loc 1 767 0
 1921               	/* #NOAPP */
 1922 0586 969A      		sbi 0x12,6
 768:setup.c       **** 	cs_mreqPin_high;
 1923               		.loc 1 768 0
 1924 0588 949A      		sbi 0x12,4
 769:setup.c       **** 	
 770:setup.c       **** 	// 0x2AA, 0x56
 771:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1925               		.loc 1 771 0
 1926 058a 15BA      		out 0x15,__zero_reg__
 772:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 1927               		.loc 1 772 0
 1928 058c 22E0      		ldi r18,lo8(2)
 1929 058e 2BBB      		out 0x1b,r18
 773:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 1930               		.loc 1 773 0
 1931 0590 2AEA      		ldi r18,lo8(-86)
 1932 0592 28BB      		out 0x18,r18
 774:setup.c       **** 	cs_mreqPin_low;
 1933               		.loc 1 774 0
 1934 0594 9498      		cbi 0x12,4
 775:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1935               		.loc 1 775 0
 1936 0596 1BBA      		out 0x1b,__zero_reg__
 776:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 1937               		.loc 1 776 0
 1938 0598 26E5      		ldi r18,lo8(86)
 1939 059a 28BB      		out 0x18,r18
 777:setup.c       **** 	wrPin_low;
 1940               		.loc 1 777 0
 1941 059c 9698      		cbi 0x12,6
 778:setup.c       **** 	asm volatile("nop");
 1942               		.loc 1 778 0
 1943               	/* #APP */
 1944               	 ;  778 "setup.c" 1
 1945 059e 0000      		nop
 1946               	 ;  0 "" 2
 779:setup.c       **** 	asm volatile("nop");
 1947               		.loc 1 779 0
 1948               	 ;  779 "setup.c" 1
 1949 05a0 0000      		nop
 1950               	 ;  0 "" 2
 780:setup.c       **** 	asm volatile("nop");
 1951               		.loc 1 780 0
 1952               	 ;  780 "setup.c" 1
 1953 05a2 0000      		nop
 1954               	 ;  0 "" 2
 781:setup.c       **** 	wrPin_high;
 1955               		.loc 1 781 0
 1956               	/* #NOAPP */
 1957 05a4 969A      		sbi 0x12,6
 782:setup.c       **** 	cs_mreqPin_high;
 1958               		.loc 1 782 0
 1959 05a6 949A      		sbi 0x12,4
 783:setup.c       **** 	
 784:setup.c       **** 	// 0x555, 0xA0;
 785:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1960               		.loc 1 785 0
 1961 05a8 15BA      		out 0x15,__zero_reg__
 786:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1962               		.loc 1 786 0
 1963 05aa 9BBB      		out 0x1b,r25
 787:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1964               		.loc 1 787 0
 1965 05ac 88BB      		out 0x18,r24
 788:setup.c       **** 	cs_mreqPin_low;
 1966               		.loc 1 788 0
 1967 05ae 9498      		cbi 0x12,4
 789:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1968               		.loc 1 789 0
 1969 05b0 1BBA      		out 0x1b,__zero_reg__
 790:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 1970               		.loc 1 790 0
 1971 05b2 80EA      		ldi r24,lo8(-96)
 1972 05b4 88BB      		out 0x18,r24
 791:setup.c       **** 	wrPin_low;
 1973               		.loc 1 791 0
 1974 05b6 9698      		cbi 0x12,6
 792:setup.c       **** 	asm volatile("nop");
 1975               		.loc 1 792 0
 1976               	/* #APP */
 1977               	 ;  792 "setup.c" 1
 1978 05b8 0000      		nop
 1979               	 ;  0 "" 2
 793:setup.c       **** 	asm volatile("nop");
 1980               		.loc 1 793 0
 1981               	 ;  793 "setup.c" 1
 1982 05ba 0000      		nop
 1983               	 ;  0 "" 2
 794:setup.c       **** 	asm volatile("nop");
 1984               		.loc 1 794 0
 1985               	 ;  794 "setup.c" 1
 1986 05bc 0000      		nop
 1987               	 ;  0 "" 2
 795:setup.c       **** 	wrPin_high;
 1988               		.loc 1 795 0
 1989               	/* #NOAPP */
 1990 05be 969A      		sbi 0x12,6
 796:setup.c       **** 	cs_mreqPin_high;
 1991               		.loc 1 796 0
 1992 05c0 949A      		sbi 0x12,4
 1993 05c2 0895      		ret
 1994               		.cfi_endproc
 1995               	.LFE41:
 1997               	.global	gba_flash_write_cycle_start
 1999               	gba_flash_write_cycle_start:
 2000               	.LFB42:
 797:setup.c       **** }
 798:setup.c       **** 
 799:setup.c       **** 
 800:setup.c       **** // Send the first 3 write cycles to the flash
 801:setup.c       **** void gba_flash_write_cycle_start(void) {
 2001               		.loc 1 801 0
 2002               		.cfi_startproc
 2003               	/* prologue: function */
 2004               	/* frame size = 0 */
 2005               	/* stack size = 0 */
 2006               	.L__stack_usage = 0
 802:setup.c       **** 	// Set outputs
 803:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2007               		.loc 1 803 0
 2008 05c4 8FEF      		ldi r24,lo8(-1)
 2009 05c6 84BB      		out 0x14,r24
 804:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2010               		.loc 1 804 0
 2011 05c8 8ABB      		out 0x1a,r24
 805:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2012               		.loc 1 805 0
 2013 05ca 87BB      		out 0x17,r24
 806:setup.c       **** 	
 807:setup.c       **** 	// 0x555, 0xAA
 808:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2014               		.loc 1 808 0
 2015 05cc 15BA      		out 0x15,__zero_reg__
 809:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2016               		.loc 1 809 0
 2017 05ce 95E0      		ldi r25,lo8(5)
 2018 05d0 9BBB      		out 0x1b,r25
 810:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2019               		.loc 1 810 0
 2020 05d2 85E5      		ldi r24,lo8(85)
 2021 05d4 88BB      		out 0x18,r24
 811:setup.c       **** 	cs_mreqPin_low;
 2022               		.loc 1 811 0
 2023 05d6 9498      		cbi 0x12,4
 812:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2024               		.loc 1 812 0
 2025 05d8 1BBA      		out 0x1b,__zero_reg__
 813:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2026               		.loc 1 813 0
 2027 05da 2AEA      		ldi r18,lo8(-86)
 2028 05dc 28BB      		out 0x18,r18
 814:setup.c       **** 	wrPin_low;
 2029               		.loc 1 814 0
 2030 05de 9698      		cbi 0x12,6
 815:setup.c       **** 	asm volatile("nop");
 2031               		.loc 1 815 0
 2032               	/* #APP */
 2033               	 ;  815 "setup.c" 1
 2034 05e0 0000      		nop
 2035               	 ;  0 "" 2
 816:setup.c       **** 	asm volatile("nop");
 2036               		.loc 1 816 0
 2037               	 ;  816 "setup.c" 1
 2038 05e2 0000      		nop
 2039               	 ;  0 "" 2
 817:setup.c       **** 	asm volatile("nop");
 2040               		.loc 1 817 0
 2041               	 ;  817 "setup.c" 1
 2042 05e4 0000      		nop
 2043               	 ;  0 "" 2
 818:setup.c       **** 	wrPin_high;
 2044               		.loc 1 818 0
 2045               	/* #NOAPP */
 2046 05e6 969A      		sbi 0x12,6
 819:setup.c       **** 	cs_mreqPin_high;
 2047               		.loc 1 819 0
 2048 05e8 949A      		sbi 0x12,4
 820:setup.c       **** 	
 821:setup.c       **** 	// 0x2AA, 0x55
 822:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2049               		.loc 1 822 0
 2050 05ea 15BA      		out 0x15,__zero_reg__
 823:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2051               		.loc 1 823 0
 2052 05ec 32E0      		ldi r19,lo8(2)
 2053 05ee 3BBB      		out 0x1b,r19
 824:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2054               		.loc 1 824 0
 2055 05f0 28BB      		out 0x18,r18
 825:setup.c       **** 	cs_mreqPin_low;
 2056               		.loc 1 825 0
 2057 05f2 9498      		cbi 0x12,4
 826:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2058               		.loc 1 826 0
 2059 05f4 1BBA      		out 0x1b,__zero_reg__
 827:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2060               		.loc 1 827 0
 2061 05f6 88BB      		out 0x18,r24
 828:setup.c       **** 	wrPin_low;
 2062               		.loc 1 828 0
 2063 05f8 9698      		cbi 0x12,6
 829:setup.c       **** 	asm volatile("nop");
 2064               		.loc 1 829 0
 2065               	/* #APP */
 2066               	 ;  829 "setup.c" 1
 2067 05fa 0000      		nop
 2068               	 ;  0 "" 2
 830:setup.c       **** 	asm volatile("nop");
 2069               		.loc 1 830 0
 2070               	 ;  830 "setup.c" 1
 2071 05fc 0000      		nop
 2072               	 ;  0 "" 2
 831:setup.c       **** 	asm volatile("nop");
 2073               		.loc 1 831 0
 2074               	 ;  831 "setup.c" 1
 2075 05fe 0000      		nop
 2076               	 ;  0 "" 2
 832:setup.c       **** 	wrPin_high;
 2077               		.loc 1 832 0
 2078               	/* #NOAPP */
 2079 0600 969A      		sbi 0x12,6
 833:setup.c       **** 	cs_mreqPin_high;
 2080               		.loc 1 833 0
 2081 0602 949A      		sbi 0x12,4
 834:setup.c       **** 	
 835:setup.c       **** 	// 0x555, 0xA0;
 836:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2082               		.loc 1 836 0
 2083 0604 15BA      		out 0x15,__zero_reg__
 837:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2084               		.loc 1 837 0
 2085 0606 9BBB      		out 0x1b,r25
 838:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2086               		.loc 1 838 0
 2087 0608 88BB      		out 0x18,r24
 839:setup.c       **** 	cs_mreqPin_low;
 2088               		.loc 1 839 0
 2089 060a 9498      		cbi 0x12,4
 840:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2090               		.loc 1 840 0
 2091 060c 1BBA      		out 0x1b,__zero_reg__
 841:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2092               		.loc 1 841 0
 2093 060e 80EA      		ldi r24,lo8(-96)
 2094 0610 88BB      		out 0x18,r24
 842:setup.c       **** 	wrPin_low;
 2095               		.loc 1 842 0
 2096 0612 9698      		cbi 0x12,6
 843:setup.c       **** 	asm volatile("nop");
 2097               		.loc 1 843 0
 2098               	/* #APP */
 2099               	 ;  843 "setup.c" 1
 2100 0614 0000      		nop
 2101               	 ;  0 "" 2
 844:setup.c       **** 	asm volatile("nop");
 2102               		.loc 1 844 0
 2103               	 ;  844 "setup.c" 1
 2104 0616 0000      		nop
 2105               	 ;  0 "" 2
 845:setup.c       **** 	asm volatile("nop");
 2106               		.loc 1 845 0
 2107               	 ;  845 "setup.c" 1
 2108 0618 0000      		nop
 2109               	 ;  0 "" 2
 846:setup.c       **** 	wrPin_high;
 2110               		.loc 1 846 0
 2111               	/* #NOAPP */
 2112 061a 969A      		sbi 0x12,6
 847:setup.c       **** 	cs_mreqPin_high;
 2113               		.loc 1 847 0
 2114 061c 949A      		sbi 0x12,4
 2115 061e 0895      		ret
 2116               		.cfi_endproc
 2117               	.LFE42:
 2119               	.global	gba_flash_write_byte
 2121               	gba_flash_write_byte:
 2122               	.LFB43:
 848:setup.c       **** }	
 849:setup.c       **** 
 850:setup.c       **** 
 851:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 852:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 853:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2123               		.loc 1 853 0
 2124               		.cfi_startproc
 2125               	.LVL152:
 2126 0620 CF92      		push r12
 2127               	.LCFI36:
 2128               		.cfi_def_cfa_offset 3
 2129               		.cfi_offset 12, -2
 2130 0622 DF92      		push r13
 2131               	.LCFI37:
 2132               		.cfi_def_cfa_offset 4
 2133               		.cfi_offset 13, -3
 2134 0624 EF92      		push r14
 2135               	.LCFI38:
 2136               		.cfi_def_cfa_offset 5
 2137               		.cfi_offset 14, -4
 2138 0626 FF92      		push r15
 2139               	.LCFI39:
 2140               		.cfi_def_cfa_offset 6
 2141               		.cfi_offset 15, -5
 2142 0628 CF93      		push r28
 2143               	.LCFI40:
 2144               		.cfi_def_cfa_offset 7
 2145               		.cfi_offset 28, -6
 2146 062a DF93      		push r29
 2147               	.LCFI41:
 2148               		.cfi_def_cfa_offset 8
 2149               		.cfi_offset 29, -7
 2150               	/* prologue: function */
 2151               	/* frame size = 0 */
 2152               	/* stack size = 6 */
 2153               	.L__stack_usage = 6
 2154 062c 6B01      		movw r12,r22
 2155 062e 7C01      		movw r14,r24
 2156 0630 EA01      		movw r28,r20
 854:setup.c       **** 	if (isD0D1Swapped == 0) {
 2157               		.loc 1 854 0
 2158 0632 2111      		cpse r18,__zero_reg__
 2159 0634 00C0      		rjmp .L84
 855:setup.c       **** 		gba_flash_write_cycle_start();
 2160               		.loc 1 855 0
 2161 0636 00D0      		rcall gba_flash_write_cycle_start
 2162               	.LVL153:
 2163 0638 00C0      		rjmp .L85
 2164               	.LVL154:
 2165               	.L84:
 856:setup.c       **** 	}
 857:setup.c       **** 	else {
 858:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2166               		.loc 1 858 0
 2167 063a 00D0      		rcall gba_flash_write_cycle_start_swapped
 2168               	.LVL155:
 2169               	.L85:
 859:setup.c       **** 	}
 860:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2170               		.loc 1 860 0
 2171 063c AE01      		movw r20,r28
 2172 063e C701      		movw r24,r14
 2173 0640 B601      		movw r22,r12
 2174 0642 00D0      		rcall gba_flash_write_bus_cycle
 2175               	.LVL156:
 2176               	.LBB154:
 2177               	.LBB155:
 2178               		.loc 2 276 0
 2179 0644 25E0      		ldi r18,lo8(5)
 2180 0646 2A95      	1:	dec r18
 2181 0648 01F4      		brne 1b
 2182 064a 0000      		nop
 2183               	.LVL157:
 2184               	.LBE155:
 2185               	.LBE154:
 861:setup.c       **** 	_delay_us(2); // Wait byte program time
 862:setup.c       **** 	
 863:setup.c       **** 	// Verify data
 864:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2186               		.loc 1 864 0
 2187 064c C701      		movw r24,r14
 2188 064e B601      		movw r22,r12
 2189 0650 00D0      		rcall gba_read_16bit_data
 2190               	.LVL158:
 2191               	.L86:
 865:setup.c       **** 	while (data != dataVerify) {
 2192               		.loc 1 865 0
 2193 0652 8C17      		cp r24,r28
 2194 0654 9D07      		cpc r25,r29
 2195 0656 01F0      		breq .L88
 866:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2196               		.loc 1 866 0
 2197 0658 C701      		movw r24,r14
 2198 065a B601      		movw r22,r12
 2199 065c 00D0      		rcall gba_read_16bit_data
 2200               	.LVL159:
 2201               	.LBB156:
 2202               	.LBB157:
 2203               		.loc 2 276 0
 2204 065e 25E0      		ldi r18,lo8(5)
 2205 0660 2A95      	1:	dec r18
 2206 0662 01F4      		brne 1b
 2207 0664 0000      		nop
 2208 0666 00C0      		rjmp .L86
 2209               	.LVL160:
 2210               	.L88:
 2211               	/* epilogue start */
 2212               	.LBE157:
 2213               	.LBE156:
 867:setup.c       **** 		_delay_us(2);
 868:setup.c       **** 	}
 869:setup.c       **** }
 2214               		.loc 1 869 0
 2215 0668 DF91      		pop r29
 2216 066a CF91      		pop r28
 2217               	.LVL161:
 2218 066c FF90      		pop r15
 2219 066e EF90      		pop r14
 2220 0670 DF90      		pop r13
 2221 0672 CF90      		pop r12
 2222               	.LVL162:
 2223 0674 0895      		ret
 2224               		.cfi_endproc
 2225               	.LFE43:
 2227               	.global	setup
 2229               	setup:
 2230               	.LFB44:
 870:setup.c       **** 
 871:setup.c       **** 
 872:setup.c       **** // Setup
 873:setup.c       **** void setup(void) {
 2231               		.loc 1 873 0
 2232               		.cfi_startproc
 2233               	/* prologue: function */
 2234               	/* frame size = 0 */
 2235               	/* stack size = 0 */
 2236               	.L__stack_usage = 0
 874:setup.c       **** 	// Turn off watchdog
 875:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2237               		.loc 1 875 0
 2238 0676 84B7      		in r24,0x34
 2239 0678 877F      		andi r24,lo8(-9)
 2240 067a 84BF      		out 0x34,r24
 876:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2241               		.loc 1 876 0
 2242 067c 88E1      		ldi r24,lo8(24)
 2243 067e 81BD      		out 0x21,r24
 877:setup.c       **** 	WDTCR = 0;
 2244               		.loc 1 877 0
 2245 0680 11BC      		out 0x21,__zero_reg__
 878:setup.c       **** 	
 879:setup.c       **** 	// Reset common lines
 880:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2246               		.loc 1 880 0
 2247 0682 00D0      		rcall rd_wr_csmreq_cs2_reset
 2248               	.LVL163:
 881:setup.c       **** 	
 882:setup.c       **** 	// Set outputs
 883:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V) | (1<<VOLTA
 2249               		.loc 1 883 0
 2250 0684 81B3      		in r24,0x11
 2251 0686 8C6F      		ori r24,lo8(-4)
 2252 0688 81BB      		out 0x11,r24
 884:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2253               		.loc 1 884 0
 2254 068a 86B1      		in r24,0x6
 2255 068c 8560      		ori r24,lo8(5)
 2256 068e 86B9      		out 0x6,r24
 885:setup.c       **** 	
 886:setup.c       **** 	// Set all pins as inputs
 887:setup.c       **** 	PORT_DATA7_0 = 0;
 2257               		.loc 1 887 0
 2258 0690 15BA      		out 0x15,__zero_reg__
 888:setup.c       **** 	DDR_DATA7_0 = 0;
 2259               		.loc 1 888 0
 2260 0692 14BA      		out 0x14,__zero_reg__
 889:setup.c       **** 	PORT_ADDR7_0 = 0;
 2261               		.loc 1 889 0
 2262 0694 18BA      		out 0x18,__zero_reg__
 890:setup.c       **** 	DDR_ADDR7_0 = 0;
 2263               		.loc 1 890 0
 2264 0696 17BA      		out 0x17,__zero_reg__
 891:setup.c       **** 	PORT_ADDR15_8 = 0;
 2265               		.loc 1 891 0
 2266 0698 1BBA      		out 0x1b,__zero_reg__
 892:setup.c       **** 	DDR_ADDR15_8 = 0;
 2267               		.loc 1 892 0
 2268 069a 1ABA      		out 0x1a,__zero_reg__
 893:setup.c       **** 	
 894:setup.c       **** 	// Light up 3.3V or 5V
 895:setup.c       **** 	if (cartMode == GB_MODE) {
 2269               		.loc 1 895 0
 2270 069c 8091 0000 		lds r24,cartMode
 2271 06a0 8130      		cpi r24,lo8(1)
 2272 06a2 01F4      		brne .L90
 896:setup.c       **** 		PORTD |= (1<<LED_5V);
 2273               		.loc 1 896 0
 2274 06a4 979A      		sbi 0x12,7
 897:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2275               		.loc 1 897 0
 2276 06a6 3898      		cbi 0x7,0
 2277 06a8 00C0      		rjmp .L91
 2278               	.L90:
 898:setup.c       **** 	}
 899:setup.c       **** 	else {
 900:setup.c       **** 		PORTE |= (1<<LED_3V);
 2279               		.loc 1 900 0
 2280 06aa 389A      		sbi 0x7,0
 901:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2281               		.loc 1 901 0
 2282 06ac 9798      		cbi 0x12,7
 2283               	.L91:
 902:setup.c       **** 	}
 903:setup.c       **** 	
 904:setup.c       **** 	// Light LED
 905:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2284               		.loc 1 905 0
 2285 06ae 939A      		sbi 0x12,3
 2286               	.LVL164:
 2287               	.LBB158:
 2288               	.LBB159:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2289               		.loc 2 187 0
 2290 06b0 2FEF      		ldi r18,lo8(799999)
 2291 06b2 84E3      		ldi r24,hi8(799999)
 2292 06b4 9CE0      		ldi r25,hlo8(799999)
 2293 06b6 2150      	1:	subi r18,1
 2294 06b8 8040      		sbci r24,0
 2295 06ba 9040      		sbci r25,0
 2296 06bc 01F4      		brne 1b
 2297 06be 00C0      		rjmp .
 2298 06c0 0000      		nop
 2299               	.LVL165:
 2300               	.LBE159:
 2301               	.LBE158:
 906:setup.c       **** 	_delay_ms(500);
 907:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2302               		.loc 1 907 0
 2303 06c2 9398      		cbi 0x12,3
 908:setup.c       **** 	
 909:setup.c       **** 	// Setup USART
 910:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2304               		.loc 1 910 0
 2305 06c4 19B8      		out 0x9,__zero_reg__
 911:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2306               		.loc 1 911 0
 2307 06c6 599A      		sbi 0xb,1
 912:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2308               		.loc 1 912 0
 2309 06c8 539A      		sbi 0xa,3
 913:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2310               		.loc 1 913 0
 2311 06ca 549A      		sbi 0xa,4
 914:setup.c       **** 	
 915:setup.c       **** 	// Turn on interrupts
 916:setup.c       **** 	sei();
 2312               		.loc 1 916 0
 2313               	/* #APP */
 2314               	 ;  916 "setup.c" 1
 2315 06cc 7894      		sei
 2316               	 ;  0 "" 2
 2317               	/* #NOAPP */
 2318 06ce 0895      		ret
 2319               		.cfi_endproc
 2320               	.LFE44:
 2322               		.section	.text.startup,"ax",@progbits
 2323               	.global	main
 2325               	main:
 2326               	.LFB45:
 2327               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.3
   4:main.c        ****  Firmware version: R13
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 26/03/2019
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 4
  53:main.c        **** #define FIRMWARE_VERSION 14
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2328               		.loc 3 66 0
 2329               		.cfi_startproc
 2330               	/* prologue: function */
 2331               	/* frame size = 0 */
 2332               	/* stack size = 0 */
 2333               	.L__stack_usage = 0
  67:main.c        **** 	setup();
 2334               		.loc 3 67 0
 2335 0000 00D0      		rcall setup
 2336               	.LVL166:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 2337               		.loc 3 71 0
 2338 0002 6624      		clr r6
 2339 0004 6394      		inc r6
  70:main.c        **** 	uint8_t resetCommonLines = 1;
 2340               		.loc 3 70 0
 2341 0006 D1E0      		ldi r29,lo8(1)
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2342               		.loc 3 69 0
 2343 0008 C12C      		mov r12,__zero_reg__
 2344 000a D12C      		mov r13,__zero_reg__
 2345 000c 7601      		movw r14,r12
 2346               	.LBB160:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  78:main.c        **** 		
  79:main.c        **** 		// Return the cart mode in use
  80:main.c        **** 		if (receivedChar == CART_MODE) {
  81:main.c        **** 			USART_Transmit(cartMode);
  82:main.c        **** 		}
  83:main.c        **** 		
  84:main.c        **** 		// Change to GB mode or GBA mode if requested
  85:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  86:main.c        **** 			gb_mode();
  87:main.c        **** 		}
  88:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
  89:main.c        **** 			gba_mode();
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Switch voltage if requested
  93:main.c        **** 		else if (receivedChar == VOLTAGE_3_3V) {
  94:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
  95:main.c        **** 			cartMode = GBA_MODE;
  96:main.c        **** 			PORTE |= (1<<LED_3V);
  97:main.c        **** 			PORTD &= ~(1<<LED_5V);
  98:main.c        **** 		}
  99:main.c        **** 		else if (receivedChar == VOLTAGE_5V) {
 100:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 101:main.c        **** 			cartMode = GB_MODE;
 102:main.c        **** 			PORTD |= (1<<LED_5V);
 103:main.c        **** 			PORTE &= ~(1<<LED_3V);
 104:main.c        **** 		}
 105:main.c        **** 		
 106:main.c        **** 		
 107:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 108:main.c        **** 		
 109:main.c        **** 		// Set address
 110:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 111:main.c        **** 			usart_read_chars(); // Read start address
 112:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 113:main.c        **** 		}
 114:main.c        **** 		
 115:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 116:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 117:main.c        **** 			gb_mode();
 118:main.c        **** 			receivedChar = '1';
 119:main.c        **** 			while (receivedChar == '1') {
 120:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 121:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 122:main.c        **** 					USART_Transmit(read_8bit_data(address));
 123:main.c        **** 					address++;
 124:main.c        **** 				}
 125:main.c        **** 				
 126:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 127:main.c        **** 				receivedChar = USART_Receive();
 128:main.c        **** 			}
 129:main.c        **** 		}
 130:main.c        **** 		
 131:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 132:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 133:main.c        **** 			gb_mode();
 134:main.c        **** 			
 135:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 136:main.c        **** 			usart_read_bytes(64);
 137:main.c        **** 			
 138:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 139:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 140:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 141:main.c        **** 				address++;
 142:main.c        **** 			}
 143:main.c        **** 			
 144:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 145:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 146:main.c        **** 		}
 147:main.c        **** 		
 148:main.c        **** 		// Set bank address and write a byte
 149:main.c        **** 		else if (receivedChar == SET_BANK) {
 150:main.c        **** 			gb_mode();
 151:main.c        **** 			
 152:main.c        **** 			usart_read_chars(); // Read start address
 153:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 154:main.c        **** 			
 155:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 156:main.c        **** 			if (receivedChar == 'B') {
 157:main.c        **** 				usart_read_chars(); // Read data
 158:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 159:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 160:main.c        **** 				
 161:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 162:main.c        **** 			}
 163:main.c        **** 		}
 164:main.c        **** 		
 165:main.c        **** 		
 166:main.c        **** 		// ****** Gameboy Advance ******
 167:main.c        **** 		
 168:main.c        **** 		// ---------- ROM ----------
 169:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 170:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 171:main.c        **** 			gba_mode();
 172:main.c        **** 			
 173:main.c        **** 			uint8_t readEnd = 32;
 174:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 175:main.c        **** 				readEnd = 128;
 176:main.c        **** 			}
 177:main.c        **** 			
 178:main.c        **** 			receivedChar = '1';
 2347               		.loc 3 178 0
 2348 000e B1E3      		ldi r27,lo8(49)
 2349 0010 7B2E      		mov r7,r27
 2350               	.LBE160:
 2351               	.LBB163:
 179:main.c        **** 			while (receivedChar == '1') {
 180:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 181:main.c        **** 				
 182:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 183:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 184:main.c        **** 					
 185:main.c        **** 					// Low byte & High byte
 186:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 187:main.c        **** 					USART_Transmit(dataRead >> 8);
 188:main.c        **** 					
 189:main.c        **** 					address++;
 190:main.c        **** 				}
 191:main.c        **** 				
 192:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 193:main.c        **** 				receivedChar = USART_Receive();
 194:main.c        **** 			}
 195:main.c        **** 		}
 196:main.c        **** 		
 197:main.c        **** 		// ---------- SRAM ----------
 198:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 199:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 200:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 201:main.c        **** 			
 202:main.c        **** 			receivedChar = '1';
 203:main.c        **** 			while (receivedChar == '1') {
 204:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 205:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 206:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 207:main.c        **** 					address++;
 208:main.c        **** 				}
 209:main.c        **** 				
 210:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 211:main.c        **** 				receivedChar = USART_Receive();
 212:main.c        **** 			}
 213:main.c        **** 			
 214:main.c        **** 			gba_mode(); // Set back
 215:main.c        **** 		}
 216:main.c        **** 		
 217:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 218:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 219:main.c        **** 			gb_mode();
 220:main.c        **** 			
 221:main.c        **** 			usart_read_bytes(64);
 222:main.c        **** 			
 223:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 224:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 225:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 226:main.c        **** 				address++;
 227:main.c        **** 			}
 228:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 229:main.c        **** 			
 230:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 231:main.c        **** 			gba_mode(); // Set back
 232:main.c        **** 		}
 233:main.c        **** 		
 234:main.c        **** 		// Write 1 byte to SRAM address
 235:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 236:main.c        **** 			gb_mode();
 237:main.c        **** 			
 238:main.c        **** 			uint8_t data = USART_Receive();
 239:main.c        **** 			gba_write_ram_8bit_data(address, data);
 240:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 241:main.c        **** 			
 242:main.c        **** 			gba_mode(); // Set back
 243:main.c        **** 		}
 244:main.c        **** 		
 245:main.c        **** 		
 246:main.c        **** 		// ---------- FLASH ----------
 247:main.c        **** 		// Read the Flash Manufacturer and Device ID
 248:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 249:main.c        **** 			gb_mode();
 250:main.c        **** 			
 251:main.c        **** 			flash_read_chip_id();
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 253:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 254:main.c        **** 			
 255:main.c        **** 			gba_mode(); // Set back
 256:main.c        **** 		}
 257:main.c        **** 		
 258:main.c        **** 		// Change bank
 259:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 260:main.c        **** 			usart_read_chars(); // Read data
 261:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 262:main.c        **** 			
 263:main.c        **** 			gb_mode();
 264:main.c        **** 			flash_switch_bank(bank);
 265:main.c        **** 			
 266:main.c        **** 			gba_mode(); // Set back
 267:main.c        **** 		}
 268:main.c        **** 		
 269:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 270:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 271:main.c        **** 			gb_mode();
 272:main.c        **** 			
 273:main.c        **** 			usart_read_chars(); // Read sector
 274:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 275:main.c        **** 			
 276:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 277:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 278:main.c        **** 			
 279:main.c        **** 			gba_mode(); // Set back
 280:main.c        **** 		}
 281:main.c        **** 		
 282:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 283:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 284:main.c        **** 			gb_mode();
 285:main.c        **** 			
 286:main.c        **** 			usart_read_bytes(64);
 287:main.c        **** 			
 288:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 289:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 290:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 291:main.c        **** 				address++;
 292:main.c        **** 			}
 293:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 294:main.c        **** 			
 295:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 296:main.c        **** 			gba_mode(); // Set back
 297:main.c        **** 		}
 298:main.c        **** 		
 299:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 300:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 301:main.c        **** 			gb_mode();
 302:main.c        **** 			
 303:main.c        **** 			usart_read_bytes(128);
 304:main.c        **** 			
 305:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 306:main.c        **** 			flash_write_sector(address); // Address used as sector number
 307:main.c        **** 			address++;
 308:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 309:main.c        **** 			
 310:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 311:main.c        **** 			gba_mode(); // Set back
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		
 315:main.c        **** 		// ---------- EEPROM ----------
 316:main.c        **** 		// Set EEPROM size
 317:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 318:main.c        **** 			usart_read_chars(); // Read size
 319:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 320:main.c        **** 		}
 321:main.c        **** 		
 322:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 323:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 324:main.c        **** 			gba_eeprom_mode();
 325:main.c        **** 			
 326:main.c        **** 			receivedChar = '1';
 327:main.c        **** 			while (receivedChar == '1') {
 328:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 329:main.c        **** 				gba_eeprom_read(address, eepromSize);
 330:main.c        **** 				
 331:main.c        **** 				// Send back the 8 bytes of data
 332:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 333:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 334:main.c        **** 				}
 335:main.c        **** 				address++; // Increment to next 8 bytes
 336:main.c        **** 				
 337:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 338:main.c        **** 				receivedChar = USART_Receive();
 339:main.c        **** 			}
 340:main.c        **** 			
 341:main.c        **** 			gba_mode(); // Set back
 342:main.c        **** 		}
 343:main.c        **** 		
 344:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 345:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 346:main.c        **** 			gba_eeprom_mode();
 347:main.c        **** 			
 348:main.c        **** 			// Read 8 bytes from USART and place in buffer
 349:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 350:main.c        **** 				eepromBuffer[x] = USART_Receive();
 351:main.c        **** 			}
 352:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 353:main.c        **** 			
 354:main.c        **** 			gba_eeprom_write(address, eepromSize);
 355:main.c        **** 			address++;
 356:main.c        **** 			
 357:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 358:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 359:main.c        **** 			
 360:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 361:main.c        **** 			gba_mode(); // Set back
 362:main.c        **** 		}
 363:main.c        **** 		
 364:main.c        **** 		
 365:main.c        **** 		// ---------- GB FLASH CARTS ----------
 366:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 367:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 368:main.c        **** 			flashWriteWePin = USART_Receive();
 369:main.c        **** 			
 370:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 371:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 372:main.c        **** 				audioPin_high;
 373:main.c        **** 			}
 374:main.c        **** 		}
 375:main.c        **** 		
 376:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 377:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 378:main.c        **** 			flashBank1CommandWrites = 1;
 379:main.c        **** 		}
 380:main.c        **** 		
 381:main.c        **** 		// Load the program method to use
 382:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 383:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 384:main.c        **** 				usart_read_chars(); // Address
 385:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 386:main.c        **** 				USART_Transmit(SEND_ACK);
 387:main.c        **** 				
 388:main.c        **** 				usart_read_chars(); // Data
 389:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 390:main.c        **** 				USART_Transmit(SEND_ACK);
 391:main.c        **** 			}
 392:main.c        **** 		}
 393:main.c        **** 		
 394:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 395:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 396:main.c        **** 			usart_read_chars(); // Read address
 397:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 398:main.c        **** 			
 399:main.c        **** 			usart_read_chars(); // Read data byte
 400:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 401:main.c        **** 			
 402:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 403:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 404:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 405:main.c        **** 			
 406:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 407:main.c        **** 		}
 408:main.c        **** 		
 409:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 410:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 411:main.c        **** 			usart_read_bytes(64);
 412:main.c        **** 			
 413:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 414:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 415:main.c        **** 				if (flashBank1CommandWrites == 0) {
 416:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 417:main.c        **** 				}
 418:main.c        **** 				else { // Some flash carts need to change to bank 1 to issue flash commands
 419:main.c        **** 					gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 420:main.c        **** 				}
 421:main.c        **** 				address++;
 422:main.c        **** 			}
 423:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 424:main.c        **** 			
 425:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 426:main.c        **** 		}
 427:main.c        **** 		
 428:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 429:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 430:main.c        **** 			usart_read_bytes(32);
 431:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 432:main.c        **** 			
 433:main.c        **** 			// Setup buffered write
 434:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 435:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 436:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 437:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 438:main.c        **** 			_delay_us(1);
 439:main.c        **** 			
 440:main.c        **** 			// Write data
 441:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 442:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 443:main.c        **** 				address++;
 444:main.c        **** 			}
 445:main.c        **** 			
 446:main.c        **** 			// Write buffer to flash
 447:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 448:main.c        **** 			_delay_us(200);
 449:main.c        **** 			
 450:main.c        **** 			// Verify last byte written
 451:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 452:main.c        **** 			uint8_t verifyCount = 0;
 453:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 454:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 455:main.c        **** 				_delay_us(5);
 456:main.c        **** 				verifyCount++;
 457:main.c        **** 				if (verifyCount >= 200) {
 458:main.c        **** 					_delay_ms(500);
 459:main.c        **** 					break;
 460:main.c        **** 				}
 461:main.c        **** 			}
 462:main.c        **** 			
 463:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 464:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 465:main.c        **** 		}
 466:main.c        **** 		
 467:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 468:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 469:main.c        **** 			usart_read_bytes(256);
 470:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 471:main.c        **** 			
 472:main.c        **** 			// Setup buffered write
 473:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 474:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 475:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 476:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 477:main.c        **** 			_delay_us(50);
 478:main.c        **** 			
 479:main.c        **** 			// Write data
 480:main.c        **** 			for (int x = 0; x < 256; x++) {
 481:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 482:main.c        **** 				address++;
 483:main.c        **** 			}
 484:main.c        **** 			
 485:main.c        **** 			// Write buffer to flash
 486:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 487:main.c        **** 			
 488:main.c        **** 			// Verify last byte written
 489:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 490:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 491:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 492:main.c        **** 				_delay_us(5);
 493:main.c        **** 			}
 494:main.c        **** 			
 495:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 496:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 497:main.c        **** 		}
 498:main.c        **** 		
 499:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 500:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 501:main.c        **** 			usart_read_bytes(128);
 502:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 503:main.c        **** 			
 504:main.c        **** 			// Enable flash chip access
 505:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 506:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 507:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 508:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 509:main.c        **** 			_delay_us(5);
 510:main.c        **** 			
 511:main.c        **** 			// Re-Enable writes to MBC registers
 512:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 513:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 514:main.c        **** 			_delay_us(5);
 515:main.c        **** 			
 516:main.c        **** 			// Bank 1 for commands
 517:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 518:main.c        **** 			_delay_us(5);
 519:main.c        **** 			
 520:main.c        **** 			
 521:main.c        **** 			// Write setup
 522:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 523:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 524:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 525:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 526:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 527:main.c        **** 			_delay_us(5);
 528:main.c        **** 			
 529:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 530:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 531:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 532:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 533:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 534:main.c        **** 			_delay_us(5);
 535:main.c        **** 			
 536:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 537:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 538:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 539:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 540:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 541:main.c        **** 			_delay_us(5);
 542:main.c        **** 			
 543:main.c        **** 			// Set bank back
 544:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 545:main.c        **** 			_delay_us(5);
 546:main.c        **** 			
 547:main.c        **** 			// Disable writes to MBC registers
 548:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 549:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 550:main.c        **** 			_delay_us(5);
 551:main.c        **** 			
 552:main.c        **** 			// Undo Wakeup
 553:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 554:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 555:main.c        **** 			_delay_us(5);
 556:main.c        **** 			
 557:main.c        **** 			
 558:main.c        **** 			// Write data
 559:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 560:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 561:main.c        **** 				_delay_us(5);
 562:main.c        **** 				address++;
 563:main.c        **** 			}
 564:main.c        **** 			
 565:main.c        **** 			// Write buffer to flash
 566:main.c        **** 			address--;
 567:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 568:main.c        **** 			address++;
 569:main.c        **** 			_delay_ms(10);
 570:main.c        **** 			
 571:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 572:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 573:main.c        **** 		}
 574:main.c        **** 		
 575:main.c        **** 		
 576:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 577:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 578:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 579:main.c        **** 			usart_read_chars(); // Read address
 580:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 581:main.c        **** 			
 582:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 583:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 584:main.c        **** 				usart_read_chars(); // Read data
 585:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 586:main.c        **** 				
 587:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 588:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 589:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 590:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 591:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 592:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 593:main.c        **** 				
 594:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 595:main.c        **** 			}
 596:main.c        **** 		}
 597:main.c        **** 		
 598:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 599:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 600:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 601:main.c        **** 			
 602:main.c        **** 			int readLength = 64;
 603:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 604:main.c        **** 				readLength = 256;
 605:main.c        **** 			}
 606:main.c        **** 			usart_read_bytes(readLength);
 607:main.c        **** 			
 608:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 609:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 610:main.c        **** 				gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 611:main.c        **** 				address++;
 612:main.c        **** 			}
 613:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 614:main.c        **** 			
 615:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 616:main.c        **** 		}
 617:main.c        **** 		
 618:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 619:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 620:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 621:main.c        **** 			
 622:main.c        **** 			int readLength = 256;
 623:main.c        **** 			usart_read_bytes(readLength);
 624:main.c        **** 			
 625:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 626:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 627:main.c        **** 				gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 628:main.c        **** 				address++;
 629:main.c        **** 			}
 630:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 631:main.c        **** 			
 632:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 633:main.c        **** 		}
 634:main.c        **** 		
 635:main.c        **** 		// Intel flash command based chips
 636:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 637:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 638:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 639:main.c        **** 			usart_read_bytes(64);
 640:main.c        **** 			
 641:main.c        **** 			// Set address lines as outputs
 642:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2352               		.loc 3 642 0
 2353 0012 CFEF      		ldi r28,lo8(-1)
 2354               	.LVL167:
 2355               	.L93:
 2356               	.LBE163:
  74:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2357               		.loc 3 74 0
 2358 0014 21E0      		ldi r18,lo8(1)
 2359 0016 6212      		cpse r6,r18
 2360 0018 00C0      		rjmp .L94
 2361               	.LVL168:
 2362               	.L230:
  75:main.c        **** 		}
 2363               		.loc 3 75 0
 2364 001a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2365               	.LVL169:
 2366               	.L94:
  77:main.c        **** 		
 2367               		.loc 3 77 0
 2368 001c 00D0      		rcall USART_Receive
 2369               	.LVL170:
 2370 001e 8093 0000 		sts receivedChar,r24
  80:main.c        **** 			USART_Transmit(cartMode);
 2371               		.loc 3 80 0
 2372 0022 8334      		cpi r24,lo8(67)
 2373 0024 01F4      		brne .L95
  81:main.c        **** 		}
 2374               		.loc 3 81 0
 2375 0026 8091 0000 		lds r24,cartMode
 2376 002a 00C0      		rjmp .L231
 2377               	.L95:
  85:main.c        **** 			gb_mode();
 2378               		.loc 3 85 0
 2379 002c 8734      		cpi r24,lo8(71)
 2380 002e 01F4      		brne .L97
  86:main.c        **** 		}
 2381               		.loc 3 86 0
 2382 0030 00D0      		rcall gb_mode
 2383               	.LVL171:
 2384 0032 00C0      		rjmp .L93
 2385               	.L97:
  88:main.c        **** 			gba_mode();
 2386               		.loc 3 88 0
 2387 0034 8736      		cpi r24,lo8(103)
 2388 0036 01F4      		brne .+2
 2389 0038 00C0      		rjmp .L233
  93:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
 2390               		.loc 3 93 0
 2391 003a 8333      		cpi r24,lo8(51)
 2392 003c 01F4      		brne .L99
  94:main.c        **** 			cartMode = GBA_MODE;
 2393               		.loc 3 94 0
 2394 003e 9298      		cbi 0x12,2
  95:main.c        **** 			PORTE |= (1<<LED_3V);
 2395               		.loc 3 95 0
 2396 0040 82E0      		ldi r24,lo8(2)
 2397 0042 8093 0000 		sts cartMode,r24
  96:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2398               		.loc 3 96 0
 2399 0046 389A      		sbi 0x7,0
  97:main.c        **** 		}
 2400               		.loc 3 97 0
 2401 0048 9798      		cbi 0x12,7
 2402 004a 00C0      		rjmp .L93
 2403               	.L99:
  99:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 2404               		.loc 3 99 0
 2405 004c 8533      		cpi r24,lo8(53)
 2406 004e 01F4      		brne .L100
 100:main.c        **** 			cartMode = GB_MODE;
 2407               		.loc 3 100 0
 2408 0050 929A      		sbi 0x12,2
 101:main.c        **** 			PORTD |= (1<<LED_5V);
 2409               		.loc 3 101 0
 2410 0052 81E0      		ldi r24,lo8(1)
 2411 0054 8093 0000 		sts cartMode,r24
 102:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2412               		.loc 3 102 0
 2413 0058 979A      		sbi 0x12,7
 103:main.c        **** 		}
 2414               		.loc 3 103 0
 2415 005a 3898      		cbi 0x7,0
 2416 005c 00C0      		rjmp .L93
 2417               	.L100:
 110:main.c        **** 			usart_read_chars(); // Read start address
 2418               		.loc 3 110 0
 2419 005e 8134      		cpi r24,lo8(65)
 2420 0060 01F4      		brne .L101
 111:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2421               		.loc 3 111 0
 2422 0062 00D0      		rcall usart_read_chars
 2423               	.LVL172:
 112:main.c        **** 		}
 2424               		.loc 3 112 0
 2425 0064 40E1      		ldi r20,lo8(16)
 2426 0066 50E0      		ldi r21,0
 2427 0068 60E0      		ldi r22,0
 2428 006a 70E0      		ldi r23,0
 2429 006c 80E0      		ldi r24,lo8(receivedBuffer)
 2430 006e 90E0      		ldi r25,hi8(receivedBuffer)
 2431 0070 00D0      		rcall strtol
 2432               	.LVL173:
 2433 0072 6B01      		movw r12,r22
 2434 0074 7C01      		movw r14,r24
 2435               	.LVL174:
 2436 0076 00C0      		rjmp .L93
 2437               	.L101:
 116:main.c        **** 			gb_mode();
 2438               		.loc 3 116 0
 2439 0078 8235      		cpi r24,lo8(82)
 2440 007a 01F4      		brne .L102
 117:main.c        **** 			receivedChar = '1';
 2441               		.loc 3 117 0
 2442 007c 00D0      		rcall gb_mode
 2443               	.LVL175:
 118:main.c        **** 			while (receivedChar == '1') {
 2444               		.loc 3 118 0
 2445 007e 7092 0000 		sts receivedChar,r7
 2446               	.LVL176:
 2447               	.L103:
 119:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2448               		.loc 3 119 0
 2449 0082 8091 0000 		lds r24,receivedChar
 2450 0086 8133      		cpi r24,lo8(49)
 2451 0088 01F4      		brne .L93
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2452               		.loc 3 120 0
 2453 008a 939A      		sbi 0x12,3
 2454               	.LVL177:
 2455 008c 00E0      		ldi r16,0
 2456 008e 10E0      		ldi r17,0
 2457               	.LVL178:
 2458               	.L104:
 2459               	.LBB174:
 122:main.c        **** 					address++;
 2460               		.loc 3 122 0 discriminator 3
 2461 0090 C801      		movw r24,r16
 2462 0092 8C0D      		add r24,r12
 2463 0094 9D1D      		adc r25,r13
 2464 0096 00D0      		rcall read_8bit_data
 2465               	.LVL179:
 2466 0098 00D0      		rcall USART_Transmit
 2467               	.LVL180:
 2468 009a 0F5F      		subi r16,-1
 2469 009c 1F4F      		sbci r17,-1
 2470               	.LVL181:
 121:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2471               		.loc 3 121 0 discriminator 3
 2472 009e 0034      		cpi r16,64
 2473 00a0 1105      		cpc r17,__zero_reg__
 2474 00a2 01F4      		brne .L104
 2475 00a4 90E4      		ldi r25,64
 2476 00a6 C90E      		add r12,r25
 2477 00a8 D11C      		adc r13,__zero_reg__
 2478 00aa E11C      		adc r14,__zero_reg__
 2479 00ac F11C      		adc r15,__zero_reg__
 2480               	.LBE174:
 126:main.c        **** 				receivedChar = USART_Receive();
 2481               		.loc 3 126 0
 2482 00ae 9398      		cbi 0x12,3
 127:main.c        **** 			}
 2483               		.loc 3 127 0
 2484 00b0 00D0      		rcall USART_Receive
 2485               	.LVL182:
 2486 00b2 8093 0000 		sts receivedChar,r24
 2487 00b6 00C0      		rjmp .L103
 2488               	.LVL183:
 2489               	.L102:
 132:main.c        **** 			gb_mode();
 2490               		.loc 3 132 0
 2491 00b8 8735      		cpi r24,lo8(87)
 2492 00ba 01F4      		brne .L106
 133:main.c        **** 			
 2493               		.loc 3 133 0
 2494 00bc 00D0      		rcall gb_mode
 2495               	.LVL184:
 136:main.c        **** 			
 2496               		.loc 3 136 0
 2497 00be 80E4      		ldi r24,lo8(64)
 2498 00c0 90E0      		ldi r25,0
 2499 00c2 00D0      		rcall usart_read_bytes
 2500               	.LVL185:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2501               		.loc 3 138 0
 2502 00c4 939A      		sbi 0x12,3
 2503               	.LVL186:
 2504 00c6 A0E0      		ldi r26,lo8(receivedBuffer)
 2505 00c8 AA2E      		mov r10,r26
 2506 00ca A0E0      		ldi r26,hi8(receivedBuffer)
 2507 00cc BA2E      		mov r11,r26
 2508 00ce 00E0      		ldi r16,0
 2509 00d0 10E0      		ldi r17,0
 2510               	.LVL187:
 2511               	.L107:
 2512               	.LBB175:
 140:main.c        **** 				address++;
 2513               		.loc 3 140 0 discriminator 3
 2514 00d2 F501      		movw r30,r10
 2515 00d4 6191      		ld r22,Z+
 2516 00d6 5F01      		movw r10,r30
 2517 00d8 C801      		movw r24,r16
 2518 00da 8C0D      		add r24,r12
 2519 00dc 9D1D      		adc r25,r13
 2520 00de 41E0      		ldi r20,lo8(1)
 2521 00e0 00D0      		rcall write_8bit_data
 2522               	.LVL188:
 2523 00e2 0F5F      		subi r16,-1
 2524 00e4 1F4F      		sbci r17,-1
 2525               	.LVL189:
 139:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2526               		.loc 3 139 0 discriminator 3
 2527 00e6 0034      		cpi r16,64
 2528 00e8 1105      		cpc r17,__zero_reg__
 2529 00ea 01F4      		brne .L107
 2530 00ec F0E4      		ldi r31,64
 2531 00ee CF0E      		add r12,r31
 2532 00f0 D11C      		adc r13,__zero_reg__
 2533 00f2 E11C      		adc r14,__zero_reg__
 2534 00f4 F11C      		adc r15,__zero_reg__
 2535 00f6 00C0      		rjmp .L250
 2536               	.LVL190:
 2537               	.L106:
 2538               	.LBE175:
 149:main.c        **** 			gb_mode();
 2539               		.loc 3 149 0
 2540 00f8 8234      		cpi r24,lo8(66)
 2541 00fa 01F4      		brne .L108
 2542               	.LBB176:
 150:main.c        **** 			
 2543               		.loc 3 150 0
 2544 00fc 00D0      		rcall gb_mode
 2545               	.LVL191:
 152:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2546               		.loc 3 152 0
 2547 00fe 00D0      		rcall usart_read_chars
 2548               	.LVL192:
 153:main.c        **** 			
 2549               		.loc 3 153 0
 2550 0100 40E1      		ldi r20,lo8(16)
 2551 0102 50E0      		ldi r21,0
 2552 0104 60E0      		ldi r22,0
 2553 0106 70E0      		ldi r23,0
 2554 0108 80E0      		ldi r24,lo8(receivedBuffer)
 2555 010a 90E0      		ldi r25,hi8(receivedBuffer)
 2556 010c 00D0      		rcall strtol
 2557               	.LVL193:
 2558 010e 4B01      		movw r8,r22
 2559 0110 5C01      		movw r10,r24
 2560               	.LVL194:
 155:main.c        **** 			if (receivedChar == 'B') {
 2561               		.loc 3 155 0
 2562 0112 00D0      		rcall USART_Receive
 2563               	.LVL195:
 2564 0114 8093 0000 		sts receivedChar,r24
 156:main.c        **** 				usart_read_chars(); // Read data
 2565               		.loc 3 156 0
 2566 0118 8234      		cpi r24,lo8(66)
 2567 011a 01F0      		breq .+2
 2568 011c 00C0      		rjmp .L93
 2569               	.LBB177:
 157:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2570               		.loc 3 157 0
 2571 011e 00D0      		rcall usart_read_chars
 2572               	.LVL196:
 158:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2573               		.loc 3 158 0
 2574 0120 80E0      		ldi r24,lo8(receivedBuffer)
 2575 0122 90E0      		ldi r25,hi8(receivedBuffer)
 2576 0124 00D0      		rcall atoi
 2577               	.LVL197:
 159:main.c        **** 				
 2578               		.loc 3 159 0
 2579 0126 8093 0000 		sts lastBankAccessed,r24
 161:main.c        **** 			}
 2580               		.loc 3 161 0
 2581 012a 40E0      		ldi r20,0
 2582 012c 682F      		mov r22,r24
 2583 012e C401      		movw r24,r8
 2584               	.LVL198:
 2585 0130 00D0      		rcall write_8bit_data
 2586               	.LVL199:
 2587 0132 00C0      		rjmp .L93
 2588               	.LVL200:
 2589               	.L108:
 2590               	.LBE177:
 2591               	.LBE176:
 170:main.c        **** 			gba_mode();
 2592               		.loc 3 170 0
 2593 0134 8237      		cpi r24,lo8(114)
 2594 0136 01F0      		breq .L109
 170:main.c        **** 			gba_mode();
 2595               		.loc 3 170 0 is_stmt 0 discriminator 1
 2596 0138 8A36      		cpi r24,lo8(106)
 2597 013a 01F4      		brne .L110
 2598               	.L109:
 2599               	.LBB178:
 171:main.c        **** 			
 2600               		.loc 3 171 0 is_stmt 1
 2601 013c 00D0      		rcall gba_mode
 2602               	.LVL201:
 174:main.c        **** 				readEnd = 128;
 2603               		.loc 3 174 0
 2604 013e 8091 0000 		lds r24,receivedChar
 2605 0142 8A36      		cpi r24,lo8(106)
 2606 0144 01F4      		brne .L202
 175:main.c        **** 			}
 2607               		.loc 3 175 0
 2608 0146 10E8      		ldi r17,lo8(-128)
 2609 0148 00C0      		rjmp .L111
 2610               	.L202:
 173:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2611               		.loc 3 173 0
 2612 014a 10E2      		ldi r17,lo8(32)
 2613               	.L111:
 2614               	.LVL202:
 178:main.c        **** 			while (receivedChar == '1') {
 2615               		.loc 3 178 0
 2616 014c 7092 0000 		sts receivedChar,r7
 2617 0150 8824      		clr r8
 2618 0152 8A94      		dec r8
 2619 0154 810E      		add r8,r17
 2620 0156 912C      		mov r9,__zero_reg__
 2621 0158 A12C      		mov r10,__zero_reg__
 2622 015a B12C      		mov r11,__zero_reg__
 2623 015c 2FEF      		ldi r18,-1
 2624 015e 821A      		sub r8,r18
 2625 0160 920A      		sbc r9,r18
 2626 0162 A20A      		sbc r10,r18
 2627 0164 B20A      		sbc r11,r18
 2628               	.LVL203:
 2629               	.L112:
 179:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2630               		.loc 3 179 0
 2631 0166 8091 0000 		lds r24,receivedChar
 2632 016a 8133      		cpi r24,lo8(49)
 2633 016c 01F0      		breq .+2
 2634 016e 00C0      		rjmp .L93
 180:main.c        **** 				
 2635               		.loc 3 180 0
 2636 0170 939A      		sbi 0x12,3
 2637               	.LVL204:
 2638 0172 1601      		movw r2,r12
 2639 0174 2701      		movw r4,r14
 2640               	.LVL205:
 2641               	.L113:
 2642               	.LBB161:
 2643               	.LBB162:
 183:main.c        **** 					
 2644               		.loc 3 183 0 discriminator 3
 2645 0176 C201      		movw r24,r4
 2646 0178 B101      		movw r22,r2
 2647 017a 00D0      		rcall gba_read_16bit_data
 2648               	.LVL206:
 2649 017c 092F      		mov r16,r25
 2650               	.LVL207:
 186:main.c        **** 					USART_Transmit(dataRead >> 8);
 2651               		.loc 3 186 0 discriminator 3
 2652 017e 00D0      		rcall USART_Transmit
 2653               	.LVL208:
 187:main.c        **** 					
 2654               		.loc 3 187 0 discriminator 3
 2655 0180 802F      		mov r24,r16
 2656 0182 00D0      		rcall USART_Transmit
 2657               	.LVL209:
 189:main.c        **** 				}
 2658               		.loc 3 189 0 discriminator 3
 2659 0184 8FEF      		ldi r24,-1
 2660 0186 281A      		sub r2,r24
 2661 0188 380A      		sbc r3,r24
 2662 018a 480A      		sbc r4,r24
 2663 018c 580A      		sbc r5,r24
 2664               	.LVL210:
 2665               	.LBE162:
 182:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2666               		.loc 3 182 0 discriminator 3
 2667 018e 822D      		mov r24,r2
 2668 0190 8C19      		sub r24,r12
 2669 0192 8117      		cp r24,r17
 2670 0194 00F0      		brlo .L113
 2671 0196 C80C      		add r12,r8
 2672 0198 D91C      		adc r13,r9
 2673 019a EA1C      		adc r14,r10
 2674 019c FB1C      		adc r15,r11
 2675               	.LVL211:
 2676               	.LBE161:
 192:main.c        **** 				receivedChar = USART_Receive();
 2677               		.loc 3 192 0
 2678 019e 9398      		cbi 0x12,3
 193:main.c        **** 			}
 2679               		.loc 3 193 0
 2680 01a0 00D0      		rcall USART_Receive
 2681               	.LVL212:
 2682 01a2 8093 0000 		sts receivedChar,r24
 2683 01a6 00C0      		rjmp .L112
 2684               	.LVL213:
 2685               	.L110:
 2686               	.LBE178:
 199:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2687               		.loc 3 199 0
 2688 01a8 8D36      		cpi r24,lo8(109)
 2689 01aa 01F4      		brne .L115
 200:main.c        **** 			
 2690               		.loc 3 200 0
 2691 01ac 00D0      		rcall gb_mode
 2692               	.LVL214:
 202:main.c        **** 			while (receivedChar == '1') {
 2693               		.loc 3 202 0
 2694 01ae 7092 0000 		sts receivedChar,r7
 2695               	.LVL215:
 2696               	.L116:
 203:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2697               		.loc 3 203 0
 2698 01b2 8091 0000 		lds r24,receivedChar
 2699 01b6 8133      		cpi r24,lo8(49)
 2700 01b8 01F4      		brne .L233
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2701               		.loc 3 204 0
 2702 01ba 939A      		sbi 0x12,3
 2703               	.LVL216:
 2704 01bc 00E0      		ldi r16,0
 2705 01be 10E0      		ldi r17,0
 2706               	.LVL217:
 2707               	.L117:
 2708               	.LBB179:
 206:main.c        **** 					address++;
 2709               		.loc 3 206 0 discriminator 3
 2710 01c0 C801      		movw r24,r16
 2711 01c2 8C0D      		add r24,r12
 2712 01c4 9D1D      		adc r25,r13
 2713 01c6 00D0      		rcall gba_read_ram_8bit_data
 2714               	.LVL218:
 2715 01c8 00D0      		rcall USART_Transmit
 2716               	.LVL219:
 2717 01ca 0F5F      		subi r16,-1
 2718 01cc 1F4F      		sbci r17,-1
 2719               	.LVL220:
 205:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2720               		.loc 3 205 0 discriminator 3
 2721 01ce 0034      		cpi r16,64
 2722 01d0 1105      		cpc r17,__zero_reg__
 2723 01d2 01F4      		brne .L117
 2724 01d4 90E4      		ldi r25,64
 2725 01d6 C90E      		add r12,r25
 2726 01d8 D11C      		adc r13,__zero_reg__
 2727 01da E11C      		adc r14,__zero_reg__
 2728 01dc F11C      		adc r15,__zero_reg__
 2729               	.LBE179:
 210:main.c        **** 				receivedChar = USART_Receive();
 2730               		.loc 3 210 0
 2731 01de 9398      		cbi 0x12,3
 211:main.c        **** 			}
 2732               		.loc 3 211 0
 2733 01e0 00D0      		rcall USART_Receive
 2734               	.LVL221:
 2735 01e2 8093 0000 		sts receivedChar,r24
 2736 01e6 00C0      		rjmp .L116
 2737               	.LVL222:
 2738               	.L115:
 218:main.c        **** 			gb_mode();
 2739               		.loc 3 218 0
 2740 01e8 8737      		cpi r24,lo8(119)
 2741 01ea 01F4      		brne .L119
 219:main.c        **** 			
 2742               		.loc 3 219 0
 2743 01ec 00D0      		rcall gb_mode
 2744               	.LVL223:
 221:main.c        **** 			
 2745               		.loc 3 221 0
 2746 01ee 80E4      		ldi r24,lo8(64)
 2747 01f0 90E0      		ldi r25,0
 2748 01f2 00D0      		rcall usart_read_bytes
 2749               	.LVL224:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2750               		.loc 3 223 0
 2751 01f4 939A      		sbi 0x12,3
 2752               	.LVL225:
 2753 01f6 F0E0      		ldi r31,lo8(receivedBuffer)
 2754 01f8 AF2E      		mov r10,r31
 2755 01fa F0E0      		ldi r31,hi8(receivedBuffer)
 2756 01fc BF2E      		mov r11,r31
 2757 01fe 00E0      		ldi r16,0
 2758 0200 10E0      		ldi r17,0
 2759               	.LVL226:
 2760               	.L120:
 2761               	.LBB180:
 225:main.c        **** 				address++;
 2762               		.loc 3 225 0 discriminator 3
 2763 0202 F501      		movw r30,r10
 2764 0204 6191      		ld r22,Z+
 2765 0206 5F01      		movw r10,r30
 2766 0208 C801      		movw r24,r16
 2767 020a 8C0D      		add r24,r12
 2768 020c 9D1D      		adc r25,r13
 2769 020e 00D0      		rcall gba_write_ram_8bit_data
 2770               	.LVL227:
 2771 0210 0F5F      		subi r16,-1
 2772 0212 1F4F      		sbci r17,-1
 2773               	.LVL228:
 224:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2774               		.loc 3 224 0 discriminator 3
 2775 0214 0034      		cpi r16,64
 2776 0216 1105      		cpc r17,__zero_reg__
 2777 0218 01F4      		brne .L120
 2778               	.LVL229:
 2779               	.L236:
 2780 021a F0E4      		ldi r31,64
 2781 021c CF0E      		add r12,r31
 2782 021e D11C      		adc r13,__zero_reg__
 2783 0220 E11C      		adc r14,__zero_reg__
 2784 0222 F11C      		adc r15,__zero_reg__
 2785               	.L235:
 2786               	.LBE180:
 228:main.c        **** 			
 2787               		.loc 3 228 0
 2788 0224 81E3      		ldi r24,lo8(49)
 2789 0226 00D0      		rcall USART_Transmit
 2790               	.LVL230:
 230:main.c        **** 			gba_mode(); // Set back
 2791               		.loc 3 230 0
 2792 0228 9398      		cbi 0x12,3
 2793               	.L233:
 231:main.c        **** 		}
 2794               		.loc 3 231 0
 2795 022a 00D0      		rcall gba_mode
 2796               	.LVL231:
 2797 022c 00C0      		rjmp .L93
 2798               	.LVL232:
 2799               	.L119:
 235:main.c        **** 			gb_mode();
 2800               		.loc 3 235 0
 2801 022e 8F36      		cpi r24,lo8(111)
 2802 0230 01F4      		brne .L121
 2803               	.LBB181:
 236:main.c        **** 			
 2804               		.loc 3 236 0
 2805 0232 00D0      		rcall gb_mode
 2806               	.LVL233:
 238:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2807               		.loc 3 238 0
 2808 0234 00D0      		rcall USART_Receive
 2809               	.LVL234:
 239:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2810               		.loc 3 239 0
 2811 0236 682F      		mov r22,r24
 2812 0238 C601      		movw r24,r12
 2813               	.LVL235:
 2814 023a 00D0      		rcall gba_write_ram_8bit_data
 2815               	.LVL236:
 2816 023c 00C0      		rjmp .L238
 2817               	.L121:
 2818               	.LBE181:
 248:main.c        **** 			gb_mode();
 2819               		.loc 3 248 0
 2820 023e 8936      		cpi r24,lo8(105)
 2821 0240 01F4      		brne .L122
 249:main.c        **** 			
 2822               		.loc 3 249 0
 2823 0242 00D0      		rcall gb_mode
 2824               	.LVL237:
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2825               		.loc 3 251 0
 2826 0244 00D0      		rcall flash_read_chip_id
 2827               	.LVL238:
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2828               		.loc 3 252 0
 2829 0246 8091 0000 		lds r24,flashChipIdBuffer
 2830 024a 00D0      		rcall USART_Transmit
 2831               	.LVL239:
 253:main.c        **** 			
 2832               		.loc 3 253 0
 2833 024c 8091 0000 		lds r24,flashChipIdBuffer+1
 2834               	.L237:
 2835 0250 00D0      		rcall USART_Transmit
 2836               	.LVL240:
 2837 0252 00C0      		rjmp .L233
 2838               	.L122:
 259:main.c        **** 			usart_read_chars(); // Read data
 2839               		.loc 3 259 0
 2840 0254 8B36      		cpi r24,lo8(107)
 2841 0256 01F4      		brne .L123
 2842               	.LBB182:
 260:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2843               		.loc 3 260 0
 2844 0258 00D0      		rcall usart_read_chars
 2845               	.LVL241:
 261:main.c        **** 			
 2846               		.loc 3 261 0
 2847 025a 80E0      		ldi r24,lo8(receivedBuffer)
 2848 025c 90E0      		ldi r25,hi8(receivedBuffer)
 2849 025e 00D0      		rcall atoi
 2850               	.LVL242:
 2851 0260 182F      		mov r17,r24
 2852               	.LVL243:
 263:main.c        **** 			flash_switch_bank(bank);
 2853               		.loc 3 263 0
 2854 0262 00D0      		rcall gb_mode
 2855               	.LVL244:
 264:main.c        **** 			
 2856               		.loc 3 264 0
 2857 0264 812F      		mov r24,r17
 2858 0266 00D0      		rcall flash_switch_bank
 2859               	.LVL245:
 2860 0268 00C0      		rjmp .L233
 2861               	.LVL246:
 2862               	.L123:
 2863               	.LBE182:
 270:main.c        **** 			gb_mode();
 2864               		.loc 3 270 0
 2865 026a 8337      		cpi r24,lo8(115)
 2866 026c 01F4      		brne .L124
 2867               	.LBB183:
 271:main.c        **** 			
 2868               		.loc 3 271 0
 2869 026e 00D0      		rcall gb_mode
 2870               	.LVL247:
 273:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2871               		.loc 3 273 0
 2872 0270 00D0      		rcall usart_read_chars
 2873               	.LVL248:
 274:main.c        **** 			
 2874               		.loc 3 274 0
 2875 0272 40E1      		ldi r20,lo8(16)
 2876 0274 50E0      		ldi r21,0
 2877 0276 60E0      		ldi r22,0
 2878 0278 70E0      		ldi r23,0
 2879 027a 80E0      		ldi r24,lo8(receivedBuffer)
 2880 027c 90E0      		ldi r25,hi8(receivedBuffer)
 2881 027e 00D0      		rcall strtol
 2882               	.LVL249:
 2883 0280 862F      		mov r24,r22
 2884               	.LVL250:
 276:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2885               		.loc 3 276 0
 2886 0282 00D0      		rcall flash_erase_4k_sector
 2887               	.LVL251:
 2888               	.L238:
 277:main.c        **** 			
 2889               		.loc 3 277 0
 2890 0284 81E3      		ldi r24,lo8(49)
 2891 0286 00C0      		rjmp .L237
 2892               	.L124:
 2893               	.LBE183:
 283:main.c        **** 			gb_mode();
 2894               		.loc 3 283 0
 2895 0288 8236      		cpi r24,lo8(98)
 2896 028a 01F4      		brne .L125
 284:main.c        **** 			
 2897               		.loc 3 284 0
 2898 028c 00D0      		rcall gb_mode
 2899               	.LVL252:
 286:main.c        **** 			
 2900               		.loc 3 286 0
 2901 028e 80E4      		ldi r24,lo8(64)
 2902 0290 90E0      		ldi r25,0
 2903 0292 00D0      		rcall usart_read_bytes
 2904               	.LVL253:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2905               		.loc 3 288 0
 2906 0294 939A      		sbi 0x12,3
 2907               	.LVL254:
 2908 0296 E0E0      		ldi r30,lo8(receivedBuffer)
 2909 0298 AE2E      		mov r10,r30
 2910 029a E0E0      		ldi r30,hi8(receivedBuffer)
 2911 029c BE2E      		mov r11,r30
 2912 029e 00E0      		ldi r16,0
 2913 02a0 10E0      		ldi r17,0
 2914               	.LVL255:
 2915               	.L126:
 2916               	.LBB184:
 290:main.c        **** 				address++;
 2917               		.loc 3 290 0 discriminator 3
 2918 02a2 F501      		movw r30,r10
 2919 02a4 6191      		ld r22,Z+
 2920 02a6 5F01      		movw r10,r30
 2921 02a8 C801      		movw r24,r16
 2922 02aa 8C0D      		add r24,r12
 2923 02ac 9D1D      		adc r25,r13
 2924 02ae 00D0      		rcall flash_write_byte
 2925               	.LVL256:
 2926 02b0 0F5F      		subi r16,-1
 2927 02b2 1F4F      		sbci r17,-1
 2928               	.LVL257:
 289:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2929               		.loc 3 289 0 discriminator 3
 2930 02b4 0034      		cpi r16,64
 2931 02b6 1105      		cpc r17,__zero_reg__
 2932 02b8 01F4      		brne .L126
 2933 02ba 00C0      		rjmp .L236
 2934               	.LVL258:
 2935               	.L125:
 2936               	.LBE184:
 300:main.c        **** 			gb_mode();
 2937               		.loc 3 300 0
 2938 02bc 8136      		cpi r24,lo8(97)
 2939 02be 01F4      		brne .L127
 301:main.c        **** 			
 2940               		.loc 3 301 0
 2941 02c0 00D0      		rcall gb_mode
 2942               	.LVL259:
 303:main.c        **** 			
 2943               		.loc 3 303 0
 2944 02c2 80E8      		ldi r24,lo8(-128)
 2945 02c4 90E0      		ldi r25,0
 2946 02c6 00D0      		rcall usart_read_bytes
 2947               	.LVL260:
 305:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2948               		.loc 3 305 0
 2949 02c8 939A      		sbi 0x12,3
 306:main.c        **** 			address++;
 2950               		.loc 3 306 0
 2951 02ca C601      		movw r24,r12
 2952 02cc 00D0      		rcall flash_write_sector
 2953               	.LVL261:
 307:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2954               		.loc 3 307 0
 2955 02ce 2FEF      		ldi r18,-1
 2956 02d0 C21A      		sub r12,r18
 2957 02d2 D20A      		sbc r13,r18
 2958 02d4 E20A      		sbc r14,r18
 2959 02d6 F20A      		sbc r15,r18
 2960               	.LVL262:
 2961 02d8 00C0      		rjmp .L235
 2962               	.L127:
 317:main.c        **** 			usart_read_chars(); // Read size
 2963               		.loc 3 317 0
 2964 02da 8335      		cpi r24,lo8(83)
 2965 02dc 01F4      		brne .L128
 318:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2966               		.loc 3 318 0
 2967 02de 00D0      		rcall usart_read_chars
 2968               	.LVL263:
 319:main.c        **** 		}
 2969               		.loc 3 319 0
 2970 02e0 40E1      		ldi r20,lo8(16)
 2971 02e2 50E0      		ldi r21,0
 2972 02e4 60E0      		ldi r22,0
 2973 02e6 70E0      		ldi r23,0
 2974 02e8 80E0      		ldi r24,lo8(receivedBuffer)
 2975 02ea 90E0      		ldi r25,hi8(receivedBuffer)
 2976 02ec 00D0      		rcall strtol
 2977               	.LVL264:
 2978 02ee D62F      		mov r29,r22
 2979               	.LVL265:
 2980 02f0 00C0      		rjmp .L93
 2981               	.LVL266:
 2982               	.L128:
 323:main.c        **** 			gba_eeprom_mode();
 2983               		.loc 3 323 0
 2984 02f2 8536      		cpi r24,lo8(101)
 2985 02f4 01F4      		brne .L129
 324:main.c        **** 			
 2986               		.loc 3 324 0
 2987 02f6 00D0      		rcall gba_eeprom_mode
 2988               	.LVL267:
 326:main.c        **** 			while (receivedChar == '1') {
 2989               		.loc 3 326 0
 2990 02f8 7092 0000 		sts receivedChar,r7
 2991               	.L130:
 327:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2992               		.loc 3 327 0
 2993 02fc 8091 0000 		lds r24,receivedChar
 2994 0300 8133      		cpi r24,lo8(49)
 2995 0302 01F0      		breq .+2
 2996 0304 00C0      		rjmp .L233
 328:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2997               		.loc 3 328 0
 2998 0306 939A      		sbi 0x12,3
 329:main.c        **** 				
 2999               		.loc 3 329 0
 3000 0308 6D2F      		mov r22,r29
 3001 030a C601      		movw r24,r12
 3002 030c 00D0      		rcall gba_eeprom_read
 3003               	.LVL268:
 3004 030e 00E0      		ldi r16,lo8(eepromBuffer)
 3005 0310 10E0      		ldi r17,hi8(eepromBuffer)
 3006               	.LVL269:
 3007               	.L131:
 3008               	.LBB185:
 333:main.c        **** 				}
 3009               		.loc 3 333 0 discriminator 3
 3010 0312 F801      		movw r30,r16
 3011 0314 8191      		ld r24,Z+
 3012 0316 8F01      		movw r16,r30
 3013               	.LVL270:
 3014 0318 00D0      		rcall USART_Transmit
 3015               	.LVL271:
 332:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3016               		.loc 3 332 0 discriminator 3
 3017 031a 80E0      		ldi r24,lo8(eepromBuffer+8)
 3018 031c 90E0      		ldi r25,hi8(eepromBuffer+8)
 3019 031e 8017      		cp r24,r16
 3020 0320 9107      		cpc r25,r17
 3021 0322 01F4      		brne .L131
 3022               	.LBE185:
 335:main.c        **** 				
 3023               		.loc 3 335 0
 3024 0324 9FEF      		ldi r25,-1
 3025 0326 C91A      		sub r12,r25
 3026 0328 D90A      		sbc r13,r25
 3027 032a E90A      		sbc r14,r25
 3028 032c F90A      		sbc r15,r25
 3029               	.LVL272:
 337:main.c        **** 				receivedChar = USART_Receive();
 3030               		.loc 3 337 0
 3031 032e 9398      		cbi 0x12,3
 338:main.c        **** 			}
 3032               		.loc 3 338 0
 3033 0330 00D0      		rcall USART_Receive
 3034               	.LVL273:
 3035 0332 8093 0000 		sts receivedChar,r24
 3036 0336 00C0      		rjmp .L130
 3037               	.LVL274:
 3038               	.L129:
 345:main.c        **** 			gba_eeprom_mode();
 3039               		.loc 3 345 0
 3040 0338 8037      		cpi r24,lo8(112)
 3041 033a 01F4      		brne .L133
 346:main.c        **** 			
 3042               		.loc 3 346 0
 3043 033c 00D0      		rcall gba_eeprom_mode
 3044               	.LVL275:
 3045 033e 00E0      		ldi r16,lo8(eepromBuffer)
 3046 0340 10E0      		ldi r17,hi8(eepromBuffer)
 3047               	.LVL276:
 3048               	.L134:
 3049               	.LBB186:
 350:main.c        **** 			}
 3050               		.loc 3 350 0 discriminator 3
 3051 0342 00D0      		rcall USART_Receive
 3052               	.LVL277:
 3053 0344 F801      		movw r30,r16
 3054 0346 8193      		st Z+,r24
 3055 0348 8F01      		movw r16,r30
 3056               	.LVL278:
 349:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3057               		.loc 3 349 0 discriminator 3
 3058 034a 80E0      		ldi r24,lo8(eepromBuffer+8)
 3059 034c 90E0      		ldi r25,hi8(eepromBuffer+8)
 3060 034e 8E17      		cp r24,r30
 3061 0350 9F07      		cpc r25,r31
 3062 0352 01F4      		brne .L134
 3063               	.LBE186:
 352:main.c        **** 			
 3064               		.loc 3 352 0
 3065 0354 939A      		sbi 0x12,3
 354:main.c        **** 			address++;
 3066               		.loc 3 354 0
 3067 0356 6D2F      		mov r22,r29
 3068 0358 C601      		movw r24,r12
 3069 035a 00D0      		rcall gba_eeprom_write
 3070               	.LVL279:
 355:main.c        **** 			
 3071               		.loc 3 355 0
 3072 035c 9FEF      		ldi r25,-1
 3073 035e C91A      		sub r12,r25
 3074 0360 D90A      		sbc r13,r25
 3075 0362 E90A      		sbc r14,r25
 3076 0364 F90A      		sbc r15,r25
 3077               	.LVL280:
 3078               	.LBB187:
 3079               	.LBB188:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3080               		.loc 2 187 0
 3081 0366 EFE7      		ldi r30,lo8(15999)
 3082 0368 FEE3      		ldi r31,hi8(15999)
 3083 036a 3197      	1:	sbiw r30,1
 3084 036c 01F4      		brne 1b
 3085 036e 00C0      		rjmp .
 3086 0370 0000      		nop
 3087               	.LVL281:
 3088 0372 00C0      		rjmp .L235
 3089               	.LVL282:
 3090               	.L133:
 3091               	.LBE188:
 3092               	.LBE187:
 367:main.c        **** 			flashWriteWePin = USART_Receive();
 3093               		.loc 3 367 0
 3094 0374 8035      		cpi r24,lo8(80)
 3095 0376 01F4      		brne .L135
 368:main.c        **** 			
 3096               		.loc 3 368 0
 3097 0378 00D0      		rcall USART_Receive
 3098               	.LVL283:
 3099 037a 8093 0000 		sts flashWriteWePin,r24
 370:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3100               		.loc 3 370 0
 3101 037e 8134      		cpi r24,lo8(65)
 3102 0380 01F0      		breq .+2
 3103 0382 00C0      		rjmp .L93
 371:main.c        **** 				audioPin_high;
 3104               		.loc 3 371 0
 3105 0384 319A      		sbi 0x6,1
 372:main.c        **** 			}
 3106               		.loc 3 372 0
 3107 0386 399A      		sbi 0x7,1
 3108 0388 00C0      		rjmp .L93
 3109               	.L135:
 377:main.c        **** 			flashBank1CommandWrites = 1;
 3110               		.loc 3 377 0
 3111 038a 8E34      		cpi r24,lo8(78)
 3112 038c 01F4      		brne .L136
 378:main.c        **** 		}
 3113               		.loc 3 378 0
 3114 038e 81E0      		ldi r24,lo8(1)
 3115 0390 8093 0000 		sts flashBank1CommandWrites,r24
 3116 0394 00C0      		rjmp .L93
 3117               	.L136:
 382:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 3118               		.loc 3 382 0
 3119 0396 8534      		cpi r24,lo8(69)
 3120 0398 01F4      		brne .L137
 3121 039a 00E0      		ldi r16,lo8(flashWriteCycle)
 3122 039c 10E0      		ldi r17,hi8(flashWriteCycle)
 3123               	.L138:
 3124               	.LBB189:
 384:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3125               		.loc 3 384 0 discriminator 3
 3126 039e 00D0      		rcall usart_read_chars
 3127               	.LVL284:
 385:main.c        **** 				USART_Transmit(SEND_ACK);
 3128               		.loc 3 385 0 discriminator 3
 3129 03a0 40E1      		ldi r20,lo8(16)
 3130 03a2 50E0      		ldi r21,0
 3131 03a4 60E0      		ldi r22,0
 3132 03a6 70E0      		ldi r23,0
 3133 03a8 80E0      		ldi r24,lo8(receivedBuffer)
 3134 03aa 90E0      		ldi r25,hi8(receivedBuffer)
 3135 03ac 00D0      		rcall strtol
 3136               	.LVL285:
 3137 03ae F801      		movw r30,r16
 3138 03b0 7183      		std Z+1,r23
 3139 03b2 6083      		st Z,r22
 386:main.c        **** 				
 3140               		.loc 3 386 0 discriminator 3
 3141 03b4 81E3      		ldi r24,lo8(49)
 3142 03b6 00D0      		rcall USART_Transmit
 3143               	.LVL286:
 388:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3144               		.loc 3 388 0 discriminator 3
 3145 03b8 00D0      		rcall usart_read_chars
 3146               	.LVL287:
 389:main.c        **** 				USART_Transmit(SEND_ACK);
 3147               		.loc 3 389 0 discriminator 3
 3148 03ba 40E1      		ldi r20,lo8(16)
 3149 03bc 50E0      		ldi r21,0
 3150 03be 60E0      		ldi r22,0
 3151 03c0 70E0      		ldi r23,0
 3152 03c2 80E0      		ldi r24,lo8(receivedBuffer)
 3153 03c4 90E0      		ldi r25,hi8(receivedBuffer)
 3154 03c6 00D0      		rcall strtol
 3155               	.LVL288:
 3156 03c8 F801      		movw r30,r16
 3157 03ca 7383      		std Z+3,r23
 3158 03cc 6283      		std Z+2,r22
 390:main.c        **** 			}
 3159               		.loc 3 390 0 discriminator 3
 3160 03ce 81E3      		ldi r24,lo8(49)
 3161 03d0 00D0      		rcall USART_Transmit
 3162               	.LVL289:
 3163 03d2 0C5F      		subi r16,-4
 3164 03d4 1F4F      		sbci r17,-1
 383:main.c        **** 				usart_read_chars(); // Address
 3165               		.loc 3 383 0 discriminator 3
 3166 03d6 80E0      		ldi r24,lo8(flashWriteCycle+12)
 3167 03d8 90E0      		ldi r25,hi8(flashWriteCycle+12)
 3168 03da 8017      		cp r24,r16
 3169 03dc 9107      		cpc r25,r17
 3170 03de 01F4      		brne .L138
 3171 03e0 00C0      		rjmp .L93
 3172               	.L137:
 3173               	.LBE189:
 395:main.c        **** 			usart_read_chars(); // Read address
 3174               		.loc 3 395 0
 3175 03e2 8634      		cpi r24,lo8(70)
 3176 03e4 01F4      		brne .L139
 3177               	.LBB190:
 396:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3178               		.loc 3 396 0
 3179 03e6 00D0      		rcall usart_read_chars
 3180               	.LVL290:
 397:main.c        **** 			
 3181               		.loc 3 397 0
 3182 03e8 40E1      		ldi r20,lo8(16)
 3183 03ea 50E0      		ldi r21,0
 3184 03ec 60E0      		ldi r22,0
 3185 03ee 70E0      		ldi r23,0
 3186 03f0 80E0      		ldi r24,lo8(receivedBuffer)
 3187 03f2 90E0      		ldi r25,hi8(receivedBuffer)
 3188 03f4 00D0      		rcall strtol
 3189               	.LVL291:
 3190 03f6 4B01      		movw r8,r22
 3191 03f8 5C01      		movw r10,r24
 3192               	.LVL292:
 399:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3193               		.loc 3 399 0
 3194 03fa 00D0      		rcall usart_read_chars
 3195               	.LVL293:
 400:main.c        **** 			
 3196               		.loc 3 400 0
 3197 03fc 40E1      		ldi r20,lo8(16)
 3198 03fe 50E0      		ldi r21,0
 3199 0400 60E0      		ldi r22,0
 3200 0402 70E0      		ldi r23,0
 3201 0404 80E0      		ldi r24,lo8(receivedBuffer)
 3202 0406 90E0      		ldi r25,hi8(receivedBuffer)
 3203 0408 00D0      		rcall strtol
 3204               	.LVL294:
 402:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3205               		.loc 3 402 0
 3206 040a 939A      		sbi 0x12,3
 403:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3207               		.loc 3 403 0
 3208 040c C401      		movw r24,r8
 3209 040e 00D0      		rcall gb_flash_write_bus_cycle
 3210               	.LVL295:
 3211 0410 00C0      		rjmp .L250
 3212               	.LVL296:
 3213               	.L139:
 3214               	.LBE190:
 410:main.c        **** 			usart_read_bytes(64);
 3215               		.loc 3 410 0
 3216 0412 8435      		cpi r24,lo8(84)
 3217 0414 01F4      		brne .L140
 411:main.c        **** 			
 3218               		.loc 3 411 0
 3219 0416 80E4      		ldi r24,lo8(64)
 3220 0418 90E0      		ldi r25,0
 3221 041a 00D0      		rcall usart_read_bytes
 3222               	.LVL297:
 413:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3223               		.loc 3 413 0
 3224 041c 939A      		sbi 0x12,3
 3225               	.LVL298:
 3226 041e 60E0      		ldi r22,lo8(receivedBuffer)
 3227 0420 A62E      		mov r10,r22
 3228 0422 60E0      		ldi r22,hi8(receivedBuffer)
 3229 0424 B62E      		mov r11,r22
 3230 0426 70E4      		ldi r23,lo8(64)
 3231 0428 972E      		mov r9,r23
 3232 042a 8601      		movw r16,r12
 3233 042c 0050      		subi r16,lo8(receivedBuffer)
 3234 042e 1040      		sbci r17,hi8(receivedBuffer)
 3235               	.LVL299:
 3236               	.L143:
 3237               	.LBB191:
 415:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3238               		.loc 3 415 0
 3239 0430 8091 0000 		lds r24,flashBank1CommandWrites
 416:main.c        **** 				}
 3240               		.loc 3 416 0
 3241 0434 F501      		movw r30,r10
 3242 0436 6081      		ld r22,Z
 415:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3243               		.loc 3 415 0
 3244 0438 8111      		cpse r24,__zero_reg__
 3245 043a 00C0      		rjmp .L141
 416:main.c        **** 				}
 3246               		.loc 3 416 0
 3247 043c C801      		movw r24,r16
 3248 043e 8A0D      		add r24,r10
 3249 0440 9B1D      		adc r25,r11
 3250 0442 00D0      		rcall gb_flash_write_byte
 3251               	.LVL300:
 3252 0444 00C0      		rjmp .L142
 3253               	.L141:
 419:main.c        **** 				}
 3254               		.loc 3 419 0
 3255 0446 C801      		movw r24,r16
 3256 0448 8A0D      		add r24,r10
 3257 044a 9B1D      		adc r25,r11
 3258 044c 00D0      		rcall gb_flash_write_byte_bank1_commands
 3259               	.LVL301:
 3260               	.L142:
 3261 044e 9A94      		dec r9
 3262 0450 FFEF      		ldi r31,-1
 3263 0452 AF1A      		sub r10,r31
 3264 0454 BF0A      		sbc r11,r31
 3265               	.LVL302:
 414:main.c        **** 				if (flashBank1CommandWrites == 0) {
 3266               		.loc 3 414 0 discriminator 2
 3267 0456 9110      		cpse r9,__zero_reg__
 3268 0458 00C0      		rjmp .L143
 3269 045a 20E4      		ldi r18,64
 3270 045c C20E      		add r12,r18
 3271 045e D11C      		adc r13,__zero_reg__
 3272 0460 E11C      		adc r14,__zero_reg__
 3273 0462 F11C      		adc r15,__zero_reg__
 3274 0464 00C0      		rjmp .L239
 3275               	.LVL303:
 3276               	.L140:
 3277               	.LBE191:
 429:main.c        **** 			usart_read_bytes(32);
 3278               		.loc 3 429 0
 3279 0466 8935      		cpi r24,lo8(89)
 3280 0468 01F0      		breq .+2
 3281 046a 00C0      		rjmp .L144
 3282               	.LBB192:
 430:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3283               		.loc 3 430 0
 3284 046c 80E2      		ldi r24,lo8(32)
 3285 046e 90E0      		ldi r25,0
 3286 0470 00D0      		rcall usart_read_bytes
 3287               	.LVL304:
 431:main.c        **** 			
 3288               		.loc 3 431 0
 3289 0472 939A      		sbi 0x12,3
 434:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3290               		.loc 3 434 0
 3291 0474 6AEA      		ldi r22,lo8(-86)
 3292 0476 8AEA      		ldi r24,lo8(-86)
 3293 0478 9AE0      		ldi r25,lo8(10)
 3294 047a 00D0      		rcall gb_flash_write_bus_cycle
 3295               	.LVL305:
 435:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3296               		.loc 3 435 0
 3297 047c 65E5      		ldi r22,lo8(85)
 3298 047e 85E5      		ldi r24,lo8(85)
 3299 0480 95E0      		ldi r25,lo8(5)
 3300 0482 00D0      		rcall gb_flash_write_bus_cycle
 3301               	.LVL306:
 436:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3302               		.loc 3 436 0
 3303 0484 5601      		movw r10,r12
 3304 0486 65E2      		ldi r22,lo8(37)
 3305 0488 C601      		movw r24,r12
 3306 048a 00D0      		rcall gb_flash_write_bus_cycle
 3307               	.LVL307:
 437:main.c        **** 			_delay_us(1);
 3308               		.loc 3 437 0
 3309 048c 6FE1      		ldi r22,lo8(31)
 3310 048e C601      		movw r24,r12
 3311 0490 00D0      		rcall gb_flash_write_bus_cycle
 3312               	.LVL308:
 3313               	.LBB193:
 3314               	.LBB194:
 3315               		.loc 2 276 0
 3316 0492 82E0      		ldi r24,lo8(2)
 3317 0494 8A95      	1:	dec r24
 3318 0496 01F4      		brne 1b
 3319 0498 00C0      		rjmp .
 3320               	.LVL309:
 3321 049a 00E0      		ldi r16,lo8(receivedBuffer)
 3322 049c 10E0      		ldi r17,hi8(receivedBuffer)
 3323 049e 812C      		mov r8,__zero_reg__
 3324 04a0 912C      		mov r9,__zero_reg__
 3325               	.LVL310:
 3326               	.L145:
 3327               	.LBE194:
 3328               	.LBE193:
 3329               	.LBB195:
 442:main.c        **** 				address++;
 3330               		.loc 3 442 0 discriminator 3
 3331 04a2 F801      		movw r30,r16
 3332 04a4 6191      		ld r22,Z+
 3333 04a6 8F01      		movw r16,r30
 3334 04a8 C401      		movw r24,r8
 3335 04aa 8A0D      		add r24,r10
 3336 04ac 9B1D      		adc r25,r11
 3337 04ae 00D0      		rcall gb_flash_write_bus_cycle
 3338               	.LVL311:
 3339 04b0 FFEF      		ldi r31,-1
 3340 04b2 8F1A      		sub r8,r31
 3341 04b4 9F0A      		sbc r9,r31
 3342               	.LVL312:
 441:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3343               		.loc 3 441 0 discriminator 3
 3344 04b6 20E2      		ldi r18,32
 3345 04b8 8216      		cp r8,r18
 3346 04ba 9104      		cpc r9,__zero_reg__
 3347 04bc 01F4      		brne .L145
 3348 04be 80E2      		ldi r24,32
 3349 04c0 C80E      		add r12,r24
 3350 04c2 D11C      		adc r13,__zero_reg__
 3351 04c4 E11C      		adc r14,__zero_reg__
 3352 04c6 F11C      		adc r15,__zero_reg__
 3353               	.LBE195:
 447:main.c        **** 			_delay_us(200);
 3354               		.loc 3 447 0
 3355 04c8 C601      		movw r24,r12
 3356 04ca 8097      		sbiw r24,32
 3357 04cc 69E2      		ldi r22,lo8(41)
 3358 04ce 00D0      		rcall gb_flash_write_bus_cycle
 3359               	.LVL313:
 3360               	.LBB196:
 3361               	.LBB197:
 3362               		.loc 2 276 0
 3363 04d0 EFE8      		ldi r30,lo8(399)
 3364 04d2 F1E0      		ldi r31,hi8(399)
 3365 04d4 3197      	1:	sbiw r30,1
 3366 04d6 01F4      		brne 1b
 3367 04d8 00C0      		rjmp .
 3368 04da 0000      		nop
 3369               	.LVL314:
 3370               	.LBE197:
 3371               	.LBE196:
 451:main.c        **** 			uint8_t verifyCount = 0;
 3372               		.loc 3 451 0
 3373 04dc 8601      		movw r16,r12
 3374 04de 0150      		subi r16,1
 3375 04e0 1109      		sbc r17,__zero_reg__
 3376 04e2 C801      		movw r24,r16
 3377 04e4 00D0      		rcall gb_flash_read_byte
 3378               	.LVL315:
 453:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3379               		.loc 3 453 0
 3380 04e6 58EC      		ldi r21,lo8(-56)
 3381 04e8 B52E      		mov r11,r21
 3382               	.LVL316:
 3383               	.L146:
 3384 04ea 9091 0000 		lds r25,receivedBuffer+31
 3385 04ee 8917      		cp r24,r25
 3386 04f0 01F4      		brne .+2
 3387 04f2 00C0      		rjmp .L239
 454:main.c        **** 				_delay_us(5);
 3388               		.loc 3 454 0
 3389 04f4 C801      		movw r24,r16
 3390               	.LVL317:
 3391 04f6 00D0      		rcall gb_flash_read_byte
 3392               	.LVL318:
 3393               	.LBB198:
 3394               	.LBB199:
 3395               		.loc 2 276 0
 3396 04f8 FDE0      		ldi r31,lo8(13)
 3397 04fa FA95      	1:	dec r31
 3398 04fc 01F4      		brne 1b
 3399 04fe 0000      		nop
 3400               	.LVL319:
 3401 0500 BA94      		dec r11
 3402               	.LVL320:
 3403               	.LBE199:
 3404               	.LBE198:
 457:main.c        **** 					_delay_ms(500);
 3405               		.loc 3 457 0
 3406 0502 B110      		cpse r11,__zero_reg__
 3407 0504 00C0      		rjmp .L146
 3408               	.LVL321:
 3409               	.LBB200:
 3410               	.LBB201:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3411               		.loc 2 187 0
 3412 0506 2FEF      		ldi r18,lo8(799999)
 3413 0508 84E3      		ldi r24,hi8(799999)
 3414 050a 9CE0      		ldi r25,hlo8(799999)
 3415 050c 2150      	1:	subi r18,1
 3416 050e 8040      		sbci r24,0
 3417 0510 9040      		sbci r25,0
 3418 0512 01F4      		brne 1b
 3419               	.LVL322:
 3420 0514 00C0      		rjmp .L251
 3421               	.LVL323:
 3422               	.L144:
 3423               	.LBE201:
 3424               	.LBE200:
 3425               	.LBE192:
 468:main.c        **** 			usart_read_bytes(256);
 3426               		.loc 3 468 0
 3427 0516 8835      		cpi r24,lo8(88)
 3428 0518 01F0      		breq .+2
 3429 051a 00C0      		rjmp .L149
 3430               	.LBB202:
 469:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3431               		.loc 3 469 0
 3432 051c 80E0      		ldi r24,0
 3433 051e 91E0      		ldi r25,lo8(1)
 3434 0520 00D0      		rcall usart_read_bytes
 3435               	.LVL324:
 470:main.c        **** 			
 3436               		.loc 3 470 0
 3437 0522 939A      		sbi 0x12,3
 473:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3438               		.loc 3 473 0
 3439 0524 69EA      		ldi r22,lo8(-87)
 3440 0526 8AEA      		ldi r24,lo8(-86)
 3441 0528 9AE0      		ldi r25,lo8(10)
 3442 052a 00D0      		rcall gb_flash_write_bus_cycle
 3443               	.LVL325:
 474:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3444               		.loc 3 474 0
 3445 052c 66E5      		ldi r22,lo8(86)
 3446 052e 85E5      		ldi r24,lo8(85)
 3447 0530 95E0      		ldi r25,lo8(5)
 3448 0532 00D0      		rcall gb_flash_write_bus_cycle
 3449               	.LVL326:
 475:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3450               		.loc 3 475 0
 3451 0534 5601      		movw r10,r12
 3452 0536 66E2      		ldi r22,lo8(38)
 3453 0538 C601      		movw r24,r12
 3454 053a 00D0      		rcall gb_flash_write_bus_cycle
 3455               	.LVL327:
 476:main.c        **** 			_delay_us(50);
 3456               		.loc 3 476 0
 3457 053c 6FEF      		ldi r22,lo8(-1)
 3458 053e C601      		movw r24,r12
 3459 0540 00D0      		rcall gb_flash_write_bus_cycle
 3460               	.LVL328:
 3461               	.LBB203:
 3462               	.LBB204:
 3463               		.loc 2 276 0
 3464 0542 E5E8      		ldi r30,lo8(-123)
 3465 0544 EA95      	1:	dec r30
 3466 0546 01F4      		brne 1b
 3467 0548 0000      		nop
 3468               	.LVL329:
 3469 054a 00E0      		ldi r16,lo8(receivedBuffer)
 3470 054c 10E0      		ldi r17,hi8(receivedBuffer)
 3471               	.LBE204:
 3472               	.LBE203:
 3473               	.LBB205:
 480:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3474               		.loc 3 480 0
 3475 054e 812C      		mov r8,__zero_reg__
 3476 0550 912C      		mov r9,__zero_reg__
 3477               	.LVL330:
 3478               	.L150:
 481:main.c        **** 				address++;
 3479               		.loc 3 481 0 discriminator 3
 3480 0552 F801      		movw r30,r16
 3481 0554 6191      		ld r22,Z+
 3482 0556 8F01      		movw r16,r30
 3483 0558 C401      		movw r24,r8
 3484 055a 8A0D      		add r24,r10
 3485 055c 9B1D      		adc r25,r11
 3486 055e 00D0      		rcall gb_flash_write_bus_cycle
 3487               	.LVL331:
 480:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3488               		.loc 3 480 0 discriminator 3
 3489 0560 FFEF      		ldi r31,-1
 3490 0562 8F1A      		sub r8,r31
 3491 0564 9F0A      		sbc r9,r31
 3492               	.LVL332:
 3493 0566 8114      		cp r8,__zero_reg__
 3494 0568 21E0      		ldi r18,1
 3495 056a 9206      		cpc r9,r18
 3496 056c 01F4      		brne .L150
 3497 056e 8FEF      		ldi r24,-1
 3498 0570 D81A      		sub r13,r24
 3499 0572 E80A      		sbc r14,r24
 3500 0574 F80A      		sbc r15,r24
 3501               	.LBE205:
 486:main.c        **** 			
 3502               		.loc 3 486 0
 3503 0576 C601      		movw r24,r12
 3504 0578 9A95      		dec r25
 3505 057a 6AE2      		ldi r22,lo8(42)
 3506 057c 00D0      		rcall gb_flash_write_bus_cycle
 3507               	.LVL333:
 489:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 3508               		.loc 3 489 0
 3509 057e 8601      		movw r16,r12
 3510 0580 0150      		subi r16,1
 3511 0582 1109      		sbc r17,__zero_reg__
 3512 0584 C801      		movw r24,r16
 3513 0586 00D0      		rcall gb_flash_read_byte
 3514               	.LVL334:
 3515               	.L151:
 490:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3516               		.loc 3 490 0
 3517 0588 9091 0000 		lds r25,receivedBuffer+255
 3518 058c 8917      		cp r24,r25
 3519 058e 01F4      		brne .+2
 3520 0590 00C0      		rjmp .L239
 491:main.c        **** 				_delay_us(5);
 3521               		.loc 3 491 0
 3522 0592 C801      		movw r24,r16
 3523               	.LVL335:
 3524 0594 00D0      		rcall gb_flash_read_byte
 3525               	.LVL336:
 3526               	.LBB206:
 3527               	.LBB207:
 3528               		.loc 2 276 0
 3529 0596 9DE0      		ldi r25,lo8(13)
 3530 0598 9A95      	1:	dec r25
 3531 059a 01F4      		brne 1b
 3532 059c 0000      		nop
 3533 059e 00C0      		rjmp .L151
 3534               	.LVL337:
 3535               	.L149:
 3536               	.LBE207:
 3537               	.LBE206:
 3538               	.LBE202:
 500:main.c        **** 			usart_read_bytes(128);
 3539               		.loc 3 500 0
 3540 05a0 8A35      		cpi r24,lo8(90)
 3541 05a2 01F0      		breq .+2
 3542 05a4 00C0      		rjmp .L153
 501:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3543               		.loc 3 501 0
 3544 05a6 80E8      		ldi r24,lo8(-128)
 3545 05a8 90E0      		ldi r25,0
 3546 05aa 00D0      		rcall usart_read_bytes
 3547               	.LVL338:
 502:main.c        **** 			
 3548               		.loc 3 502 0
 3549 05ac 939A      		sbi 0x12,3
 505:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 3550               		.loc 3 505 0
 3551 05ae 69E0      		ldi r22,lo8(9)
 3552 05b0 80E2      		ldi r24,lo8(32)
 3553 05b2 91E0      		ldi r25,lo8(1)
 3554 05b4 00D0      		rcall gb_flash_write_bus_cycle
 3555               	.LVL339:
 506:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 3556               		.loc 3 506 0
 3557 05b6 6AEA      		ldi r22,lo8(-86)
 3558 05b8 81E2      		ldi r24,lo8(33)
 3559 05ba 91E0      		ldi r25,lo8(1)
 3560 05bc 00D0      		rcall gb_flash_write_bus_cycle
 3561               	.LVL340:
 507:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3562               		.loc 3 507 0
 3563 05be 65E5      		ldi r22,lo8(85)
 3564 05c0 82E2      		ldi r24,lo8(34)
 3565 05c2 91E0      		ldi r25,lo8(1)
 3566 05c4 00D0      		rcall gb_flash_write_bus_cycle
 3567               	.LVL341:
 508:main.c        **** 			_delay_us(5);
 3568               		.loc 3 508 0
 3569 05c6 65EA      		ldi r22,lo8(-91)
 3570 05c8 8FE3      		ldi r24,lo8(63)
 3571 05ca 91E0      		ldi r25,lo8(1)
 3572 05cc 00D0      		rcall gb_flash_write_bus_cycle
 3573               	.LVL342:
 3574               	.LBB208:
 3575               	.LBB209:
 3576               		.loc 2 276 0
 3577 05ce EDE0      		ldi r30,lo8(13)
 3578 05d0 EA95      	1:	dec r30
 3579 05d2 01F4      		brne 1b
 3580 05d4 0000      		nop
 3581               	.LVL343:
 3582               	.LBE209:
 3583               	.LBE208:
 512:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3584               		.loc 3 512 0
 3585 05d6 61E1      		ldi r22,lo8(17)
 3586 05d8 80E2      		ldi r24,lo8(32)
 3587 05da 91E0      		ldi r25,lo8(1)
 3588 05dc 00D0      		rcall gb_flash_write_bus_cycle
 3589               	.LVL344:
 513:main.c        **** 			_delay_us(5);
 3590               		.loc 3 513 0
 3591 05de 65EA      		ldi r22,lo8(-91)
 3592 05e0 8FE3      		ldi r24,lo8(63)
 3593 05e2 91E0      		ldi r25,lo8(1)
 3594 05e4 00D0      		rcall gb_flash_write_bus_cycle
 3595               	.LVL345:
 3596               	.LBB210:
 3597               	.LBB211:
 3598               		.loc 2 276 0
 3599 05e6 FDE0      		ldi r31,lo8(13)
 3600 05e8 FA95      	1:	dec r31
 3601 05ea 01F4      		brne 1b
 3602 05ec 0000      		nop
 3603               	.LVL346:
 3604               	.LBE211:
 3605               	.LBE210:
 517:main.c        **** 			_delay_us(5);
 3606               		.loc 3 517 0
 3607 05ee 61E0      		ldi r22,lo8(1)
 3608 05f0 80E0      		ldi r24,0
 3609 05f2 91E2      		ldi r25,lo8(33)
 3610 05f4 00D0      		rcall gb_flash_write_bus_cycle
 3611               	.LVL347:
 3612               	.LBB212:
 3613               	.LBB213:
 3614               		.loc 2 276 0
 3615 05f6 2DE0      		ldi r18,lo8(13)
 3616 05f8 2A95      	1:	dec r18
 3617 05fa 01F4      		brne 1b
 3618 05fc 0000      		nop
 3619               	.LVL348:
 3620               	.LBE213:
 3621               	.LBE212:
 522:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3622               		.loc 3 522 0
 3623 05fe 6FE0      		ldi r22,lo8(15)
 3624 0600 80E2      		ldi r24,lo8(32)
 3625 0602 91E0      		ldi r25,lo8(1)
 3626 0604 00D0      		rcall gb_flash_write_bus_cycle
 3627               	.LVL349:
 523:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3628               		.loc 3 523 0
 3629 0606 65E5      		ldi r22,lo8(85)
 3630 0608 85E2      		ldi r24,lo8(37)
 3631 060a 91E0      		ldi r25,lo8(1)
 3632 060c 00D0      		rcall gb_flash_write_bus_cycle
 3633               	.LVL350:
 524:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 3634               		.loc 3 524 0
 3635 060e 65E5      		ldi r22,lo8(85)
 3636 0610 86E2      		ldi r24,lo8(38)
 3637 0612 91E0      		ldi r25,lo8(1)
 3638 0614 00D0      		rcall gb_flash_write_bus_cycle
 3639               	.LVL351:
 525:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3640               		.loc 3 525 0
 3641 0616 6AEA      		ldi r22,lo8(-86)
 3642 0618 87E2      		ldi r24,lo8(39)
 3643 061a 91E0      		ldi r25,lo8(1)
 3644 061c 00D0      		rcall gb_flash_write_bus_cycle
 3645               	.LVL352:
 526:main.c        **** 			_delay_us(5);
 3646               		.loc 3 526 0
 3647 061e 65EA      		ldi r22,lo8(-91)
 3648 0620 8FE3      		ldi r24,lo8(63)
 3649 0622 91E0      		ldi r25,lo8(1)
 3650 0624 00D0      		rcall gb_flash_write_bus_cycle
 3651               	.LVL353:
 3652               	.LBB214:
 3653               	.LBB215:
 3654               		.loc 2 276 0
 3655 0626 8DE0      		ldi r24,lo8(13)
 3656 0628 8A95      	1:	dec r24
 3657 062a 01F4      		brne 1b
 3658 062c 0000      		nop
 3659               	.LVL354:
 3660               	.LBE215:
 3661               	.LBE214:
 529:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 3662               		.loc 3 529 0
 3663 062e 6FE0      		ldi r22,lo8(15)
 3664 0630 80E2      		ldi r24,lo8(32)
 3665 0632 91E0      		ldi r25,lo8(1)
 3666 0634 00D0      		rcall gb_flash_write_bus_cycle
 3667               	.LVL355:
 530:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 3668               		.loc 3 530 0
 3669 0636 6AE2      		ldi r22,lo8(42)
 3670 0638 85E2      		ldi r24,lo8(37)
 3671 063a 91E0      		ldi r25,lo8(1)
 3672 063c 00D0      		rcall gb_flash_write_bus_cycle
 3673               	.LVL356:
 531:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 3674               		.loc 3 531 0
 3675 063e 6AEA      		ldi r22,lo8(-86)
 3676 0640 86E2      		ldi r24,lo8(38)
 3677 0642 91E0      		ldi r25,lo8(1)
 3678 0644 00D0      		rcall gb_flash_write_bus_cycle
 3679               	.LVL357:
 532:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3680               		.loc 3 532 0
 3681 0646 65E5      		ldi r22,lo8(85)
 3682 0648 87E2      		ldi r24,lo8(39)
 3683 064a 91E0      		ldi r25,lo8(1)
 3684 064c 00D0      		rcall gb_flash_write_bus_cycle
 3685               	.LVL358:
 533:main.c        **** 			_delay_us(5);
 3686               		.loc 3 533 0
 3687 064e 65EA      		ldi r22,lo8(-91)
 3688 0650 8FE3      		ldi r24,lo8(63)
 3689 0652 91E0      		ldi r25,lo8(1)
 3690 0654 00D0      		rcall gb_flash_write_bus_cycle
 3691               	.LVL359:
 3692               	.LBB216:
 3693               	.LBB217:
 3694               		.loc 2 276 0
 3695 0656 9DE0      		ldi r25,lo8(13)
 3696 0658 9A95      	1:	dec r25
 3697 065a 01F4      		brne 1b
 3698 065c 0000      		nop
 3699               	.LVL360:
 3700               	.LBE217:
 3701               	.LBE216:
 536:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3702               		.loc 3 536 0
 3703 065e 6FE0      		ldi r22,lo8(15)
 3704 0660 80E2      		ldi r24,lo8(32)
 3705 0662 91E0      		ldi r25,lo8(1)
 3706 0664 00D0      		rcall gb_flash_write_bus_cycle
 3707               	.LVL361:
 537:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3708               		.loc 3 537 0
 3709 0666 65E5      		ldi r22,lo8(85)
 3710 0668 85E2      		ldi r24,lo8(37)
 3711 066a 91E0      		ldi r25,lo8(1)
 3712 066c 00D0      		rcall gb_flash_write_bus_cycle
 3713               	.LVL362:
 538:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 3714               		.loc 3 538 0
 3715 066e 65E5      		ldi r22,lo8(85)
 3716 0670 86E2      		ldi r24,lo8(38)
 3717 0672 91E0      		ldi r25,lo8(1)
 3718 0674 00D0      		rcall gb_flash_write_bus_cycle
 3719               	.LVL363:
 539:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3720               		.loc 3 539 0
 3721 0676 60EA      		ldi r22,lo8(-96)
 3722 0678 87E2      		ldi r24,lo8(39)
 3723 067a 91E0      		ldi r25,lo8(1)
 3724 067c 00D0      		rcall gb_flash_write_bus_cycle
 3725               	.LVL364:
 540:main.c        **** 			_delay_us(5);
 3726               		.loc 3 540 0
 3727 067e 65EA      		ldi r22,lo8(-91)
 3728 0680 8FE3      		ldi r24,lo8(63)
 3729 0682 91E0      		ldi r25,lo8(1)
 3730 0684 00D0      		rcall gb_flash_write_bus_cycle
 3731               	.LVL365:
 3732               	.LBB218:
 3733               	.LBB219:
 3734               		.loc 2 276 0
 3735 0686 EDE0      		ldi r30,lo8(13)
 3736 0688 EA95      	1:	dec r30
 3737 068a 01F4      		brne 1b
 3738 068c 0000      		nop
 3739               	.LVL366:
 3740               	.LBE219:
 3741               	.LBE218:
 544:main.c        **** 			_delay_us(5);
 3742               		.loc 3 544 0
 3743 068e 40E0      		ldi r20,0
 3744 0690 6091 0000 		lds r22,lastBankAccessed
 3745 0694 80E0      		ldi r24,0
 3746 0696 91E2      		ldi r25,lo8(33)
 3747 0698 00D0      		rcall write_8bit_data
 3748               	.LVL367:
 3749               	.LBB220:
 3750               	.LBB221:
 3751               		.loc 2 276 0
 3752 069a FDE0      		ldi r31,lo8(13)
 3753 069c FA95      	1:	dec r31
 3754 069e 01F4      		brne 1b
 3755 06a0 0000      		nop
 3756               	.LVL368:
 3757               	.LBE221:
 3758               	.LBE220:
 548:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3759               		.loc 3 548 0
 3760 06a2 60E1      		ldi r22,lo8(16)
 3761 06a4 80E2      		ldi r24,lo8(32)
 3762 06a6 91E0      		ldi r25,lo8(1)
 3763 06a8 00D0      		rcall gb_flash_write_bus_cycle
 3764               	.LVL369:
 549:main.c        **** 			_delay_us(5);
 3765               		.loc 3 549 0
 3766 06aa 65EA      		ldi r22,lo8(-91)
 3767 06ac 8FE3      		ldi r24,lo8(63)
 3768 06ae 91E0      		ldi r25,lo8(1)
 3769 06b0 00D0      		rcall gb_flash_write_bus_cycle
 3770               	.LVL370:
 3771               	.LBB222:
 3772               	.LBB223:
 3773               		.loc 2 276 0
 3774 06b2 2DE0      		ldi r18,lo8(13)
 3775 06b4 2A95      	1:	dec r18
 3776 06b6 01F4      		brne 1b
 3777 06b8 0000      		nop
 3778               	.LVL371:
 3779               	.LBE223:
 3780               	.LBE222:
 553:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3781               		.loc 3 553 0
 3782 06ba 68E0      		ldi r22,lo8(8)
 3783 06bc 80E2      		ldi r24,lo8(32)
 3784 06be 91E0      		ldi r25,lo8(1)
 3785 06c0 00D0      		rcall gb_flash_write_bus_cycle
 3786               	.LVL372:
 554:main.c        **** 			_delay_us(5);
 3787               		.loc 3 554 0
 3788 06c2 65EA      		ldi r22,lo8(-91)
 3789 06c4 8FE3      		ldi r24,lo8(63)
 3790 06c6 91E0      		ldi r25,lo8(1)
 3791 06c8 00D0      		rcall gb_flash_write_bus_cycle
 3792               	.LVL373:
 3793               	.LBB224:
 3794               	.LBB225:
 3795               		.loc 2 276 0
 3796 06ca 8DE0      		ldi r24,lo8(13)
 3797 06cc 8A95      	1:	dec r24
 3798 06ce 01F4      		brne 1b
 3799 06d0 0000      		nop
 3800               	.LVL374:
 3801 06d2 00E0      		ldi r16,lo8(receivedBuffer)
 3802 06d4 10E0      		ldi r17,hi8(receivedBuffer)
 3803               	.L154:
 3804               	.LBE225:
 3805               	.LBE224:
 3806               	.LBB226:
 559:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3807               		.loc 3 559 0 discriminator 1
 3808 06d6 80E0      		ldi r24,hi8(receivedBuffer+128)
 3809 06d8 0030      		cpi r16,lo8(receivedBuffer+128)
 3810 06da 1807      		cpc r17,r24
 3811 06dc 01F0      		breq .L252
 560:main.c        **** 				_delay_us(5);
 3812               		.loc 3 560 0 discriminator 3
 3813 06de F801      		movw r30,r16
 3814 06e0 6191      		ld r22,Z+
 3815 06e2 8F01      		movw r16,r30
 3816 06e4 C601      		movw r24,r12
 3817 06e6 00D0      		rcall gb_flash_write_bus_cycle
 3818               	.LVL375:
 3819               	.LBB227:
 3820               	.LBB228:
 3821               		.loc 2 276 0 discriminator 3
 3822 06e8 FDE0      		ldi r31,lo8(13)
 3823 06ea FA95      	1:	dec r31
 3824 06ec 01F4      		brne 1b
 3825 06ee 0000      		nop
 3826               	.LVL376:
 3827               	.LBE228:
 3828               	.LBE227:
 562:main.c        **** 			}
 3829               		.loc 3 562 0 discriminator 3
 3830 06f0 2FEF      		ldi r18,-1
 3831 06f2 C21A      		sub r12,r18
 3832 06f4 D20A      		sbc r13,r18
 3833 06f6 E20A      		sbc r14,r18
 3834 06f8 F20A      		sbc r15,r18
 3835               	.LVL377:
 3836 06fa 00C0      		rjmp .L154
 3837               	.L252:
 3838               	.LVL378:
 3839               	.LBE226:
 567:main.c        **** 			address++;
 3840               		.loc 3 567 0
 3841 06fc 6FEF      		ldi r22,lo8(-1)
 3842 06fe D701      		movw r26,r14
 3843 0700 C601      		movw r24,r12
 3844 0702 0197      		sbiw r24,1
 3845 0704 A109      		sbc r26,__zero_reg__
 3846 0706 B109      		sbc r27,__zero_reg__
 3847               	.LVL379:
 3848 0708 00D0      		rcall gb_flash_write_bus_cycle
 3849               	.LVL380:
 3850               	.LBB229:
 3851               	.LBB230:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3852               		.loc 2 187 0
 3853 070a EFE1      		ldi r30,lo8(19999)
 3854 070c FEE4      		ldi r31,hi8(19999)
 3855 070e 3197      	1:	sbiw r30,1
 3856 0710 01F4      		brne 1b
 3857               	.LVL381:
 3858               	.L251:
 3859 0712 00C0      		rjmp .
 3860 0714 0000      		nop
 3861 0716 00C0      		rjmp .L239
 3862               	.LVL382:
 3863               	.L153:
 3864               	.LBE230:
 3865               	.LBE229:
 578:main.c        **** 			usart_read_chars(); // Read address
 3866               		.loc 3 578 0
 3867 0718 8E36      		cpi r24,lo8(110)
 3868 071a 01F4      		brne .L156
 3869               	.LBB231:
 579:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3870               		.loc 3 579 0
 3871 071c 00D0      		rcall usart_read_chars
 3872               	.LVL383:
 580:main.c        **** 			
 3873               		.loc 3 580 0
 3874 071e 40E1      		ldi r20,lo8(16)
 3875 0720 50E0      		ldi r21,0
 3876 0722 60E0      		ldi r22,0
 3877 0724 70E0      		ldi r23,0
 3878 0726 80E0      		ldi r24,lo8(receivedBuffer)
 3879 0728 90E0      		ldi r25,hi8(receivedBuffer)
 3880 072a 00D0      		rcall strtol
 3881               	.LVL384:
 3882 072c 4B01      		movw r8,r22
 3883 072e 5C01      		movw r10,r24
 3884               	.LVL385:
 582:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3885               		.loc 3 582 0
 3886 0730 00D0      		rcall USART_Receive
 3887               	.LVL386:
 3888 0732 8093 0000 		sts receivedChar,r24
 583:main.c        **** 				usart_read_chars(); // Read data
 3889               		.loc 3 583 0
 3890 0736 8E36      		cpi r24,lo8(110)
 3891 0738 01F0      		breq .+2
 3892 073a 00C0      		rjmp .L93
 3893               	.LBB232:
 584:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 3894               		.loc 3 584 0
 3895 073c 00D0      		rcall usart_read_chars
 3896               	.LVL387:
 585:main.c        **** 				
 3897               		.loc 3 585 0
 3898 073e 40E1      		ldi r20,lo8(16)
 3899 0740 50E0      		ldi r21,0
 3900 0742 60E0      		ldi r22,0
 3901 0744 70E0      		ldi r23,0
 3902 0746 80E0      		ldi r24,lo8(receivedBuffer)
 3903 0748 90E0      		ldi r25,hi8(receivedBuffer)
 3904 074a 00D0      		rcall strtol
 3905               	.LVL388:
 587:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3906               		.loc 3 587 0
 3907 074c 939A      		sbi 0x12,3
 588:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3908               		.loc 3 588 0
 3909 074e C4BB      		out 0x14,r28
 589:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3910               		.loc 3 589 0
 3911 0750 CABB      		out 0x1a,r28
 590:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 3912               		.loc 3 590 0
 3913 0752 C7BB      		out 0x17,r28
 591:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3914               		.loc 3 591 0
 3915 0754 AB01      		movw r20,r22
 3916 0756 C501      		movw r24,r10
 3917 0758 B401      		movw r22,r8
 3918               	.LVL389:
 3919 075a 00D0      		rcall gba_flash_write_bus_cycle
 3920               	.LVL390:
 3921               	.L250:
 592:main.c        **** 				
 3922               		.loc 3 592 0
 3923 075c 9398      		cbi 0x12,3
 594:main.c        **** 			}
 3924               		.loc 3 594 0
 3925 075e 81E3      		ldi r24,lo8(49)
 3926 0760 00C0      		rjmp .L231
 3927               	.LVL391:
 3928               	.L156:
 3929               	.LBE232:
 3930               	.LBE231:
 599:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3931               		.loc 3 599 0
 3932 0762 8137      		cpi r24,lo8(113)
 3933 0764 01F0      		breq .L157
 599:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3934               		.loc 3 599 0 is_stmt 0 discriminator 1
 3935 0766 8437      		cpi r24,lo8(116)
 3936 0768 01F4      		brne .L158
 3937               	.L157:
 3938               	.LBB233:
 600:main.c        **** 			
 3939               		.loc 3 600 0 is_stmt 1
 3940 076a 939A      		sbi 0x12,3
 3941               	.LVL392:
 603:main.c        **** 				readLength = 256;
 3942               		.loc 3 603 0
 3943 076c 8091 0000 		lds r24,receivedChar
 3944 0770 8437      		cpi r24,lo8(116)
 3945 0772 01F4      		brne .L203
 604:main.c        **** 			}
 3946               		.loc 3 604 0
 3947 0774 00E0      		ldi r16,0
 3948 0776 11E0      		ldi r17,lo8(1)
 3949 0778 00C0      		rjmp .L159
 3950               	.L203:
 602:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 3951               		.loc 3 602 0
 3952 077a 00E4      		ldi r16,lo8(64)
 3953 077c 10E0      		ldi r17,0
 3954               	.L159:
 3955               	.LVL393:
 606:main.c        **** 			
 3956               		.loc 3 606 0
 3957 077e C801      		movw r24,r16
 3958 0780 00D0      		rcall usart_read_bytes
 3959               	.LVL394:
 3960 0782 40E0      		ldi r20,lo8(receivedBuffer)
 3961 0784 A42E      		mov r10,r20
 3962 0786 40E0      		ldi r20,hi8(receivedBuffer)
 3963 0788 B42E      		mov r11,r20
 3964 078a 1601      		movw r2,r12
 3965 078c 2701      		movw r4,r14
 3966               	.LVL395:
 3967               	.L160:
 3968               	.LBB234:
 3969               	.LBB235:
 610:main.c        **** 				address++;
 3970               		.loc 3 610 0 discriminator 3
 3971 078e F501      		movw r30,r10
 3972 0790 4181      		ldd r20,Z+1
 3973 0792 50E0      		ldi r21,0
 3974 0794 542F      		mov r21,r20
 3975 0796 4427      		clr r20
 3976 0798 8081      		ld r24,Z
 3977 079a 482B      		or r20,r24
 3978 079c 21E0      		ldi r18,lo8(1)
 3979 079e C201      		movw r24,r4
 3980 07a0 B101      		movw r22,r2
 3981 07a2 00D0      		rcall gba_flash_write_byte
 3982               	.LVL396:
 611:main.c        **** 			}
 3983               		.loc 3 611 0 discriminator 3
 3984 07a4 FFEF      		ldi r31,-1
 3985 07a6 2F1A      		sub r2,r31
 3986 07a8 3F0A      		sbc r3,r31
 3987 07aa 4F0A      		sbc r4,r31
 3988 07ac 5F0A      		sbc r5,r31
 3989               	.LVL397:
 3990 07ae 22E0      		ldi r18,2
 3991 07b0 A20E      		add r10,r18
 3992 07b2 B11C      		adc r11,__zero_reg__
 3993               	.LVL398:
 3994               	.LBE235:
 608:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 3995               		.loc 3 608 0 discriminator 3
 3996 07b4 C501      		movw r24,r10
 3997 07b6 8050      		subi r24,lo8(receivedBuffer)
 3998 07b8 9040      		sbci r25,hi8(receivedBuffer)
 3999 07ba 8017      		cp r24,r16
 4000 07bc 9107      		cpc r25,r17
 4001 07be 04F0      		brlt .L160
 4002 07c0 8FEF      		ldi r24,-1
 4003 07c2 C81A      		sub r12,r24
 4004 07c4 D80A      		sbc r13,r24
 4005 07c6 E80A      		sbc r14,r24
 4006 07c8 F80A      		sbc r15,r24
 4007 07ca 0150      		subi r16,1
 4008 07cc 1109      		sbc r17,__zero_reg__
 4009               	.LVL399:
 4010 07ce 1695      		lsr r17
 4011 07d0 0795      		ror r16
 4012               	.LVL400:
 4013 07d2 C00E      		add r12,r16
 4014 07d4 D11E      		adc r13,r17
 4015 07d6 E11C      		adc r14,__zero_reg__
 4016 07d8 F11C      		adc r15,__zero_reg__
 4017 07da 00C0      		rjmp .L239
 4018               	.LVL401:
 4019               	.L158:
 4020               	.LBE234:
 4021               	.LBE233:
 619:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4022               		.loc 3 619 0
 4023 07dc 8636      		cpi r24,lo8(102)
 4024 07de 01F4      		brne .L161
 4025               	.LBB236:
 620:main.c        **** 			
 4026               		.loc 3 620 0
 4027 07e0 939A      		sbi 0x12,3
 4028               	.LVL402:
 623:main.c        **** 			
 4029               		.loc 3 623 0
 4030 07e2 80E0      		ldi r24,0
 4031 07e4 91E0      		ldi r25,lo8(1)
 4032 07e6 00D0      		rcall usart_read_bytes
 4033               	.LVL403:
 4034 07e8 00E0      		ldi r16,lo8(receivedBuffer)
 4035 07ea 10E0      		ldi r17,hi8(receivedBuffer)
 4036 07ec 4601      		movw r8,r12
 4037 07ee 5701      		movw r10,r14
 4038               	.LVL404:
 4039               	.L162:
 4040               	.LBB237:
 4041               	.LBB238:
 627:main.c        **** 				address++;
 4042               		.loc 3 627 0 discriminator 3
 4043 07f0 F801      		movw r30,r16
 4044 07f2 4181      		ldd r20,Z+1
 4045 07f4 50E0      		ldi r21,0
 4046 07f6 542F      		mov r21,r20
 4047 07f8 4427      		clr r20
 4048 07fa 8081      		ld r24,Z
 4049 07fc 482B      		or r20,r24
 4050 07fe 20E0      		ldi r18,0
 4051 0800 C501      		movw r24,r10
 4052 0802 B401      		movw r22,r8
 4053 0804 00D0      		rcall gba_flash_write_byte
 4054               	.LVL405:
 628:main.c        **** 			}
 4055               		.loc 3 628 0 discriminator 3
 4056 0806 FFEF      		ldi r31,-1
 4057 0808 8F1A      		sub r8,r31
 4058 080a 9F0A      		sbc r9,r31
 4059 080c AF0A      		sbc r10,r31
 4060 080e BF0A      		sbc r11,r31
 4061               	.LVL406:
 4062 0810 0E5F      		subi r16,-2
 4063 0812 1F4F      		sbci r17,-1
 4064               	.LVL407:
 4065               	.LBE238:
 625:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4066               		.loc 3 625 0 discriminator 3
 4067 0814 20E0      		ldi r18,hi8(receivedBuffer+256)
 4068 0816 0030      		cpi r16,lo8(receivedBuffer+256)
 4069 0818 1207      		cpc r17,r18
 4070 081a 01F4      		brne .L162
 4071 081c 80E8      		ldi r24,-128
 4072 081e C80E      		add r12,r24
 4073 0820 D11C      		adc r13,__zero_reg__
 4074 0822 E11C      		adc r14,__zero_reg__
 4075 0824 F11C      		adc r15,__zero_reg__
 4076 0826 00C0      		rjmp .L239
 4077               	.LVL408:
 4078               	.L161:
 4079               	.LBE237:
 4080               	.LBE236:
 637:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4081               		.loc 3 637 0
 4082 0828 8C36      		cpi r24,lo8(108)
 4083 082a 01F0      		breq .+2
 4084 082c 00C0      		rjmp .L163
 4085               	.LBB239:
 638:main.c        **** 			usart_read_bytes(64);
 4086               		.loc 3 638 0
 4087 082e 939A      		sbi 0x12,3
 639:main.c        **** 			
 4088               		.loc 3 639 0
 4089 0830 80E4      		ldi r24,lo8(64)
 4090 0832 90E0      		ldi r25,0
 4091 0834 00D0      		rcall usart_read_bytes
 4092               	.LVL409:
 4093               		.loc 3 642 0
 4094 0836 C4BB      		out 0x14,r28
 643:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4095               		.loc 3 643 0
 4096 0838 CABB      		out 0x1a,r28
 644:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4097               		.loc 3 644 0
 4098 083a C7BB      		out 0x17,r28
 645:main.c        **** 			
 646:main.c        **** 			// Unlock
 647:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 4099               		.loc 3 647 0
 4100 083c 40E6      		ldi r20,lo8(96)
 4101 083e 50E0      		ldi r21,0
 4102 0840 C701      		movw r24,r14
 4103 0842 B601      		movw r22,r12
 4104 0844 00D0      		rcall gba_flash_write_bus_cycle
 4105               	.LVL410:
 648:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4106               		.loc 3 648 0
 4107 0846 40ED      		ldi r20,lo8(-48)
 4108 0848 50E0      		ldi r21,0
 4109 084a C701      		movw r24,r14
 4110 084c B601      		movw r22,r12
 4111 084e 00D0      		rcall gba_flash_write_bus_cycle
 4112               	.LVL411:
 649:main.c        **** 			
 650:main.c        **** 			// Buffered write command
 651:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 4113               		.loc 3 651 0
 4114 0850 48EE      		ldi r20,lo8(-24)
 4115 0852 50E0      		ldi r21,0
 4116 0854 C701      		movw r24,r14
 4117 0856 B601      		movw r22,r12
 4118 0858 00D0      		rcall gba_flash_write_bus_cycle
 4119               	.LVL412:
 4120               	.LBB164:
 4121               	.LBB165:
 4122               		.loc 2 276 0
 4123 085a 95E8      		ldi r25,lo8(-123)
 4124 085c 9A95      	1:	dec r25
 4125 085e 01F4      		brne 1b
 4126 0860 0000      		nop
 4127               	.LVL413:
 4128               	.LBE165:
 4129               	.LBE164:
 652:main.c        **** 			_delay_us(50);
 653:main.c        **** 			
 654:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 655:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 4130               		.loc 3 655 0
 4131 0862 C701      		movw r24,r14
 4132 0864 B601      		movw r22,r12
 4133 0866 00D0      		rcall gba_read_16bit_data
 4134               	.LVL414:
 4135               	.L164:
 656:main.c        **** 			while (dataVerify != 0x0080) {
 4136               		.loc 3 656 0
 4137 0868 8038      		cpi r24,-128
 4138 086a 9105      		cpc r25,__zero_reg__
 4139 086c 01F0      		breq .L253
 657:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4140               		.loc 3 657 0
 4141 086e C701      		movw r24,r14
 4142 0870 B601      		movw r22,r12
 4143 0872 00D0      		rcall gba_read_16bit_data
 4144               	.LVL415:
 4145               	.LBB166:
 4146               	.LBB167:
 4147               		.loc 2 276 0
 4148 0874 E5E8      		ldi r30,lo8(-123)
 4149 0876 EA95      	1:	dec r30
 4150 0878 01F4      		brne 1b
 4151 087a 0000      		nop
 4152 087c 00C0      		rjmp .L164
 4153               	.LVL416:
 4154               	.L253:
 4155               	.LBE167:
 4156               	.LBE166:
 658:main.c        **** 				_delay_us(50);
 659:main.c        **** 			}
 660:main.c        **** 			
 661:main.c        **** 			
 662:main.c        **** 			// Set address lines as outputs
 663:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4157               		.loc 3 663 0
 4158 087e C4BB      		out 0x14,r28
 664:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4159               		.loc 3 664 0
 4160 0880 CABB      		out 0x1a,r28
 665:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4161               		.loc 3 665 0
 4162 0882 C7BB      		out 0x17,r28
 666:main.c        **** 			
 667:main.c        **** 			// Set length
 668:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 4163               		.loc 3 668 0
 4164 0884 4FE1      		ldi r20,lo8(31)
 4165 0886 50E0      		ldi r21,0
 4166 0888 C701      		movw r24,r14
 4167 088a B601      		movw r22,r12
 4168 088c 00D0      		rcall gba_flash_write_bus_cycle
 4169               	.LVL417:
 4170 088e 00E0      		ldi r16,lo8(receivedBuffer)
 4171 0890 10E0      		ldi r17,hi8(receivedBuffer)
 4172 0892 4601      		movw r8,r12
 4173 0894 5701      		movw r10,r14
 4174               	.LVL418:
 4175               	.L166:
 4176               	.LBB168:
 4177               	.LBB169:
 669:main.c        **** 			
 670:main.c        **** 			// Write data
 671:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 672:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 673:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4178               		.loc 3 673 0 discriminator 3
 4179 0896 F801      		movw r30,r16
 4180 0898 4181      		ldd r20,Z+1
 4181 089a 50E0      		ldi r21,0
 4182 089c 542F      		mov r21,r20
 4183 089e 4427      		clr r20
 4184 08a0 8081      		ld r24,Z
 4185 08a2 482B      		or r20,r24
 4186 08a4 C501      		movw r24,r10
 4187 08a6 B401      		movw r22,r8
 4188 08a8 00D0      		rcall gba_flash_write_bus_cycle
 4189               	.LVL419:
 674:main.c        **** 				address++;
 4190               		.loc 3 674 0 discriminator 3
 4191 08aa FFEF      		ldi r31,-1
 4192 08ac 8F1A      		sub r8,r31
 4193 08ae 9F0A      		sbc r9,r31
 4194 08b0 AF0A      		sbc r10,r31
 4195 08b2 BF0A      		sbc r11,r31
 4196               	.LVL420:
 4197 08b4 0E5F      		subi r16,-2
 4198 08b6 1F4F      		sbci r17,-1
 4199               	.LVL421:
 4200               	.LBE169:
 671:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4201               		.loc 3 671 0 discriminator 3
 4202 08b8 80E0      		ldi r24,lo8(receivedBuffer+64)
 4203 08ba 90E0      		ldi r25,hi8(receivedBuffer+64)
 4204 08bc 8017      		cp r24,r16
 4205 08be 9107      		cpc r25,r17
 4206 08c0 01F4      		brne .L166
 4207 08c2 90E2      		ldi r25,32
 4208 08c4 C90E      		add r12,r25
 4209 08c6 D11C      		adc r13,__zero_reg__
 4210 08c8 E11C      		adc r14,__zero_reg__
 4211 08ca F11C      		adc r15,__zero_reg__
 4212               	.LBE168:
 675:main.c        **** 			}
 676:main.c        **** 			
 677:main.c        **** 			// Write buffer to flash
 678:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4213               		.loc 3 678 0
 4214 08cc 40ED      		ldi r20,lo8(-48)
 4215 08ce 50E0      		ldi r21,0
 4216 08d0 C701      		movw r24,r14
 4217 08d2 B601      		movw r22,r12
 4218 08d4 00D0      		rcall gba_flash_write_bus_cycle
 4219               	.LVL422:
 4220               	.LBB170:
 4221               	.LBB171:
 4222               		.loc 2 276 0
 4223 08d6 EFE6      		ldi r30,lo8(879)
 4224 08d8 F3E0      		ldi r31,hi8(879)
 4225 08da 3197      	1:	sbiw r30,1
 4226 08dc 01F4      		brne 1b
 4227 08de 00C0      		rjmp .
 4228 08e0 0000      		nop
 4229               	.LVL423:
 4230               	.LBE171:
 4231               	.LBE170:
 679:main.c        **** 			_delay_us(440);
 680:main.c        **** 			
 681:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 682:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 4232               		.loc 3 682 0
 4233 08e2 C701      		movw r24,r14
 4234 08e4 B601      		movw r22,r12
 4235 08e6 00D0      		rcall gba_read_16bit_data
 4236               	.LVL424:
 4237               	.L167:
 683:main.c        **** 			while (dataVerify != 0x0080) {
 4238               		.loc 3 683 0
 4239 08e8 8038      		cpi r24,-128
 4240 08ea 9105      		cpc r25,__zero_reg__
 4241 08ec 01F0      		breq .L254
 684:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4242               		.loc 3 684 0
 4243 08ee C701      		movw r24,r14
 4244 08f0 B601      		movw r22,r12
 4245 08f2 00D0      		rcall gba_read_16bit_data
 4246               	.LVL425:
 4247               	.LBB172:
 4248               	.LBB173:
 4249               		.loc 2 276 0
 4250 08f4 F5E8      		ldi r31,lo8(-123)
 4251 08f6 FA95      	1:	dec r31
 4252 08f8 01F4      		brne 1b
 4253 08fa 0000      		nop
 4254 08fc 00C0      		rjmp .L167
 4255               	.LVL426:
 4256               	.L254:
 4257               	.LBE173:
 4258               	.LBE172:
 685:main.c        **** 				_delay_us(50);
 686:main.c        **** 			}
 687:main.c        **** 			
 688:main.c        **** 			
 689:main.c        **** 			// Set address lines as outputs
 690:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4259               		.loc 3 690 0
 4260 08fe C4BB      		out 0x14,r28
 691:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4261               		.loc 3 691 0
 4262 0900 CABB      		out 0x1a,r28
 692:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4263               		.loc 3 692 0
 4264 0902 C7BB      		out 0x17,r28
 693:main.c        **** 			
 694:main.c        **** 			// Back to reading mode
 695:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 4265               		.loc 3 695 0
 4266 0904 4FEF      		ldi r20,lo8(-1)
 4267 0906 50E0      		ldi r21,0
 4268 0908 C701      		movw r24,r14
 4269 090a B601      		movw r22,r12
 4270 090c 00D0      		rcall gba_flash_write_bus_cycle
 4271               	.LVL427:
 4272               	.L239:
 696:main.c        **** 			
 697:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 4273               		.loc 3 697 0
 4274 090e 81E3      		ldi r24,lo8(49)
 4275 0910 00C0      		rjmp .L234
 4276               	.LVL428:
 4277               	.L163:
 4278               	.LBE239:
 698:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 699:main.c        **** 		}
 700:main.c        **** 		
 701:main.c        **** 		
 702:main.c        **** 		// ---------- General commands ----------
 703:main.c        **** 		// Set any pin as input/output
 704:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 705:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 4279               		.loc 3 705 0
 4280 0912 8934      		cpi r24,lo8(73)
 4281 0914 01F0      		breq .L169
 4282               		.loc 3 705 0 is_stmt 0 discriminator 1
 4283 0916 8F34      		cpi r24,lo8(79)
 4284 0918 01F0      		breq .+2
 4285 091a 00C0      		rjmp .L170
 4286               	.L169:
 4287               	.LBB240:
 706:main.c        **** 			char portChar = USART_Receive();
 4288               		.loc 3 706 0 is_stmt 1
 4289 091c 00D0      		rcall USART_Receive
 4290               	.LVL429:
 4291 091e 182F      		mov r17,r24
 4292               	.LVL430:
 707:main.c        **** 			usart_read_chars();
 4293               		.loc 3 707 0
 4294 0920 00D0      		rcall usart_read_chars
 4295               	.LVL431:
 708:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4296               		.loc 3 708 0
 4297 0922 40E1      		ldi r20,lo8(16)
 4298 0924 50E0      		ldi r21,0
 4299 0926 60E0      		ldi r22,0
 4300 0928 70E0      		ldi r23,0
 4301 092a 80E0      		ldi r24,lo8(receivedBuffer)
 4302 092c 90E0      		ldi r25,hi8(receivedBuffer)
 4303 092e 00D0      		rcall strtol
 4304               	.LVL432:
 709:main.c        **** 			
 710:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4305               		.loc 3 710 0
 4306 0930 939A      		sbi 0x12,3
 711:main.c        **** 			if (receivedChar == SET_INPUT) {
 4307               		.loc 3 711 0
 4308 0932 8091 0000 		lds r24,receivedChar
 4309 0936 8934      		cpi r24,lo8(73)
 4310 0938 01F4      		brne .L171
 712:main.c        **** 				if (portChar == 'A') {
 4311               		.loc 3 712 0
 4312 093a 1134      		cpi r17,lo8(65)
 4313 093c 01F4      		brne .L172
 713:main.c        **** 					DDRA &= ~(setValue);
 4314               		.loc 3 713 0
 4315 093e 8AB3      		in r24,0x1a
 4316 0940 6095      		com r22
 4317               	.LVL433:
 4318 0942 6823      		and r22,r24
 4319               	.LVL434:
 4320 0944 00C0      		rjmp .L241
 4321               	.LVL435:
 4322               	.L172:
 714:main.c        **** 				}
 715:main.c        **** 				else if (portChar == 'B') {
 4323               		.loc 3 715 0
 4324 0946 1234      		cpi r17,lo8(66)
 4325 0948 01F4      		brne .L174
 716:main.c        **** 					DDRB &= ~(setValue);
 4326               		.loc 3 716 0
 4327 094a 87B3      		in r24,0x17
 4328 094c 6095      		com r22
 4329               	.LVL436:
 4330 094e 6823      		and r22,r24
 4331               	.LVL437:
 4332 0950 00C0      		rjmp .L242
 4333               	.LVL438:
 4334               	.L174:
 717:main.c        **** 				}
 718:main.c        **** 				else if (portChar == 'C') {
 4335               		.loc 3 718 0
 4336 0952 1334      		cpi r17,lo8(67)
 4337 0954 01F4      		brne .L175
 719:main.c        **** 					DDRC &= ~(setValue);
 4338               		.loc 3 719 0
 4339 0956 84B3      		in r24,0x14
 4340 0958 6095      		com r22
 4341               	.LVL439:
 4342 095a 6823      		and r22,r24
 4343               	.LVL440:
 4344 095c 00C0      		rjmp .L247
 4345               	.LVL441:
 4346               	.L175:
 720:main.c        **** 				}
 721:main.c        **** 				else if (portChar == 'D') {
 4347               		.loc 3 721 0
 4348 095e 1434      		cpi r17,lo8(68)
 4349 0960 01F4      		brne .L176
 722:main.c        **** 					DDRD &= ~(setValue);
 4350               		.loc 3 722 0
 4351 0962 81B3      		in r24,0x11
 4352 0964 6095      		com r22
 4353               	.LVL442:
 4354 0966 6823      		and r22,r24
 4355               	.LVL443:
 4356 0968 00C0      		rjmp .L248
 4357               	.LVL444:
 4358               	.L176:
 723:main.c        **** 				}
 724:main.c        **** 				else if (portChar == 'E') {
 4359               		.loc 3 724 0
 4360 096a 1534      		cpi r17,lo8(69)
 4361 096c 01F0      		breq .+2
 4362 096e 00C0      		rjmp .L195
 725:main.c        **** 					DDRE &= ~(setValue);
 4363               		.loc 3 725 0
 4364 0970 86B1      		in r24,0x6
 4365 0972 6095      		com r22
 4366               	.LVL445:
 4367 0974 6823      		and r22,r24
 4368               	.LVL446:
 4369 0976 00C0      		rjmp .L249
 4370               	.LVL447:
 4371               	.L171:
 726:main.c        **** 				}
 727:main.c        **** 			}
 728:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 4372               		.loc 3 728 0
 4373 0978 8F34      		cpi r24,lo8(79)
 4374 097a 01F0      		breq .+2
 4375 097c 00C0      		rjmp .L195
 729:main.c        **** 				if (portChar == 'A') {
 4376               		.loc 3 729 0
 4377 097e 1134      		cpi r17,lo8(65)
 4378 0980 01F4      		brne .L177
 730:main.c        **** 					DDRA |= (setValue);
 4379               		.loc 3 730 0
 4380 0982 8AB3      		in r24,0x1a
 4381 0984 682B      		or r22,r24
 4382               	.LVL448:
 4383               	.L241:
 4384 0986 6ABB      		out 0x1a,r22
 4385 0988 00C0      		rjmp .L195
 4386               	.LVL449:
 4387               	.L177:
 731:main.c        **** 				}
 732:main.c        **** 				else if (portChar == 'B') {
 4388               		.loc 3 732 0
 4389 098a 1234      		cpi r17,lo8(66)
 4390 098c 01F4      		brne .L178
 733:main.c        **** 					DDRB |= (setValue);
 4391               		.loc 3 733 0
 4392 098e 87B3      		in r24,0x17
 4393 0990 682B      		or r22,r24
 4394               	.LVL450:
 4395               	.L242:
 4396 0992 67BB      		out 0x17,r22
 4397 0994 00C0      		rjmp .L195
 4398               	.LVL451:
 4399               	.L178:
 734:main.c        **** 				}
 735:main.c        **** 				else if (portChar == 'C') {
 4400               		.loc 3 735 0
 4401 0996 1334      		cpi r17,lo8(67)
 4402 0998 01F4      		brne .L179
 736:main.c        **** 					DDRC |= (setValue);
 4403               		.loc 3 736 0
 4404 099a 84B3      		in r24,0x14
 4405 099c 682B      		or r22,r24
 4406               	.LVL452:
 4407               	.L247:
 4408 099e 64BB      		out 0x14,r22
 4409 09a0 00C0      		rjmp .L195
 4410               	.LVL453:
 4411               	.L179:
 737:main.c        **** 				}
 738:main.c        **** 				else if (portChar == 'D') {
 4412               		.loc 3 738 0
 4413 09a2 1434      		cpi r17,lo8(68)
 4414 09a4 01F4      		brne .L180
 739:main.c        **** 					DDRD |= (setValue);
 4415               		.loc 3 739 0
 4416 09a6 81B3      		in r24,0x11
 4417 09a8 682B      		or r22,r24
 4418               	.LVL454:
 4419               	.L248:
 4420 09aa 61BB      		out 0x11,r22
 4421 09ac 00C0      		rjmp .L195
 4422               	.LVL455:
 4423               	.L180:
 740:main.c        **** 				}
 741:main.c        **** 				else if (portChar == 'E') {
 4424               		.loc 3 741 0
 4425 09ae 1534      		cpi r17,lo8(69)
 4426 09b0 01F0      		breq .+2
 4427 09b2 00C0      		rjmp .L195
 742:main.c        **** 					DDRE |= (setValue);
 4428               		.loc 3 742 0
 4429 09b4 86B1      		in r24,0x6
 4430 09b6 682B      		or r22,r24
 4431               	.LVL456:
 4432               	.L249:
 4433 09b8 66B9      		out 0x6,r22
 4434 09ba 00C0      		rjmp .L195
 4435               	.LVL457:
 4436               	.L170:
 4437               	.LBE240:
 743:main.c        **** 				}
 744:main.c        **** 			}
 745:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 746:main.c        **** 		}
 747:main.c        **** 		
 748:main.c        **** 		// Set pin output as low
 749:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 4438               		.loc 3 749 0
 4439 09bc 8C34      		cpi r24,lo8(76)
 4440 09be 01F4      		brne .L181
 4441               	.LBB241:
 750:main.c        **** 			char portChar = USART_Receive();			
 4442               		.loc 3 750 0
 4443 09c0 00D0      		rcall USART_Receive
 4444               	.LVL458:
 4445 09c2 182F      		mov r17,r24
 4446               	.LVL459:
 751:main.c        **** 			usart_read_chars();
 4447               		.loc 3 751 0
 4448 09c4 00D0      		rcall usart_read_chars
 4449               	.LVL460:
 752:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4450               		.loc 3 752 0
 4451 09c6 40E1      		ldi r20,lo8(16)
 4452 09c8 50E0      		ldi r21,0
 4453 09ca 60E0      		ldi r22,0
 4454 09cc 70E0      		ldi r23,0
 4455 09ce 80E0      		ldi r24,lo8(receivedBuffer)
 4456 09d0 90E0      		ldi r25,hi8(receivedBuffer)
 4457 09d2 00D0      		rcall strtol
 4458               	.LVL461:
 753:main.c        **** 			
 754:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4459               		.loc 3 754 0
 4460 09d4 939A      		sbi 0x12,3
 755:main.c        **** 			if (portChar == 'A') {
 4461               		.loc 3 755 0
 4462 09d6 1134      		cpi r17,lo8(65)
 4463 09d8 01F4      		brne .L182
 756:main.c        **** 				PORTA &= ~(setValue);
 4464               		.loc 3 756 0
 4465 09da 8BB3      		in r24,0x1b
 4466 09dc 6095      		com r22
 4467               	.LVL462:
 4468 09de 6823      		and r22,r24
 4469               	.LVL463:
 4470 09e0 00C0      		rjmp .L246
 4471               	.LVL464:
 4472               	.L182:
 757:main.c        **** 			}
 758:main.c        **** 			else if (portChar == 'B') {
 4473               		.loc 3 758 0
 4474 09e2 1234      		cpi r17,lo8(66)
 4475 09e4 01F4      		brne .L184
 759:main.c        **** 				PORTB &= ~(setValue);
 4476               		.loc 3 759 0
 4477 09e6 88B3      		in r24,0x18
 4478 09e8 6095      		com r22
 4479               	.LVL465:
 4480 09ea 6823      		and r22,r24
 4481               	.LVL466:
 4482 09ec 00C0      		rjmp .L245
 4483               	.LVL467:
 4484               	.L184:
 760:main.c        **** 			}
 761:main.c        **** 			else if (portChar == 'C') {
 4485               		.loc 3 761 0
 4486 09ee 1334      		cpi r17,lo8(67)
 4487 09f0 01F4      		brne .L185
 762:main.c        **** 				PORTC &= ~(setValue);
 4488               		.loc 3 762 0
 4489 09f2 85B3      		in r24,0x15
 4490 09f4 6095      		com r22
 4491               	.LVL468:
 4492 09f6 6823      		and r22,r24
 4493               	.LVL469:
 4494 09f8 00C0      		rjmp .L244
 4495               	.LVL470:
 4496               	.L185:
 763:main.c        **** 			}
 764:main.c        **** 			else if (portChar == 'D') {
 4497               		.loc 3 764 0
 4498 09fa 1434      		cpi r17,lo8(68)
 4499 09fc 01F4      		brne .L186
 765:main.c        **** 				PORTD &= ~(setValue);
 4500               		.loc 3 765 0
 4501 09fe 82B3      		in r24,0x12
 4502 0a00 6095      		com r22
 4503               	.LVL471:
 4504 0a02 6823      		and r22,r24
 4505               	.LVL472:
 4506 0a04 00C0      		rjmp .L243
 4507               	.LVL473:
 4508               	.L186:
 766:main.c        **** 			}
 767:main.c        **** 			else if (portChar == 'E') {
 4509               		.loc 3 767 0
 4510 0a06 1534      		cpi r17,lo8(69)
 4511 0a08 01F0      		breq .+2
 4512 0a0a 00C0      		rjmp .L195
 768:main.c        **** 				PORTE &= ~(setValue);
 4513               		.loc 3 768 0
 4514 0a0c 87B1      		in r24,0x7
 4515 0a0e 6095      		com r22
 4516               	.LVL474:
 4517 0a10 6823      		and r22,r24
 4518               	.LVL475:
 4519 0a12 00C0      		rjmp .L240
 4520               	.LVL476:
 4521               	.L181:
 4522               	.LBE241:
 769:main.c        **** 			}
 770:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 771:main.c        **** 		}
 772:main.c        **** 		
 773:main.c        **** 		// Set pin output as high
 774:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 4523               		.loc 3 774 0
 4524 0a14 8834      		cpi r24,lo8(72)
 4525 0a16 01F4      		brne .L187
 4526               	.LBB242:
 775:main.c        **** 			char portChar = USART_Receive();			
 4527               		.loc 3 775 0
 4528 0a18 00D0      		rcall USART_Receive
 4529               	.LVL477:
 4530 0a1a 182F      		mov r17,r24
 4531               	.LVL478:
 776:main.c        **** 			usart_read_chars();
 4532               		.loc 3 776 0
 4533 0a1c 00D0      		rcall usart_read_chars
 4534               	.LVL479:
 777:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4535               		.loc 3 777 0
 4536 0a1e 40E1      		ldi r20,lo8(16)
 4537 0a20 50E0      		ldi r21,0
 4538 0a22 60E0      		ldi r22,0
 4539 0a24 70E0      		ldi r23,0
 4540 0a26 80E0      		ldi r24,lo8(receivedBuffer)
 4541 0a28 90E0      		ldi r25,hi8(receivedBuffer)
 4542 0a2a 00D0      		rcall strtol
 4543               	.LVL480:
 778:main.c        **** 			
 779:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4544               		.loc 3 779 0
 4545 0a2c 939A      		sbi 0x12,3
 780:main.c        **** 			if (portChar == 'A') {
 4546               		.loc 3 780 0
 4547 0a2e 1134      		cpi r17,lo8(65)
 4548 0a30 01F4      		brne .L188
 781:main.c        **** 				PORTA |= (setValue);
 4549               		.loc 3 781 0
 4550 0a32 8BB3      		in r24,0x1b
 4551 0a34 682B      		or r22,r24
 4552               	.LVL481:
 4553               	.L246:
 4554 0a36 6BBB      		out 0x1b,r22
 4555 0a38 00C0      		rjmp .L195
 4556               	.LVL482:
 4557               	.L188:
 782:main.c        **** 			}
 783:main.c        **** 			else if (portChar == 'B') {
 4558               		.loc 3 783 0
 4559 0a3a 1234      		cpi r17,lo8(66)
 4560 0a3c 01F4      		brne .L190
 784:main.c        **** 				PORTB |= (setValue);
 4561               		.loc 3 784 0
 4562 0a3e 88B3      		in r24,0x18
 4563 0a40 682B      		or r22,r24
 4564               	.LVL483:
 4565               	.L245:
 4566 0a42 68BB      		out 0x18,r22
 4567 0a44 00C0      		rjmp .L195
 4568               	.LVL484:
 4569               	.L190:
 785:main.c        **** 			}
 786:main.c        **** 			else if (portChar == 'C') {
 4570               		.loc 3 786 0
 4571 0a46 1334      		cpi r17,lo8(67)
 4572 0a48 01F4      		brne .L191
 787:main.c        **** 				PORTC |= (setValue);
 4573               		.loc 3 787 0
 4574 0a4a 85B3      		in r24,0x15
 4575 0a4c 682B      		or r22,r24
 4576               	.LVL485:
 4577               	.L244:
 4578 0a4e 65BB      		out 0x15,r22
 4579 0a50 00C0      		rjmp .L195
 4580               	.LVL486:
 4581               	.L191:
 788:main.c        **** 			}
 789:main.c        **** 			else if (portChar == 'D') {
 4582               		.loc 3 789 0
 4583 0a52 1434      		cpi r17,lo8(68)
 4584 0a54 01F4      		brne .L192
 790:main.c        **** 				PORTD |= (setValue);
 4585               		.loc 3 790 0
 4586 0a56 82B3      		in r24,0x12
 4587 0a58 682B      		or r22,r24
 4588               	.LVL487:
 4589               	.L243:
 4590 0a5a 62BB      		out 0x12,r22
 4591 0a5c 00C0      		rjmp .L195
 4592               	.LVL488:
 4593               	.L192:
 791:main.c        **** 			}
 792:main.c        **** 			else if (portChar == 'E') {
 4594               		.loc 3 792 0
 4595 0a5e 1534      		cpi r17,lo8(69)
 4596 0a60 01F4      		brne .L195
 793:main.c        **** 				PORTE |= (setValue);
 4597               		.loc 3 793 0
 4598 0a62 87B1      		in r24,0x7
 4599 0a64 682B      		or r22,r24
 4600               	.LVL489:
 4601               	.L240:
 4602 0a66 67B9      		out 0x7,r22
 4603 0a68 00C0      		rjmp .L195
 4604               	.L187:
 4605               	.LBE242:
 794:main.c        **** 			}
 795:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 796:main.c        **** 		}
 797:main.c        **** 		
 798:main.c        **** 		// Read all pins of a PORT and return the value
 799:main.c        **** 		else if (receivedChar == READ_INPUT) {
 4606               		.loc 3 799 0
 4607 0a6a 8434      		cpi r24,lo8(68)
 4608 0a6c 01F4      		brne .L193
 4609               	.LBB243:
 800:main.c        **** 			char portChar = USART_Receive();			
 4610               		.loc 3 800 0
 4611 0a6e 00D0      		rcall USART_Receive
 4612               	.LVL490:
 801:main.c        **** 			
 802:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4613               		.loc 3 802 0
 4614 0a70 939A      		sbi 0x12,3
 803:main.c        **** 			if (portChar == 'A') {
 4615               		.loc 3 803 0
 4616 0a72 8134      		cpi r24,lo8(65)
 4617 0a74 01F4      		brne .L194
 804:main.c        **** 				USART_Transmit(PINA);
 4618               		.loc 3 804 0
 4619 0a76 89B3      		in r24,0x19
 4620               	.LVL491:
 4621 0a78 00C0      		rjmp .L234
 4622               	.LVL492:
 4623               	.L194:
 805:main.c        **** 			}
 806:main.c        **** 			else if (portChar == 'B') {
 4624               		.loc 3 806 0
 4625 0a7a 8234      		cpi r24,lo8(66)
 4626 0a7c 01F4      		brne .L196
 807:main.c        **** 				USART_Transmit(PINB);
 4627               		.loc 3 807 0
 4628 0a7e 86B3      		in r24,0x16
 4629               	.LVL493:
 4630 0a80 00C0      		rjmp .L234
 4631               	.LVL494:
 4632               	.L196:
 808:main.c        **** 			}
 809:main.c        **** 			else if (portChar == 'C') {
 4633               		.loc 3 809 0
 4634 0a82 8334      		cpi r24,lo8(67)
 4635 0a84 01F4      		brne .L197
 810:main.c        **** 				USART_Transmit(PINC);
 4636               		.loc 3 810 0
 4637 0a86 83B3      		in r24,0x13
 4638               	.LVL495:
 4639 0a88 00C0      		rjmp .L234
 4640               	.LVL496:
 4641               	.L197:
 811:main.c        **** 			}
 812:main.c        **** 			else if (portChar == 'D') {
 4642               		.loc 3 812 0
 4643 0a8a 8434      		cpi r24,lo8(68)
 4644 0a8c 01F4      		brne .L198
 813:main.c        **** 				USART_Transmit(PIND);
 4645               		.loc 3 813 0
 4646 0a8e 80B3      		in r24,0x10
 4647               	.LVL497:
 4648 0a90 00C0      		rjmp .L234
 4649               	.LVL498:
 4650               	.L198:
 814:main.c        **** 			}
 815:main.c        **** 			else if (portChar == 'E') {
 4651               		.loc 3 815 0
 4652 0a92 8534      		cpi r24,lo8(69)
 4653 0a94 01F4      		brne .L195
 816:main.c        **** 				USART_Transmit(PINE);
 4654               		.loc 3 816 0
 4655 0a96 85B1      		in r24,0x5
 4656               	.LVL499:
 4657               	.L234:
 4658 0a98 00D0      		rcall USART_Transmit
 4659               	.LVL500:
 4660               	.L195:
 817:main.c        **** 			}
 818:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 4661               		.loc 3 818 0
 4662 0a9a 9398      		cbi 0x12,3
 4663               	.LBE243:
 4664 0a9c 00C0      		rjmp .L93
 4665               	.LVL501:
 4666               	.L193:
 819:main.c        **** 		}
 820:main.c        **** 		
 821:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 822:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 4667               		.loc 3 822 0
 4668 0a9e 8D34      		cpi r24,lo8(77)
 4669 0aa0 01F4      		brne .L199
 4670               	.LBB244:
 823:main.c        **** 			char commonChar = USART_Receive();
 4671               		.loc 3 823 0
 4672 0aa2 00D0      		rcall USART_Receive
 4673               	.LVL502:
 824:main.c        **** 			if (commonChar == '1') {
 4674               		.loc 3 824 0
 4675 0aa4 8133      		cpi r24,lo8(49)
 4676 0aa6 01F4      		brne .L255
 825:main.c        **** 				resetCommonLines = 1;
 4677               		.loc 3 825 0
 4678 0aa8 6624      		clr r6
 4679 0aaa 6394      		inc r6
 4680 0aac 00C0      		rjmp .L230
 4681               	.L255:
 826:main.c        **** 			}
 827:main.c        **** 			else if (commonChar == '0') {
 4682               		.loc 3 827 0
 4683 0aae 8033      		cpi r24,lo8(48)
 4684 0ab0 01F0      		breq .+2
 4685 0ab2 00C0      		rjmp .L93
 828:main.c        **** 				resetCommonLines = 0;
 4686               		.loc 3 828 0
 4687 0ab4 612C      		mov r6,__zero_reg__
 4688 0ab6 00C0      		rjmp .L94
 4689               	.LVL503:
 4690               	.L199:
 4691               	.LBE244:
 829:main.c        **** 			}
 830:main.c        **** 		}
 831:main.c        **** 		
 832:main.c        **** 		// Send back the PCB version number
 833:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 4692               		.loc 3 833 0
 4693 0ab8 8836      		cpi r24,lo8(104)
 4694 0aba 01F4      		brne .L200
 834:main.c        **** 			USART_Transmit(PCB_VERSION);
 4695               		.loc 3 834 0
 4696 0abc 84E0      		ldi r24,lo8(4)
 4697 0abe 00C0      		rjmp .L231
 4698               	.L200:
 835:main.c        **** 		}
 836:main.c        **** 		
 837:main.c        **** 		// Send back the firmware version number
 838:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 4699               		.loc 3 838 0
 4700 0ac0 8635      		cpi r24,lo8(86)
 4701 0ac2 01F4      		brne .L201
 839:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 4702               		.loc 3 839 0
 4703 0ac4 8EE0      		ldi r24,lo8(14)
 4704               	.LVL504:
 4705               	.L231:
 4706 0ac6 00D0      		rcall USART_Transmit
 4707               	.LVL505:
 4708 0ac8 00C0      		rjmp .L93
 4709               	.LVL506:
 4710               	.L201:
 840:main.c        **** 		}
 841:main.c        **** 		
 842:main.c        **** 		// Reset the AVR if it matches the number
 843:main.c        **** 		else if (receivedChar == RESET_AVR) {
 4711               		.loc 3 843 0
 4712 0aca 8A32      		cpi r24,lo8(42)
 4713 0acc 01F0      		breq .+2
 4714 0ace 00C0      		rjmp .L93
 4715               	.LBB245:
 844:main.c        **** 			usart_read_chars();
 4716               		.loc 3 844 0
 4717 0ad0 00D0      		rcall usart_read_chars
 4718               	.LVL507:
 845:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 4719               		.loc 3 845 0
 4720 0ad2 40E1      		ldi r20,lo8(16)
 4721 0ad4 50E0      		ldi r21,0
 4722 0ad6 60E0      		ldi r22,0
 4723 0ad8 70E0      		ldi r23,0
 4724 0ada 80E0      		ldi r24,lo8(receivedBuffer)
 4725 0adc 90E0      		ldi r25,hi8(receivedBuffer)
 4726 0ade 00D0      		rcall strtol
 4727               	.LVL508:
 846:main.c        **** 			if (resetValue == RESET_VALUE) {
 4728               		.loc 3 846 0
 4729 0ae0 613E      		cpi r22,-31
 4730 0ae2 754E      		sbci r23,-27
 4731 0ae4 8740      		sbci r24,7
 4732 0ae6 9105      		cpc r25,__zero_reg__
 4733 0ae8 01F0      		breq .+2
 4734 0aea 00C0      		rjmp .L93
 847:main.c        **** 				// Clear watchdog flag
 848:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 4735               		.loc 3 848 0
 4736 0aec 84B7      		in r24,0x34
 4737 0aee 877F      		andi r24,lo8(-9)
 4738 0af0 84BF      		out 0x34,r24
 849:main.c        **** 				
 850:main.c        **** 				// Start timed sequence
 851:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 4739               		.loc 3 851 0
 4740 0af2 88E1      		ldi r24,lo8(24)
 4741 0af4 81BD      		out 0x21,r24
 852:main.c        **** 				
 853:main.c        **** 				// Reset in 250 ms
 854:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 4742               		.loc 3 854 0
 4743 0af6 9CE0      		ldi r25,lo8(12)
 4744 0af8 91BD      		out 0x21,r25
 4745               	.LVL509:
 4746               	.LBB246:
 4747               	.LBB247:
 4748               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 4749               		.loc 4 105 0
 4750 0afa 8FEF      		ldi r24,lo8(-1)
 4751 0afc 9FEF      		ldi r25,lo8(-1)
 4752               	/* #APP */
 4753               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 4754 0afe 0197      		1: sbiw r24,1
 4755 0b00 01F4      		brne 1b
 4756               	 ;  0 "" 2
 4757               	.LVL510:
 4758               	/* #NOAPP */
 4759 0b02 00C0      		rjmp .L93
 4760               	.LBE247:
 4761               	.LBE246:
 4762               	.LBE245:
 4763               		.cfi_endproc
 4764               	.LFE45:
 4766               	.global	cartMode
 4767               		.data
 4770               	cartMode:
 4771 0000 02        		.byte	2
 4772               	.global	lastBankAccessed
 4773               		.section .bss
 4776               	lastBankAccessed:
 4777 0000 00        		.zero	1
 4778               	.global	flashBank1CommandWrites
 4781               	flashBank1CommandWrites:
 4782 0001 00        		.zero	1
 4783               		.comm	flashWriteCycle,12,1
 4784               		.comm	flashWriteWePin,1,1
 4785               		.comm	flashChipIdBuffer,2,1
 4786               		.comm	eepromBuffer,8,1
 4787               		.comm	receivedChar,1,1
 4788               		.comm	receivedBuffer,256,1
 4789               		.text
 4790               	.Letext0:
 4791               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 4792               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1467   .text:0000040a gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1546   .text:0000043c gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1646   .text:000004a0 gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:4776   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1809   .text:00000534 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1875   .text:00000564 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:1999   .text:000005c4 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:2121   .text:00000620 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:2229   .text:00000676 setup
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:4770   .data:00000000 cartMode
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:2325   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\cc4xrVmb.s:4781   .bss:00000001 flashBank1CommandWrites

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
