   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.3
   4:setup.c       ****  Firmware version: R16
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 16/01/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define VOLTAGE_SELECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 144:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 145:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
 146:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 147:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
 148:setup.c       **** 
 149:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 150:setup.c       **** 
 151:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 152:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 153:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 154:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 155:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 156:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE_WORD 'u'
 157:setup.c       **** 
 158:setup.c       **** #define D0D1_NOT_SWAPPED 0
 159:setup.c       **** #define D0D1_SWAPPED 1
 160:setup.c       **** 
 161:setup.c       **** // General commands
 162:setup.c       **** #define SEND_ACK '1'
 163:setup.c       **** #define CART_MODE 'C'
 164:setup.c       **** #define SET_INPUT 'I'
 165:setup.c       **** #define SET_OUTPUT 'O'
 166:setup.c       **** #define SET_OUTPUT_LOW 'L'
 167:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 168:setup.c       **** #define READ_INPUT 'D'
 169:setup.c       **** #define RESET_COMMON_LINES 'M'
 170:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 171:setup.c       **** #define READ_PCB_VERSION 'h'
 172:setup.c       **** #define VOLTAGE_3_3V '3'
 173:setup.c       **** #define VOLTAGE_5V '5'
 174:setup.c       **** 
 175:setup.c       **** #define RESET_AVR '*'
 176:setup.c       **** #define RESET_VALUE 0x7E5E1
 177:setup.c       **** 
 178:setup.c       **** 
 179:setup.c       **** char receivedBuffer[256];
 180:setup.c       **** char receivedChar;
 181:setup.c       **** uint8_t eepromBuffer[8];
 182:setup.c       **** uint8_t flashChipIdBuffer[2];
 183:setup.c       **** 
 184:setup.c       **** char flashWriteWePin;
 185:setup.c       **** uint16_t flashWriteCycle[3][2];
 186:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 187:setup.c       **** uint8_t lastBankAccessed = 0;
 188:setup.c       **** 
 189:setup.c       **** uint8_t cartMode = GBA_MODE;
 190:setup.c       **** 
 191:setup.c       **** // Receive USART data
 192:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 192 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 193:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 193 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 194:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 194 0
  26 0004 8CB1      		in r24,0xc
 195:setup.c       **** }
  27               		.loc 1 195 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 196:setup.c       **** 
 197:setup.c       **** // Transmit USART data
 198:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 198 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 199:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 199 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 200:setup.c       **** 	UDR = data;
  47               		.loc 1 200 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 201:setup.c       **** }
 202:setup.c       **** 
 203:setup.c       **** // Read 1-256 bytes from the USART 
 204:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 204 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB134:
 205:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 205 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 205 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 206:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 206 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE134:
 207:setup.c       **** 	}
 208:setup.c       **** }
 106               		.loc 1 208 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 209:setup.c       **** 
 210:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 211:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 211 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 212:setup.c       **** 	int x = 0;
 213:setup.c       **** 	while (1) {
 214:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 214 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 215:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 215 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 216:setup.c       **** 			break;
 217:setup.c       **** 		}
 218:setup.c       **** 		x++;
 219:setup.c       **** 	}
 220:setup.c       **** }
 148               		.loc 1 220 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 221:setup.c       **** 
 222:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 223:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 223 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 224:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 224 0
 167 0050 3A9A      		sbi 0x7,2
 225:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 225 0
 169 0052 949A      		sbi 0x12,4
 226:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 226 0
 171 0054 959A      		sbi 0x12,5
 227:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 227 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 228:setup.c       **** }
 229:setup.c       **** 
 230:setup.c       **** 
 231:setup.c       **** 
 232:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 233:setup.c       **** 
 234:setup.c       **** // Set Gameboy mode
 235:setup.c       **** void gb_mode(void) {
 182               		.loc 1 235 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 236:setup.c       **** 	// Set inputs
 237:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 237 0
 189 005a 15BA      		out 0x15,__zero_reg__
 238:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 238 0
 191 005c 14BA      		out 0x14,__zero_reg__
 239:setup.c       **** 	
 240:setup.c       **** 	// Set outputs
 241:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 241 0
 193 005e 18BA      		out 0x18,__zero_reg__
 242:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 242 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 243:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 243 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 244:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 244 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 245:setup.c       **** }
 246:setup.c       **** 
 247:setup.c       **** // Set the 16 bit address on A15-0
 248:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 248 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 249:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 249 0
 217 006a 9BBB      		out 0x1b,r25
 250:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 250 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 251:setup.c       **** }
 252:setup.c       **** 
 253:setup.c       **** // Set the address and read a byte from the 8 bit data line
 254:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 254 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 255:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 255 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 256:setup.c       **** 	
 257:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 257 0
 239 0072 9498      		cbi 0x12,4
 258:setup.c       **** 	rdPin_low;
 240               		.loc 1 258 0
 241 0074 9598      		cbi 0x12,5
 259:setup.c       **** 	
 260:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 260 0
 243               	/* #APP */
 244               	 ;  260 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 261:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 261 0
 248               	 ;  261 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 262:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 262 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 263:setup.c       **** 	
 264:setup.c       **** 	rdPin_high;
 255               		.loc 1 264 0
 256 007c 959A      		sbi 0x12,5
 265:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 265 0
 258 007e 949A      		sbi 0x12,4
 266:setup.c       **** 	
 267:setup.c       **** 	return data;
 268:setup.c       **** }
 259               		.loc 1 268 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 269:setup.c       **** 
 270:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 271:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 271 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 272:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 272 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 273:setup.c       **** 	
 274:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 274 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 275:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 275 0
 292 0090 D5BB      		out 0x15,r29
 276:setup.c       **** 	
 277:setup.c       **** 	// Pulse WR and mREQ if the type matches
 278:setup.c       **** 	wrPin_low;
 293               		.loc 1 278 0
 294 0092 9698      		cbi 0x12,6
 279:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 279 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 280:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 280 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 281:setup.c       **** 	}
 282:setup.c       **** 	
 283:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 283 0
 302               	/* #APP */
 303               	 ;  283 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 284:setup.c       **** 	
 285:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 285 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 286:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 286 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 287:setup.c       **** 	}
 288:setup.c       **** 	wrPin_high;
 313               		.loc 1 288 0
 314 00a2 969A      		sbi 0x12,6
 289:setup.c       **** 	
 290:setup.c       **** 	// Clear data outputs and set data pins as inputs
 291:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 291 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 292:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 292 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 293:setup.c       **** }
 320               		.loc 1 293 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 294:setup.c       **** 
 295:setup.c       **** 
 296:setup.c       **** 
 297:setup.c       **** // ****** Gameboy Advance functions ****** 
 298:setup.c       **** 
 299:setup.c       **** // Set GBA mode
 300:setup.c       **** void gba_mode(void) {
 333               		.loc 1 300 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 301:setup.c       **** 	// Set outputs for reading ROM addresses as default
 302:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 302 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 303:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 303 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 304:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 304 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 305:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 305 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 306:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 306 0
 349 00b8 8ABB      		out 0x1a,r24
 307:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 307 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 308:setup.c       **** }
 309:setup.c       **** 
 310:setup.c       **** // Set the 24 bit address on A23-0
 311:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 311 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 312:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 312 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 313:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 313 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 314:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 314 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 315:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 315 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 316:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 316 0
 385 00cc 2ABB      		out 0x1a,r18
 317:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 317 0
 387 00ce 27BB      		out 0x17,r18
 318:setup.c       **** 	
 319:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 319 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 320:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 320 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 321:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 321 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 322:setup.c       **** }
 402               		.loc 1 322 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 323:setup.c       **** 
 324:setup.c       **** 
 325:setup.c       **** 
 326:setup.c       **** // ---------- ROM/SRAM ----------
 327:setup.c       **** 
 328:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 329:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 329 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 330:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 330 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 331:setup.c       **** 	
 332:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 332 0
 424 00ec 9498      		cbi 0x12,4
 333:setup.c       **** 	
 334:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 334 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 335:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 335 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 336:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 336 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 337:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 337 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 338:setup.c       **** 	
 339:setup.c       **** 	rdPin_low;
 433               		.loc 1 339 0
 434 00f6 9598      		cbi 0x12,5
 340:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 340 0
 436               	/* #APP */
 437               	 ;  340 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 341:setup.c       **** 	
 342:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 342 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 343:setup.c       **** 	
 344:setup.c       **** 	rdPin_high;
 445               		.loc 1 344 0
 446 00fe 959A      		sbi 0x12,5
 345:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 345 0
 448 0100 949A      		sbi 0x12,4
 346:setup.c       **** 	
 347:setup.c       **** 	return data;
 449               		.loc 1 347 0
 450 0102 90E0      		ldi r25,0
 348:setup.c       **** }
 451               		.loc 1 348 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 349:setup.c       **** 
 350:setup.c       **** // Set the address and read a byte from the 8 bit data line
 351:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 351 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 352:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 352 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 353:setup.c       **** 	
 354:setup.c       **** 	rdPin_low;
 471               		.loc 1 354 0
 472 010a 9598      		cbi 0x12,5
 355:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 473               		.loc 1 355 0
 474 010c 3A98      		cbi 0x7,2
 356:setup.c       **** 	
 357:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 357 0
 476               	/* #APP */
 477               	 ;  357 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 358:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 358 0
 481               	 ;  358 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 359:setup.c       **** 	
 360:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 360 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 361:setup.c       **** 	
 362:setup.c       **** 	cs2Pin_high;
 488               		.loc 1 362 0
 489 0114 3A9A      		sbi 0x7,2
 363:setup.c       **** 	rdPin_high;
 490               		.loc 1 363 0
 491 0116 959A      		sbi 0x12,5
 364:setup.c       **** 	
 365:setup.c       **** 	return data;
 366:setup.c       **** }
 492               		.loc 1 366 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 367:setup.c       **** 
 368:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 369:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 369 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 370:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 370 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 371:setup.c       **** 	
 372:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 372 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 373:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 373 0
 520 0124 C5BB      		out 0x15,r28
 374:setup.c       **** 	
 375:setup.c       **** 	// Pulse WR
 376:setup.c       **** 	wrPin_low;
 521               		.loc 1 376 0
 522 0126 9698      		cbi 0x12,6
 377:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 523               		.loc 1 377 0
 524 0128 3A98      		cbi 0x7,2
 378:setup.c       **** 	
 379:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 379 0
 526               	/* #APP */
 527               	 ;  379 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 380:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 380 0
 531               	 ;  380 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 381:setup.c       **** 	
 382:setup.c       **** 	cs2Pin_high;
 534               		.loc 1 382 0
 535               	/* #NOAPP */
 536 012e 3A9A      		sbi 0x7,2
 383:setup.c       **** 	wrPin_high;
 537               		.loc 1 383 0
 538 0130 969A      		sbi 0x12,6
 384:setup.c       **** 	
 385:setup.c       **** 	// Clear data outputs and set data pins as inputs
 386:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 386 0
 540 0132 15BA      		out 0x15,__zero_reg__
 387:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 387 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 388:setup.c       **** }
 544               		.loc 1 388 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 389:setup.c       **** 
 390:setup.c       **** 
 391:setup.c       **** 
 392:setup.c       **** // ---------- EEPROM ----------
 393:setup.c       **** 
 394:setup.c       **** // Set address/data all high (includes AD0/A23)
 395:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 395 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 396:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 396 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 397:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 397 0
 565 013e 8ABB      		out 0x1a,r24
 398:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 398 0
 567 0140 84BB      		out 0x14,r24
 399:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 399 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 400:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 400 0
 572 0146 8BBB      		out 0x1b,r24
 401:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 401 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 402:setup.c       **** }
 403:setup.c       **** 
 404:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 405:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 405 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 406:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 406 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 407:setup.c       **** 	
 408:setup.c       **** 	int8_t x = 0;
 409:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 409 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 410:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 410 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 411:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 411 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 412:setup.c       **** 		}
 413:setup.c       **** 		else {
 414:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 415:setup.c       **** 		}
 416:setup.c       **** 		x = 15;
 603               		.loc 1 416 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 417:setup.c       **** 	}
 418:setup.c       **** 	else {
 419:setup.c       **** 		if (command == EEPROM_READ) {
 420:setup.c       **** 			address |= (1<<7) | (1<<6);
 421:setup.c       **** 		}
 422:setup.c       **** 		else {
 423:setup.c       **** 			address |= (1<<7);
 424:setup.c       **** 		}
 425:setup.c       **** 		x = 7;
 426:setup.c       **** 	}
 427:setup.c       **** 	
 428:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 429:setup.c       **** 	while (x >= 0) {
 430:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 430 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 414:setup.c       **** 		}
 613               		.loc 1 414 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 419:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 419 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 420:setup.c       **** 		}
 621               		.loc 1 420 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 423:setup.c       **** 		}
 626               		.loc 1 423 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 425:setup.c       **** 	}
 630               		.loc 1 425 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 431:setup.c       **** 			ad0Pin_high;
 432:setup.c       **** 		}
 433:setup.c       **** 		else {
 434:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 434 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 435:setup.c       **** 		}
 436:setup.c       **** 		
 437:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 437 0
 639 0174 9698      		cbi 0x12,6
 438:setup.c       **** 		asm ("nop");
 640               		.loc 1 438 0
 641               	/* #APP */
 642               	 ;  438 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 439:setup.c       **** 		asm ("nop");
 645               		.loc 1 439 0
 646               	 ;  439 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 440:setup.c       **** 		wrPin_high; 
 649               		.loc 1 440 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 441:setup.c       **** 		asm ("nop");
 652               		.loc 1 441 0
 653               	/* #APP */
 654               	 ;  441 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 442:setup.c       **** 		asm ("nop");
 657               		.loc 1 442 0
 658               	 ;  442 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 429:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 429 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 430:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 430 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 431:setup.c       **** 		}
 682               		.loc 1 431 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 443:setup.c       **** 		
 444:setup.c       **** 		x--;
 445:setup.c       **** 	}
 446:setup.c       **** 	
 447:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 448:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 448 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 449:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 449 0
 690 01a4 C098      		cbi 0x18,0
 450:setup.c       **** 		asm ("nop");
 691               		.loc 1 450 0
 692               	/* #APP */
 693               	 ;  450 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 451:setup.c       **** 		wrPin_low;
 696               		.loc 1 451 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 452:setup.c       **** 		asm ("nop");
 699               		.loc 1 452 0
 700               	/* #APP */
 701               	 ;  452 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 453:setup.c       **** 		asm ("nop");
 704               		.loc 1 453 0
 705               	 ;  453 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 454:setup.c       **** 		
 455:setup.c       **** 		wrPin_high;
 708               		.loc 1 455 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 456:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 456 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 457:setup.c       **** 	}
 458:setup.c       **** }
 459:setup.c       **** 
 460:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 461:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 461 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 462:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 462 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 463:setup.c       **** 	
 464:setup.c       **** 	// Set AD0 pin as input
 465:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 465 0
 734 01b8 C098      		cbi 0x18,0
 466:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 466 0
 736 01ba B898      		cbi 0x17,0
 467:setup.c       **** 	
 468:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 468 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB135:
 469:setup.c       **** 	
 470:setup.c       **** 	// Ignore first 4 bits
 471:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 472:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 472 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 473:setup.c       **** 		asm ("nop");
 746               		.loc 1 473 0 discriminator 3
 747               	/* #APP */
 748               	 ;  473 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 474:setup.c       **** 		asm ("nop");
 751               		.loc 1 474 0 discriminator 3
 752               	 ;  474 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 475:setup.c       **** 		rdPin_high; 
 755               		.loc 1 475 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 476:setup.c       **** 		asm ("nop");
 758               		.loc 1 476 0 discriminator 3
 759               	/* #APP */
 760               	 ;  476 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 477:setup.c       **** 		asm ("nop");
 763               		.loc 1 477 0 discriminator 3
 764               	 ;  477 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 471:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 471 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE135:
 776               	.LBB136:
 777               	.LBB137:
 778               	.LBB138:
 478:setup.c       **** 	}
 479:setup.c       **** 	
 480:setup.c       **** 	// Read out 64 bits
 481:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 482:setup.c       **** 		uint8_t data = 0;
 483:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 484:setup.c       **** 			rdPin_low; // CLK
 485:setup.c       **** 			asm ("nop");
 486:setup.c       **** 			asm ("nop");
 487:setup.c       **** 			rdPin_high;
 488:setup.c       **** 			
 489:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 490:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 490 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE138:
 785               	.LBE137:
 786               	.LBE136:
 468:setup.c       **** 	
 787               		.loc 1 468 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB141:
 794               	.LBB140:
 795               	.LBB139:
 484:setup.c       **** 			asm ("nop");
 796               		.loc 1 484 0
 797 01de 9598      		cbi 0x12,5
 485:setup.c       **** 			asm ("nop");
 798               		.loc 1 485 0
 799               	/* #APP */
 800               	 ;  485 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 486:setup.c       **** 			rdPin_high;
 803               		.loc 1 486 0
 804               	 ;  486 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 487:setup.c       **** 			
 807               		.loc 1 487 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 489:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 489 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 490 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE139:
 491:setup.c       **** 			}
 492:setup.c       **** 		}
 493:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 493 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE140:
 481:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 481 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE141:
 494:setup.c       **** 	}
 495:setup.c       **** 	
 496:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 496 0
 841 0206 949A      		sbi 0x12,4
 497:setup.c       **** 	
 498:setup.c       **** 	// Set AD0 pin as output
 499:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 499 0
 843 0208 C09A      		sbi 0x18,0
 500:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 500 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 501:setup.c       **** }
 502:setup.c       **** 
 503:setup.c       **** // Write 8 bytes to the EEPROM address
 504:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 504 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 505:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 505 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 504:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 504 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB142:
 876               	.LBB143:
 506:setup.c       **** 	
 507:setup.c       **** 	// Write 64 bits
 508:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 509:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 510:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 510 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 511:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 511 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 512:setup.c       **** 			}
 513:setup.c       **** 			else {
 514:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 514 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 515:setup.c       **** 			}
 516:setup.c       **** 			
 517:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 517 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 518:setup.c       **** 			asm ("nop");
 899               		.loc 1 518 0 discriminator 2
 900               	/* #APP */
 901               	 ;  518 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 519:setup.c       **** 			asm ("nop");
 904               		.loc 1 519 0 discriminator 2
 905               	 ;  519 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 520:setup.c       **** 			wrPin_high; 
 908               		.loc 1 520 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 521:setup.c       **** 			asm ("nop");
 911               		.loc 1 521 0 discriminator 2
 912               	/* #APP */
 913               	 ;  521 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 522:setup.c       **** 			asm ("nop");
 916               		.loc 1 522 0 discriminator 2
 917               	 ;  522 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE143:
 508:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 508 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE142:
 523:setup.c       **** 		}
 524:setup.c       **** 	}
 525:setup.c       **** 	
 526:setup.c       **** 	// Last bit low
 527:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 527 0
 935 0250 C098      		cbi 0x18,0
 528:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 528 0
 937 0252 9698      		cbi 0x12,6
 529:setup.c       **** 	asm ("nop");
 938               		.loc 1 529 0
 939               	/* #APP */
 940               	 ;  529 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 530:setup.c       **** 	asm ("nop");
 943               		.loc 1 530 0
 944               	 ;  530 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 531:setup.c       **** 	wrPin_high; 
 947               		.loc 1 531 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 532:setup.c       **** 	asm ("nop");
 950               		.loc 1 532 0
 951               	/* #APP */
 952               	 ;  532 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 533:setup.c       **** 	asm ("nop");
 955               		.loc 1 533 0
 956               	 ;  533 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 534:setup.c       **** 	
 535:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 535 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 536:setup.c       **** }
 537:setup.c       **** 
 538:setup.c       **** 
 539:setup.c       **** 
 540:setup.c       **** // ---------- FLASH ----------
 541:setup.c       **** 
 542:setup.c       **** // Set the address and data for the write byte cycle to the flash
 543:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 543 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 544:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 544 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 545:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 545 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 546:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 546 0
 989 026c C5BB      		out 0x15,r28
 547:setup.c       **** 	
 548:setup.c       **** 	wrPin_low;
 990               		.loc 1 548 0
 991 026e 9698      		cbi 0x12,6
 549:setup.c       **** 	cs2Pin_low;
 992               		.loc 1 549 0
 993 0270 3A98      		cbi 0x7,2
 550:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 550 0
 995               	/* #APP */
 996               	 ;  550 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 551:setup.c       **** 	wrPin_high;
 999               		.loc 1 551 0
 1000               	/* #NOAPP */
 1001 0274 969A      		sbi 0x12,6
 552:setup.c       **** 	cs2Pin_high;
 1002               		.loc 1 552 0
 1003 0276 3A9A      		sbi 0x7,2
 1004               	/* epilogue start */
 553:setup.c       **** }
 1005               		.loc 1 553 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 554:setup.c       **** 
 555:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 556:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 556 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 557:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 557 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 558:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 558 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 559:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 559 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB144:
 1049               	.LBB145:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE145:
 1060               	.LBE144:
 560:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 561:setup.c       **** 	
 562:setup.c       **** 	// Set data as inputs
 563:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 563 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 564:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 564 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 565:setup.c       **** 	
 566:setup.c       **** 	// Read and transmit the 2 bytes
 567:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 567 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 568:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 568 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 569:setup.c       **** 	
 570:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 570 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 571:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 571 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 572:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 572 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB146:
 1098               	.LBB147:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE147:
 1109               	.LBE146:
 573:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 574:setup.c       **** }
 1110               		.loc 1 574 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 575:setup.c       **** 
 576:setup.c       **** // Switch banks on the Flash
 577:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 577 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 578:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 578 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 579:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 579 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 580:setup.c       **** 	
 581:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 581 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 582:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 582 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 583:setup.c       **** }
 1157               		.loc 1 583 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 582:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 582 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 584:setup.c       **** 
 585:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 586:setup.c       **** // Takes 25ms after last command to erase sector
 587:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 587 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 588:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 588 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 589:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 589 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 590:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 590 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 591:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 591 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 592:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 592 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 593:setup.c       **** 	
 594:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 594 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB148:
 1222               	.LBB149:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE149:
 1233               	.LBE148:
 595:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 596:setup.c       **** }
 1234               		.loc 1 596 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 597:setup.c       **** 
 598:setup.c       **** // Write a single byte to the Flash address
 599:setup.c       **** // Takes 20us to program Flash
 600:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 600 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 601:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 601 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 602:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 602 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 603:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 603 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 604:setup.c       **** 	
 605:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 605 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB150:
 1292               	.LBB151:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE151:
 1301               	.LBE150:
 606:setup.c       **** 	_delay_us(20); // Wait byte program time
 607:setup.c       **** }
 1302               		.loc 1 607 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 608:setup.c       **** 
 609:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 610:setup.c       **** // Takes 20ms for write cycle
 611:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 611 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 612:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 612 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 613:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 613 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 614:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 614 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB152:
 615:setup.c       **** 	
 616:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 617:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 618:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 618 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 618 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 617:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 617 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE152:
 1400               	.LBB153:
 1401               	.LBB154:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE154:
 1412               	.LBE153:
 619:setup.c       **** 	}
 620:setup.c       **** 	_delay_ms(20); // Wait sector program time
 621:setup.c       **** }
 1413               		.loc 1 621 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 622:setup.c       **** 
 623:setup.c       **** 
 624:setup.c       **** 
 625:setup.c       **** // ---------- GB FLASH CARTS ----------
 626:setup.c       **** 
 627:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 628:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 628 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 629:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 629 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 630:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 630 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 631:setup.c       **** 	
 632:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 632 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 633:setup.c       **** 	
 634:setup.c       **** 	rdPin_low;
 1443               		.loc 1 634 0
 1444 03fe 9598      		cbi 0x12,5
 635:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 635 0
 1446               	/* #APP */
 1447               	 ;  635 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 636:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 636 0
 1451               	 ;  636 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 637:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 637 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 638:setup.c       **** 	rdPin_high;
 1458               		.loc 1 638 0
 1459 0406 959A      		sbi 0x12,5
 639:setup.c       **** 	
 640:setup.c       **** 	return data;
 641:setup.c       **** }
 1460               		.loc 1 641 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_write_bus_cycle
 1467               	gb_flash_write_bus_cycle:
 1468               	.LFB37:
 642:setup.c       **** 
 643:setup.c       **** // Set the address and data for the write byte cycle to the flash
 644:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 644 0
 1470               		.cfi_startproc
 1471               	.LVL116:
 1472 040a CF93      		push r28
 1473               	.LCFI25:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 1 */
 1479               	.L__stack_usage = 1
 1480 040c C62F      		mov r28,r22
 645:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1481               		.loc 1 645 0
 1482 040e 2FEF      		ldi r18,lo8(-1)
 1483 0410 24BB      		out 0x14,r18
 646:setup.c       **** 	set_16bit_address(address);
 1484               		.loc 1 646 0
 1485 0412 00D0      		rcall set_16bit_address
 1486               	.LVL117:
 647:setup.c       **** 	PORT_DATA7_0 = data;
 1487               		.loc 1 647 0
 1488 0414 C5BB      		out 0x15,r28
 648:setup.c       **** 	
 649:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1489               		.loc 1 649 0
 1490 0416 8091 0000 		lds r24,flashWriteWePin
 1491 041a 8134      		cpi r24,lo8(65)
 1492 041c 01F4      		brne .L70
 650:setup.c       **** 		audioPin_low; // WE low
 1493               		.loc 1 650 0
 1494 041e 3998      		cbi 0x7,1
 651:setup.c       **** 		asm volatile("nop");
 1495               		.loc 1 651 0
 1496               	/* #APP */
 1497               	 ;  651 "setup.c" 1
 1498 0420 0000      		nop
 1499               	 ;  0 "" 2
 652:setup.c       **** 		asm volatile("nop");
 1500               		.loc 1 652 0
 1501               	 ;  652 "setup.c" 1
 1502 0422 0000      		nop
 1503               	 ;  0 "" 2
 653:setup.c       **** 		asm volatile("nop");
 1504               		.loc 1 653 0
 1505               	 ;  653 "setup.c" 1
 1506 0424 0000      		nop
 1507               	 ;  0 "" 2
 654:setup.c       **** 		audioPin_high; // WE high
 1508               		.loc 1 654 0
 1509               	/* #NOAPP */
 1510 0426 399A      		sbi 0x7,1
 1511 0428 00C0      		rjmp .L71
 1512               	.L70:
 655:setup.c       **** 	}
 656:setup.c       **** 	else { // WR pin
 657:setup.c       **** 		wrPin_low; // WE low
 1513               		.loc 1 657 0
 1514 042a 9698      		cbi 0x12,6
 658:setup.c       **** 		asm volatile("nop");
 1515               		.loc 1 658 0
 1516               	/* #APP */
 1517               	 ;  658 "setup.c" 1
 1518 042c 0000      		nop
 1519               	 ;  0 "" 2
 659:setup.c       **** 		asm volatile("nop");
 1520               		.loc 1 659 0
 1521               	 ;  659 "setup.c" 1
 1522 042e 0000      		nop
 1523               	 ;  0 "" 2
 660:setup.c       **** 		asm volatile("nop");
 1524               		.loc 1 660 0
 1525               	 ;  660 "setup.c" 1
 1526 0430 0000      		nop
 1527               	 ;  0 "" 2
 661:setup.c       **** 		wrPin_high; // WE high
 1528               		.loc 1 661 0
 1529               	/* #NOAPP */
 1530 0432 969A      		sbi 0x12,6
 1531               	.L71:
 662:setup.c       **** 	}
 663:setup.c       **** 	
 664:setup.c       **** 	// Clear data outputs and set data pins as inputs
 665:setup.c       **** 	PORT_DATA7_0 = 0;
 1532               		.loc 1 665 0
 1533 0434 15BA      		out 0x15,__zero_reg__
 666:setup.c       **** 	DDR_DATA7_0 = 0;
 1534               		.loc 1 666 0
 1535 0436 14BA      		out 0x14,__zero_reg__
 1536               	/* epilogue start */
 667:setup.c       **** }
 1537               		.loc 1 667 0
 1538 0438 CF91      		pop r28
 1539               	.LVL118:
 1540 043a 0895      		ret
 1541               		.cfi_endproc
 1542               	.LFE37:
 1544               	.global	gb_flash_write_byte
 1546               	gb_flash_write_byte:
 1547               	.LFB38:
 668:setup.c       **** 
 669:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 670:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1548               		.loc 1 670 0
 1549               		.cfi_startproc
 1550               	.LVL119:
 1551 043c 1F93      		push r17
 1552               	.LCFI26:
 1553               		.cfi_def_cfa_offset 3
 1554               		.cfi_offset 17, -2
 1555 043e CF93      		push r28
 1556               	.LCFI27:
 1557               		.cfi_def_cfa_offset 4
 1558               		.cfi_offset 28, -3
 1559 0440 DF93      		push r29
 1560               	.LCFI28:
 1561               		.cfi_def_cfa_offset 5
 1562               		.cfi_offset 29, -4
 1563               	/* prologue: function */
 1564               	/* frame size = 0 */
 1565               	/* stack size = 3 */
 1566               	.L__stack_usage = 3
 1567 0442 EC01      		movw r28,r24
 1568 0444 162F      		mov r17,r22
 671:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1569               		.loc 1 671 0
 1570 0446 6091 0000 		lds r22,flashWriteCycle+2
 1571               	.LVL120:
 1572 044a 8091 0000 		lds r24,flashWriteCycle
 1573 044e 9091 0000 		lds r25,flashWriteCycle+1
 1574               	.LVL121:
 1575 0452 00D0      		rcall gb_flash_write_bus_cycle
 1576               	.LVL122:
 672:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1577               		.loc 1 672 0
 1578 0454 6091 0000 		lds r22,flashWriteCycle+6
 1579 0458 8091 0000 		lds r24,flashWriteCycle+4
 1580 045c 9091 0000 		lds r25,flashWriteCycle+4+1
 1581 0460 00D0      		rcall gb_flash_write_bus_cycle
 1582               	.LVL123:
 673:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1583               		.loc 1 673 0
 1584 0462 6091 0000 		lds r22,flashWriteCycle+10
 1585 0466 8091 0000 		lds r24,flashWriteCycle+8
 1586 046a 9091 0000 		lds r25,flashWriteCycle+8+1
 1587 046e 00D0      		rcall gb_flash_write_bus_cycle
 1588               	.LVL124:
 674:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1589               		.loc 1 674 0
 1590 0470 612F      		mov r22,r17
 1591 0472 CE01      		movw r24,r28
 1592 0474 00D0      		rcall gb_flash_write_bus_cycle
 1593               	.LVL125:
 1594               	.LBB155:
 1595               	.LBB156:
 1596               		.loc 2 276 0
 1597 0476 8AE1      		ldi r24,lo8(26)
 1598 0478 8A95      	1:	dec r24
 1599 047a 01F4      		brne 1b
 1600 047c 00C0      		rjmp .
 1601               	.LVL126:
 1602               	.LBE156:
 1603               	.LBE155:
 675:setup.c       **** 	_delay_us(10); // Wait byte program time
 676:setup.c       **** 	
 677:setup.c       **** 	// Set data pins inputs
 678:setup.c       **** 	PORT_DATA7_0 = 0;
 1604               		.loc 1 678 0
 1605 047e 15BA      		out 0x15,__zero_reg__
 679:setup.c       **** 	DDR_DATA7_0 = 0;
 1606               		.loc 1 679 0
 1607 0480 14BA      		out 0x14,__zero_reg__
 680:setup.c       **** 	
 681:setup.c       **** 	// Verify data
 682:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1608               		.loc 1 682 0
 1609 0482 CE01      		movw r24,r28
 1610 0484 00D0      		rcall gb_flash_read_byte
 1611               	.LVL127:
 1612               	.L73:
 683:setup.c       **** 	while (data != dataVerify) {
 1613               		.loc 1 683 0
 1614 0486 8117      		cp r24,r17
 1615 0488 01F0      		breq .L75
 684:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1616               		.loc 1 684 0
 1617 048a CE01      		movw r24,r28
 1618               	.LVL128:
 1619 048c 00D0      		rcall gb_flash_read_byte
 1620               	.LVL129:
 1621               	.LBB157:
 1622               	.LBB158:
 1623               		.loc 2 276 0
 1624 048e 9DE0      		ldi r25,lo8(13)
 1625 0490 9A95      	1:	dec r25
 1626 0492 01F4      		brne 1b
 1627 0494 0000      		nop
 1628 0496 00C0      		rjmp .L73
 1629               	.LVL130:
 1630               	.L75:
 1631               	/* epilogue start */
 1632               	.LBE158:
 1633               	.LBE157:
 685:setup.c       **** 		_delay_us(5);
 686:setup.c       **** 	}
 687:setup.c       **** }
 1634               		.loc 1 687 0
 1635 0498 DF91      		pop r29
 1636 049a CF91      		pop r28
 1637               	.LVL131:
 1638 049c 1F91      		pop r17
 1639               	.LVL132:
 1640 049e 0895      		ret
 1641               		.cfi_endproc
 1642               	.LFE38:
 1644               	.global	gb_flash_write_byte_special
 1646               	gb_flash_write_byte_special:
 1647               	.LFB39:
 688:setup.c       **** 
 689:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 690:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 1648               		.loc 1 690 0
 1649               		.cfi_startproc
 1650               	.LVL133:
 1651 04a0 1F93      		push r17
 1652               	.LCFI29:
 1653               		.cfi_def_cfa_offset 3
 1654               		.cfi_offset 17, -2
 1655 04a2 CF93      		push r28
 1656               	.LCFI30:
 1657               		.cfi_def_cfa_offset 4
 1658               		.cfi_offset 28, -3
 1659 04a4 DF93      		push r29
 1660               	.LCFI31:
 1661               		.cfi_def_cfa_offset 5
 1662               		.cfi_offset 29, -4
 1663               	/* prologue: function */
 1664               	/* frame size = 0 */
 1665               	/* stack size = 3 */
 1666               	.L__stack_usage = 3
 1667 04a6 EC01      		movw r28,r24
 1668 04a8 162F      		mov r17,r22
 691:setup.c       **** 	// Set bank back
 692:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 1669               		.loc 1 692 0
 1670 04aa 8091 0000 		lds r24,flashBank1CommandWrites
 1671               	.LVL134:
 1672 04ae 8130      		cpi r24,lo8(1)
 1673 04b0 01F4      		brne .L77
 693:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 1674               		.loc 1 693 0
 1675 04b2 40E0      		ldi r20,0
 1676 04b4 6091 0000 		lds r22,lastBankAccessed
 1677               	.LVL135:
 1678 04b8 80E0      		ldi r24,0
 1679 04ba 91E2      		ldi r25,lo8(33)
 1680 04bc 00D0      		rcall write_8bit_data
 1681               	.LVL136:
 1682               	.LBB159:
 1683               	.LBB160:
 1684               		.loc 2 276 0
 1685 04be 85E8      		ldi r24,lo8(-123)
 1686 04c0 8A95      	1:	dec r24
 1687 04c2 01F4      		brne 1b
 1688 04c4 0000      		nop
 1689               	.LVL137:
 1690               	.L77:
 1691               	.LBE160:
 1692               	.LBE159:
 694:setup.c       **** 		_delay_us(50);
 695:setup.c       **** 	}
 696:setup.c       **** 	
 697:setup.c       **** 	// Write
 698:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1693               		.loc 1 698 0
 1694 04c6 6091 0000 		lds r22,flashWriteCycle+2
 1695 04ca 8091 0000 		lds r24,flashWriteCycle
 1696 04ce 9091 0000 		lds r25,flashWriteCycle+1
 1697 04d2 00D0      		rcall gb_flash_write_bus_cycle
 1698               	.LVL138:
 699:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1699               		.loc 1 699 0
 1700 04d4 6091 0000 		lds r22,flashWriteCycle+6
 1701 04d8 8091 0000 		lds r24,flashWriteCycle+4
 1702 04dc 9091 0000 		lds r25,flashWriteCycle+4+1
 1703 04e0 00D0      		rcall gb_flash_write_bus_cycle
 1704               	.LVL139:
 700:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1705               		.loc 1 700 0
 1706 04e2 6091 0000 		lds r22,flashWriteCycle+10
 1707 04e6 8091 0000 		lds r24,flashWriteCycle+8
 1708 04ea 9091 0000 		lds r25,flashWriteCycle+8+1
 1709 04ee 00D0      		rcall gb_flash_write_bus_cycle
 1710               	.LVL140:
 701:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1711               		.loc 1 701 0
 1712 04f0 612F      		mov r22,r17
 1713 04f2 CE01      		movw r24,r28
 1714 04f4 00D0      		rcall gb_flash_write_bus_cycle
 1715               	.LVL141:
 1716               	.LBB161:
 1717               	.LBB162:
 1718               		.loc 2 276 0
 1719 04f6 83EF      		ldi r24,lo8(499)
 1720 04f8 91E0      		ldi r25,hi8(499)
 1721 04fa 0197      	1:	sbiw r24,1
 1722 04fc 01F4      		brne 1b
 1723 04fe 00C0      		rjmp .
 1724 0500 0000      		nop
 1725               	.LVL142:
 1726               	.LBE162:
 1727               	.LBE161:
 702:setup.c       **** 	_delay_us(250); // Wait byte program time
 703:setup.c       **** 	
 704:setup.c       **** 	// Set data pins inputs
 705:setup.c       **** 	PORT_DATA7_0 = 0;
 1728               		.loc 1 705 0
 1729 0502 15BA      		out 0x15,__zero_reg__
 706:setup.c       **** 	DDR_DATA7_0 = 0;
 1730               		.loc 1 706 0
 1731 0504 14BA      		out 0x14,__zero_reg__
 707:setup.c       **** 	
 708:setup.c       **** 	// Pulse reset
 709:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 1732               		.loc 1 709 0
 1733 0506 3A98      		cbi 0x7,2
 1734               	.LVL143:
 1735               	.LBB163:
 1736               	.LBB164:
 1737               		.loc 2 276 0
 1738 0508 95E8      		ldi r25,lo8(-123)
 1739 050a 9A95      	1:	dec r25
 1740 050c 01F4      		brne 1b
 1741 050e 0000      		nop
 1742               	.LVL144:
 1743               	.LBE164:
 1744               	.LBE163:
 710:setup.c       **** 	_delay_us(50);
 711:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 1745               		.loc 1 711 0
 1746 0510 3A9A      		sbi 0x7,2
 1747               	.LVL145:
 1748               	.LBB165:
 1749               	.LBB166:
 1750               		.loc 2 276 0
 1751 0512 85E8      		ldi r24,lo8(-123)
 1752 0514 8A95      	1:	dec r24
 1753 0516 01F4      		brne 1b
 1754 0518 0000      		nop
 1755               	.LVL146:
 1756               	/* epilogue start */
 1757               	.LBE166:
 1758               	.LBE165:
 712:setup.c       **** 	_delay_us(50);
 713:setup.c       **** }
 1759               		.loc 1 713 0
 1760 051a DF91      		pop r29
 1761 051c CF91      		pop r28
 1762               	.LVL147:
 1763 051e 1F91      		pop r17
 1764               	.LVL148:
 1765 0520 0895      		ret
 1766               		.cfi_endproc
 1767               	.LFE39:
 1769               	.global	gb_flash_write_byte_bank1_commands
 1771               	gb_flash_write_byte_bank1_commands:
 1772               	.LFB40:
 714:setup.c       **** 
 715:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 716:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 717:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1773               		.loc 1 717 0
 1774               		.cfi_startproc
 1775               	.LVL149:
 1776 0522 FF92      		push r15
 1777               	.LCFI32:
 1778               		.cfi_def_cfa_offset 3
 1779               		.cfi_offset 15, -2
 1780 0524 0F93      		push r16
 1781               	.LCFI33:
 1782               		.cfi_def_cfa_offset 4
 1783               		.cfi_offset 16, -3
 1784 0526 1F93      		push r17
 1785               	.LCFI34:
 1786               		.cfi_def_cfa_offset 5
 1787               		.cfi_offset 17, -4
 1788 0528 CF93      		push r28
 1789               	.LCFI35:
 1790               		.cfi_def_cfa_offset 6
 1791               		.cfi_offset 28, -5
 1792 052a DF93      		push r29
 1793               	.LCFI36:
 1794               		.cfi_def_cfa_offset 7
 1795               		.cfi_offset 29, -6
 1796               	/* prologue: function */
 1797               	/* frame size = 0 */
 1798               	/* stack size = 5 */
 1799               	.L__stack_usage = 5
 1800 052c EC01      		movw r28,r24
 1801 052e 162F      		mov r17,r22
 718:setup.c       **** 	// Set bank 1
 719:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1802               		.loc 1 719 0
 1803 0530 FF24      		clr r15
 1804 0532 FA94      		dec r15
 1805 0534 F4BA      		out 0x14,r15
 1806               	.LVL150:
 1807               	.LBB167:
 1808               	.LBB168:
 249:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1809               		.loc 1 249 0
 1810 0536 01E2      		ldi r16,lo8(33)
 1811 0538 0BBB      		out 0x1b,r16
 250:setup.c       **** }
 1812               		.loc 1 250 0
 1813 053a 18BA      		out 0x18,__zero_reg__
 1814               	.LVL151:
 1815               	.LBE168:
 1816               	.LBE167:
 720:setup.c       **** 	set_16bit_address(0x2100);
 721:setup.c       **** 	PORT_DATA7_0 = 1;
 1817               		.loc 1 721 0
 1818 053c 81E0      		ldi r24,lo8(1)
 1819               	.LVL152:
 1820 053e 85BB      		out 0x15,r24
 722:setup.c       **** 	wrPin_low; // Pulse WR
 1821               		.loc 1 722 0
 1822 0540 9698      		cbi 0x12,6
 723:setup.c       **** 	asm volatile("nop");
 1823               		.loc 1 723 0
 1824               	/* #APP */
 1825               	 ;  723 "setup.c" 1
 1826 0542 0000      		nop
 1827               	 ;  0 "" 2
 724:setup.c       **** 	wrPin_high;
 1828               		.loc 1 724 0
 1829               	/* #NOAPP */
 1830 0544 969A      		sbi 0x12,6
 725:setup.c       **** 	
 726:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1831               		.loc 1 726 0
 1832 0546 6091 0000 		lds r22,flashWriteCycle+2
 1833               	.LVL153:
 1834 054a 8091 0000 		lds r24,flashWriteCycle
 1835 054e 9091 0000 		lds r25,flashWriteCycle+1
 1836 0552 00D0      		rcall gb_flash_write_bus_cycle
 1837               	.LVL154:
 727:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1838               		.loc 1 727 0
 1839 0554 6091 0000 		lds r22,flashWriteCycle+6
 1840 0558 8091 0000 		lds r24,flashWriteCycle+4
 1841 055c 9091 0000 		lds r25,flashWriteCycle+4+1
 1842 0560 00D0      		rcall gb_flash_write_bus_cycle
 1843               	.LVL155:
 728:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1844               		.loc 1 728 0
 1845 0562 6091 0000 		lds r22,flashWriteCycle+10
 1846 0566 8091 0000 		lds r24,flashWriteCycle+8
 1847 056a 9091 0000 		lds r25,flashWriteCycle+8+1
 1848 056e 00D0      		rcall gb_flash_write_bus_cycle
 1849               	.LVL156:
 729:setup.c       **** 	
 730:setup.c       **** 	
 731:setup.c       **** 	// Set bank back
 732:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1850               		.loc 1 732 0
 1851 0570 F4BA      		out 0x14,r15
 1852               	.LVL157:
 1853               	.LBB169:
 1854               	.LBB170:
 249:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1855               		.loc 1 249 0
 1856 0572 0BBB      		out 0x1b,r16
 250:setup.c       **** }
 1857               		.loc 1 250 0
 1858 0574 18BA      		out 0x18,__zero_reg__
 1859               	.LVL158:
 1860               	.LBE170:
 1861               	.LBE169:
 733:setup.c       **** 	set_16bit_address(0x2100);
 734:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1862               		.loc 1 734 0
 1863 0576 8091 0000 		lds r24,lastBankAccessed
 1864 057a 85BB      		out 0x15,r24
 735:setup.c       **** 	wrPin_low; // Pulse WR
 1865               		.loc 1 735 0
 1866 057c 9698      		cbi 0x12,6
 736:setup.c       **** 	asm volatile("nop");
 1867               		.loc 1 736 0
 1868               	/* #APP */
 1869               	 ;  736 "setup.c" 1
 1870 057e 0000      		nop
 1871               	 ;  0 "" 2
 737:setup.c       **** 	wrPin_high;
 1872               		.loc 1 737 0
 1873               	/* #NOAPP */
 1874 0580 969A      		sbi 0x12,6
 738:setup.c       **** 	
 739:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1875               		.loc 1 739 0
 1876 0582 612F      		mov r22,r17
 1877 0584 CE01      		movw r24,r28
 1878 0586 00D0      		rcall gb_flash_write_bus_cycle
 1879               	.LVL159:
 1880               	.LBB171:
 1881               	.LBB172:
 1882               		.loc 2 276 0
 1883 0588 8AE1      		ldi r24,lo8(26)
 1884 058a 8A95      	1:	dec r24
 1885 058c 01F4      		brne 1b
 1886 058e 00C0      		rjmp .
 1887               	.LVL160:
 1888               	.LBE172:
 1889               	.LBE171:
 740:setup.c       **** 	_delay_us(10); // Wait byte program time
 741:setup.c       **** 	
 742:setup.c       **** 	// Set data pins inputs
 743:setup.c       **** 	PORT_DATA7_0 = 0;
 1890               		.loc 1 743 0
 1891 0590 15BA      		out 0x15,__zero_reg__
 744:setup.c       **** 	DDR_DATA7_0 = 0;
 1892               		.loc 1 744 0
 1893 0592 14BA      		out 0x14,__zero_reg__
 745:setup.c       **** 	
 746:setup.c       **** 	// Verify data
 747:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1894               		.loc 1 747 0
 1895 0594 CE01      		movw r24,r28
 1896 0596 00D0      		rcall gb_flash_read_byte
 1897               	.LVL161:
 1898               	.L79:
 748:setup.c       **** 	while (data != dataVerify) {
 1899               		.loc 1 748 0
 1900 0598 8117      		cp r24,r17
 1901 059a 01F0      		breq .L81
 749:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1902               		.loc 1 749 0
 1903 059c CE01      		movw r24,r28
 1904               	.LVL162:
 1905 059e 00D0      		rcall gb_flash_read_byte
 1906               	.LVL163:
 1907               	.LBB173:
 1908               	.LBB174:
 1909               		.loc 2 276 0
 1910 05a0 9DE0      		ldi r25,lo8(13)
 1911 05a2 9A95      	1:	dec r25
 1912 05a4 01F4      		brne 1b
 1913 05a6 0000      		nop
 1914 05a8 00C0      		rjmp .L79
 1915               	.LVL164:
 1916               	.L81:
 1917               	/* epilogue start */
 1918               	.LBE174:
 1919               	.LBE173:
 750:setup.c       **** 		_delay_us(5);
 751:setup.c       **** 	}
 752:setup.c       **** }
 1920               		.loc 1 752 0
 1921 05aa DF91      		pop r29
 1922 05ac CF91      		pop r28
 1923               	.LVL165:
 1924 05ae 1F91      		pop r17
 1925               	.LVL166:
 1926 05b0 0F91      		pop r16
 1927 05b2 FF90      		pop r15
 1928 05b4 0895      		ret
 1929               		.cfi_endproc
 1930               	.LFE40:
 1932               	.global	gba_flash_write_bus_cycle
 1934               	gba_flash_write_bus_cycle:
 1935               	.LFB41:
 753:setup.c       **** 
 754:setup.c       **** 
 755:setup.c       **** 
 756:setup.c       **** // ---------- GBA FLASH CARTS ----------
 757:setup.c       **** 
 758:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 759:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1936               		.loc 1 759 0
 1937               		.cfi_startproc
 1938               	.LVL167:
 1939 05b6 0F93      		push r16
 1940               	.LCFI37:
 1941               		.cfi_def_cfa_offset 3
 1942               		.cfi_offset 16, -2
 1943 05b8 1F93      		push r17
 1944               	.LCFI38:
 1945               		.cfi_def_cfa_offset 4
 1946               		.cfi_offset 17, -3
 1947               	/* prologue: function */
 1948               	/* frame size = 0 */
 1949               	/* stack size = 2 */
 1950               	.L__stack_usage = 2
 760:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 1951               		.loc 1 760 0
 1952 05ba 8C01      		movw r16,r24
 1953 05bc 2227      		clr r18
 1954 05be 3327      		clr r19
 1955 05c0 05BB      		out 0x15,r16
 761:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 1956               		.loc 1 761 0
 1957 05c2 072F      		mov r16,r23
 1958 05c4 182F      		mov r17,r24
 1959 05c6 292F      		mov r18,r25
 1960 05c8 3327      		clr r19
 1961 05ca 0BBB      		out 0x1b,r16
 762:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 1962               		.loc 1 762 0
 1963 05cc 68BB      		out 0x18,r22
 763:setup.c       **** 	
 764:setup.c       **** 	cs_mreqPin_low;
 1964               		.loc 1 764 0
 1965 05ce 9498      		cbi 0x12,4
 765:setup.c       **** 	
 766:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1966               		.loc 1 766 0
 1967 05d0 5BBB      		out 0x1b,r21
 767:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1968               		.loc 1 767 0
 1969 05d2 48BB      		out 0x18,r20
 768:setup.c       **** 	
 769:setup.c       **** 	wrPin_low;
 1970               		.loc 1 769 0
 1971 05d4 9698      		cbi 0x12,6
 770:setup.c       **** 	asm volatile("nop");
 1972               		.loc 1 770 0
 1973               	/* #APP */
 1974               	 ;  770 "setup.c" 1
 1975 05d6 0000      		nop
 1976               	 ;  0 "" 2
 771:setup.c       **** 	asm volatile("nop");
 1977               		.loc 1 771 0
 1978               	 ;  771 "setup.c" 1
 1979 05d8 0000      		nop
 1980               	 ;  0 "" 2
 772:setup.c       **** 	asm volatile("nop");
 1981               		.loc 1 772 0
 1982               	 ;  772 "setup.c" 1
 1983 05da 0000      		nop
 1984               	 ;  0 "" 2
 773:setup.c       **** 	wrPin_high;
 1985               		.loc 1 773 0
 1986               	/* #NOAPP */
 1987 05dc 969A      		sbi 0x12,6
 774:setup.c       **** 	cs_mreqPin_high;
 1988               		.loc 1 774 0
 1989 05de 949A      		sbi 0x12,4
 1990               	/* epilogue start */
 775:setup.c       **** }
 1991               		.loc 1 775 0
 1992 05e0 1F91      		pop r17
 1993 05e2 0F91      		pop r16
 1994 05e4 0895      		ret
 1995               		.cfi_endproc
 1996               	.LFE41:
 1998               	.global	gba_flash_write_cycle_start_swapped
 2000               	gba_flash_write_cycle_start_swapped:
 2001               	.LFB42:
 776:setup.c       **** 
 777:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 778:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 2002               		.loc 1 778 0
 2003               		.cfi_startproc
 2004               	/* prologue: function */
 2005               	/* frame size = 0 */
 2006               	/* stack size = 0 */
 2007               	.L__stack_usage = 0
 779:setup.c       **** 	// Set outputs
 780:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2008               		.loc 1 780 0
 2009 05e6 8FEF      		ldi r24,lo8(-1)
 2010 05e8 84BB      		out 0x14,r24
 781:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2011               		.loc 1 781 0
 2012 05ea 8ABB      		out 0x1a,r24
 782:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2013               		.loc 1 782 0
 2014 05ec 87BB      		out 0x17,r24
 783:setup.c       **** 	
 784:setup.c       **** 	// 0x555, 0xA9
 785:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2015               		.loc 1 785 0
 2016 05ee 15BA      		out 0x15,__zero_reg__
 786:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2017               		.loc 1 786 0
 2018 05f0 95E0      		ldi r25,lo8(5)
 2019 05f2 9BBB      		out 0x1b,r25
 787:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2020               		.loc 1 787 0
 2021 05f4 85E5      		ldi r24,lo8(85)
 2022 05f6 88BB      		out 0x18,r24
 788:setup.c       **** 	cs_mreqPin_low;
 2023               		.loc 1 788 0
 2024 05f8 9498      		cbi 0x12,4
 789:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2025               		.loc 1 789 0
 2026 05fa 1BBA      		out 0x1b,__zero_reg__
 790:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 2027               		.loc 1 790 0
 2028 05fc 29EA      		ldi r18,lo8(-87)
 2029 05fe 28BB      		out 0x18,r18
 791:setup.c       **** 	wrPin_low;
 2030               		.loc 1 791 0
 2031 0600 9698      		cbi 0x12,6
 792:setup.c       **** 	asm volatile("nop");
 2032               		.loc 1 792 0
 2033               	/* #APP */
 2034               	 ;  792 "setup.c" 1
 2035 0602 0000      		nop
 2036               	 ;  0 "" 2
 793:setup.c       **** 	asm volatile("nop");
 2037               		.loc 1 793 0
 2038               	 ;  793 "setup.c" 1
 2039 0604 0000      		nop
 2040               	 ;  0 "" 2
 794:setup.c       **** 	asm volatile("nop");
 2041               		.loc 1 794 0
 2042               	 ;  794 "setup.c" 1
 2043 0606 0000      		nop
 2044               	 ;  0 "" 2
 795:setup.c       **** 	wrPin_high;
 2045               		.loc 1 795 0
 2046               	/* #NOAPP */
 2047 0608 969A      		sbi 0x12,6
 796:setup.c       **** 	cs_mreqPin_high;
 2048               		.loc 1 796 0
 2049 060a 949A      		sbi 0x12,4
 797:setup.c       **** 	
 798:setup.c       **** 	// 0x2AA, 0x56
 799:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2050               		.loc 1 799 0
 2051 060c 15BA      		out 0x15,__zero_reg__
 800:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2052               		.loc 1 800 0
 2053 060e 22E0      		ldi r18,lo8(2)
 2054 0610 2BBB      		out 0x1b,r18
 801:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2055               		.loc 1 801 0
 2056 0612 2AEA      		ldi r18,lo8(-86)
 2057 0614 28BB      		out 0x18,r18
 802:setup.c       **** 	cs_mreqPin_low;
 2058               		.loc 1 802 0
 2059 0616 9498      		cbi 0x12,4
 803:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2060               		.loc 1 803 0
 2061 0618 1BBA      		out 0x1b,__zero_reg__
 804:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 2062               		.loc 1 804 0
 2063 061a 26E5      		ldi r18,lo8(86)
 2064 061c 28BB      		out 0x18,r18
 805:setup.c       **** 	wrPin_low;
 2065               		.loc 1 805 0
 2066 061e 9698      		cbi 0x12,6
 806:setup.c       **** 	asm volatile("nop");
 2067               		.loc 1 806 0
 2068               	/* #APP */
 2069               	 ;  806 "setup.c" 1
 2070 0620 0000      		nop
 2071               	 ;  0 "" 2
 807:setup.c       **** 	asm volatile("nop");
 2072               		.loc 1 807 0
 2073               	 ;  807 "setup.c" 1
 2074 0622 0000      		nop
 2075               	 ;  0 "" 2
 808:setup.c       **** 	asm volatile("nop");
 2076               		.loc 1 808 0
 2077               	 ;  808 "setup.c" 1
 2078 0624 0000      		nop
 2079               	 ;  0 "" 2
 809:setup.c       **** 	wrPin_high;
 2080               		.loc 1 809 0
 2081               	/* #NOAPP */
 2082 0626 969A      		sbi 0x12,6
 810:setup.c       **** 	cs_mreqPin_high;
 2083               		.loc 1 810 0
 2084 0628 949A      		sbi 0x12,4
 811:setup.c       **** 	
 812:setup.c       **** 	// 0x555, 0xA0;
 813:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2085               		.loc 1 813 0
 2086 062a 15BA      		out 0x15,__zero_reg__
 814:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2087               		.loc 1 814 0
 2088 062c 9BBB      		out 0x1b,r25
 815:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2089               		.loc 1 815 0
 2090 062e 88BB      		out 0x18,r24
 816:setup.c       **** 	cs_mreqPin_low;
 2091               		.loc 1 816 0
 2092 0630 9498      		cbi 0x12,4
 817:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2093               		.loc 1 817 0
 2094 0632 1BBA      		out 0x1b,__zero_reg__
 818:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2095               		.loc 1 818 0
 2096 0634 80EA      		ldi r24,lo8(-96)
 2097 0636 88BB      		out 0x18,r24
 819:setup.c       **** 	wrPin_low;
 2098               		.loc 1 819 0
 2099 0638 9698      		cbi 0x12,6
 820:setup.c       **** 	asm volatile("nop");
 2100               		.loc 1 820 0
 2101               	/* #APP */
 2102               	 ;  820 "setup.c" 1
 2103 063a 0000      		nop
 2104               	 ;  0 "" 2
 821:setup.c       **** 	asm volatile("nop");
 2105               		.loc 1 821 0
 2106               	 ;  821 "setup.c" 1
 2107 063c 0000      		nop
 2108               	 ;  0 "" 2
 822:setup.c       **** 	asm volatile("nop");
 2109               		.loc 1 822 0
 2110               	 ;  822 "setup.c" 1
 2111 063e 0000      		nop
 2112               	 ;  0 "" 2
 823:setup.c       **** 	wrPin_high;
 2113               		.loc 1 823 0
 2114               	/* #NOAPP */
 2115 0640 969A      		sbi 0x12,6
 824:setup.c       **** 	cs_mreqPin_high;
 2116               		.loc 1 824 0
 2117 0642 949A      		sbi 0x12,4
 2118 0644 0895      		ret
 2119               		.cfi_endproc
 2120               	.LFE42:
 2122               	.global	gba_flash_write_cycle_start
 2124               	gba_flash_write_cycle_start:
 2125               	.LFB43:
 825:setup.c       **** }
 826:setup.c       **** 
 827:setup.c       **** 
 828:setup.c       **** // Send the first 3 write cycles to the flash
 829:setup.c       **** void gba_flash_write_cycle_start(void) {
 2126               		.loc 1 829 0
 2127               		.cfi_startproc
 2128               	/* prologue: function */
 2129               	/* frame size = 0 */
 2130               	/* stack size = 0 */
 2131               	.L__stack_usage = 0
 830:setup.c       **** 	// Set outputs
 831:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2132               		.loc 1 831 0
 2133 0646 8FEF      		ldi r24,lo8(-1)
 2134 0648 84BB      		out 0x14,r24
 832:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2135               		.loc 1 832 0
 2136 064a 8ABB      		out 0x1a,r24
 833:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2137               		.loc 1 833 0
 2138 064c 87BB      		out 0x17,r24
 834:setup.c       **** 	
 835:setup.c       **** 	// 0x555, 0xAA
 836:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2139               		.loc 1 836 0
 2140 064e 15BA      		out 0x15,__zero_reg__
 837:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2141               		.loc 1 837 0
 2142 0650 95E0      		ldi r25,lo8(5)
 2143 0652 9BBB      		out 0x1b,r25
 838:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2144               		.loc 1 838 0
 2145 0654 85E5      		ldi r24,lo8(85)
 2146 0656 88BB      		out 0x18,r24
 839:setup.c       **** 	cs_mreqPin_low;
 2147               		.loc 1 839 0
 2148 0658 9498      		cbi 0x12,4
 840:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2149               		.loc 1 840 0
 2150 065a 1BBA      		out 0x1b,__zero_reg__
 841:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2151               		.loc 1 841 0
 2152 065c 2AEA      		ldi r18,lo8(-86)
 2153 065e 28BB      		out 0x18,r18
 842:setup.c       **** 	wrPin_low;
 2154               		.loc 1 842 0
 2155 0660 9698      		cbi 0x12,6
 843:setup.c       **** 	asm volatile("nop");
 2156               		.loc 1 843 0
 2157               	/* #APP */
 2158               	 ;  843 "setup.c" 1
 2159 0662 0000      		nop
 2160               	 ;  0 "" 2
 844:setup.c       **** 	asm volatile("nop");
 2161               		.loc 1 844 0
 2162               	 ;  844 "setup.c" 1
 2163 0664 0000      		nop
 2164               	 ;  0 "" 2
 845:setup.c       **** 	asm volatile("nop");
 2165               		.loc 1 845 0
 2166               	 ;  845 "setup.c" 1
 2167 0666 0000      		nop
 2168               	 ;  0 "" 2
 846:setup.c       **** 	wrPin_high;
 2169               		.loc 1 846 0
 2170               	/* #NOAPP */
 2171 0668 969A      		sbi 0x12,6
 847:setup.c       **** 	cs_mreqPin_high;
 2172               		.loc 1 847 0
 2173 066a 949A      		sbi 0x12,4
 848:setup.c       **** 	
 849:setup.c       **** 	// 0x2AA, 0x55
 850:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2174               		.loc 1 850 0
 2175 066c 15BA      		out 0x15,__zero_reg__
 851:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2176               		.loc 1 851 0
 2177 066e 32E0      		ldi r19,lo8(2)
 2178 0670 3BBB      		out 0x1b,r19
 852:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2179               		.loc 1 852 0
 2180 0672 28BB      		out 0x18,r18
 853:setup.c       **** 	cs_mreqPin_low;
 2181               		.loc 1 853 0
 2182 0674 9498      		cbi 0x12,4
 854:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2183               		.loc 1 854 0
 2184 0676 1BBA      		out 0x1b,__zero_reg__
 855:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2185               		.loc 1 855 0
 2186 0678 88BB      		out 0x18,r24
 856:setup.c       **** 	wrPin_low;
 2187               		.loc 1 856 0
 2188 067a 9698      		cbi 0x12,6
 857:setup.c       **** 	asm volatile("nop");
 2189               		.loc 1 857 0
 2190               	/* #APP */
 2191               	 ;  857 "setup.c" 1
 2192 067c 0000      		nop
 2193               	 ;  0 "" 2
 858:setup.c       **** 	asm volatile("nop");
 2194               		.loc 1 858 0
 2195               	 ;  858 "setup.c" 1
 2196 067e 0000      		nop
 2197               	 ;  0 "" 2
 859:setup.c       **** 	asm volatile("nop");
 2198               		.loc 1 859 0
 2199               	 ;  859 "setup.c" 1
 2200 0680 0000      		nop
 2201               	 ;  0 "" 2
 860:setup.c       **** 	wrPin_high;
 2202               		.loc 1 860 0
 2203               	/* #NOAPP */
 2204 0682 969A      		sbi 0x12,6
 861:setup.c       **** 	cs_mreqPin_high;
 2205               		.loc 1 861 0
 2206 0684 949A      		sbi 0x12,4
 862:setup.c       **** 	
 863:setup.c       **** 	// 0x555, 0xA0;
 864:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2207               		.loc 1 864 0
 2208 0686 15BA      		out 0x15,__zero_reg__
 865:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2209               		.loc 1 865 0
 2210 0688 9BBB      		out 0x1b,r25
 866:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2211               		.loc 1 866 0
 2212 068a 88BB      		out 0x18,r24
 867:setup.c       **** 	cs_mreqPin_low;
 2213               		.loc 1 867 0
 2214 068c 9498      		cbi 0x12,4
 868:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2215               		.loc 1 868 0
 2216 068e 1BBA      		out 0x1b,__zero_reg__
 869:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2217               		.loc 1 869 0
 2218 0690 80EA      		ldi r24,lo8(-96)
 2219 0692 88BB      		out 0x18,r24
 870:setup.c       **** 	wrPin_low;
 2220               		.loc 1 870 0
 2221 0694 9698      		cbi 0x12,6
 871:setup.c       **** 	asm volatile("nop");
 2222               		.loc 1 871 0
 2223               	/* #APP */
 2224               	 ;  871 "setup.c" 1
 2225 0696 0000      		nop
 2226               	 ;  0 "" 2
 872:setup.c       **** 	asm volatile("nop");
 2227               		.loc 1 872 0
 2228               	 ;  872 "setup.c" 1
 2229 0698 0000      		nop
 2230               	 ;  0 "" 2
 873:setup.c       **** 	asm volatile("nop");
 2231               		.loc 1 873 0
 2232               	 ;  873 "setup.c" 1
 2233 069a 0000      		nop
 2234               	 ;  0 "" 2
 874:setup.c       **** 	wrPin_high;
 2235               		.loc 1 874 0
 2236               	/* #NOAPP */
 2237 069c 969A      		sbi 0x12,6
 875:setup.c       **** 	cs_mreqPin_high;
 2238               		.loc 1 875 0
 2239 069e 949A      		sbi 0x12,4
 2240 06a0 0895      		ret
 2241               		.cfi_endproc
 2242               	.LFE43:
 2244               	.global	gba_flash_write_byte
 2246               	gba_flash_write_byte:
 2247               	.LFB44:
 876:setup.c       **** }	
 877:setup.c       **** 
 878:setup.c       **** 
 879:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 880:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 881:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2248               		.loc 1 881 0
 2249               		.cfi_startproc
 2250               	.LVL168:
 2251 06a2 CF92      		push r12
 2252               	.LCFI39:
 2253               		.cfi_def_cfa_offset 3
 2254               		.cfi_offset 12, -2
 2255 06a4 DF92      		push r13
 2256               	.LCFI40:
 2257               		.cfi_def_cfa_offset 4
 2258               		.cfi_offset 13, -3
 2259 06a6 EF92      		push r14
 2260               	.LCFI41:
 2261               		.cfi_def_cfa_offset 5
 2262               		.cfi_offset 14, -4
 2263 06a8 FF92      		push r15
 2264               	.LCFI42:
 2265               		.cfi_def_cfa_offset 6
 2266               		.cfi_offset 15, -5
 2267 06aa CF93      		push r28
 2268               	.LCFI43:
 2269               		.cfi_def_cfa_offset 7
 2270               		.cfi_offset 28, -6
 2271 06ac DF93      		push r29
 2272               	.LCFI44:
 2273               		.cfi_def_cfa_offset 8
 2274               		.cfi_offset 29, -7
 2275               	/* prologue: function */
 2276               	/* frame size = 0 */
 2277               	/* stack size = 6 */
 2278               	.L__stack_usage = 6
 2279 06ae 6B01      		movw r12,r22
 2280 06b0 7C01      		movw r14,r24
 2281 06b2 EA01      		movw r28,r20
 882:setup.c       **** 	if (isD0D1Swapped == 0) {
 2282               		.loc 1 882 0
 2283 06b4 2111      		cpse r18,__zero_reg__
 2284 06b6 00C0      		rjmp .L86
 883:setup.c       **** 		gba_flash_write_cycle_start();
 2285               		.loc 1 883 0
 2286 06b8 00D0      		rcall gba_flash_write_cycle_start
 2287               	.LVL169:
 2288 06ba 00C0      		rjmp .L87
 2289               	.LVL170:
 2290               	.L86:
 884:setup.c       **** 	}
 885:setup.c       **** 	else {
 886:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2291               		.loc 1 886 0
 2292 06bc 00D0      		rcall gba_flash_write_cycle_start_swapped
 2293               	.LVL171:
 2294               	.L87:
 887:setup.c       **** 	}
 888:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2295               		.loc 1 888 0
 2296 06be AE01      		movw r20,r28
 2297 06c0 C701      		movw r24,r14
 2298 06c2 B601      		movw r22,r12
 2299 06c4 00D0      		rcall gba_flash_write_bus_cycle
 2300               	.LVL172:
 2301               	.LBB175:
 2302               	.LBB176:
 2303               		.loc 2 276 0
 2304 06c6 25E0      		ldi r18,lo8(5)
 2305 06c8 2A95      	1:	dec r18
 2306 06ca 01F4      		brne 1b
 2307 06cc 0000      		nop
 2308               	.LVL173:
 2309               	.LBE176:
 2310               	.LBE175:
 889:setup.c       **** 	_delay_us(2); // Wait byte program time
 890:setup.c       **** 	
 891:setup.c       **** 	// Verify data
 892:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2311               		.loc 1 892 0
 2312 06ce C701      		movw r24,r14
 2313 06d0 B601      		movw r22,r12
 2314 06d2 00D0      		rcall gba_read_16bit_data
 2315               	.LVL174:
 2316               	.L88:
 893:setup.c       **** 	while (data != dataVerify) {
 2317               		.loc 1 893 0
 2318 06d4 8C17      		cp r24,r28
 2319 06d6 9D07      		cpc r25,r29
 2320 06d8 01F0      		breq .L90
 894:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2321               		.loc 1 894 0
 2322 06da C701      		movw r24,r14
 2323 06dc B601      		movw r22,r12
 2324 06de 00D0      		rcall gba_read_16bit_data
 2325               	.LVL175:
 2326               	.LBB177:
 2327               	.LBB178:
 2328               		.loc 2 276 0
 2329 06e0 25E0      		ldi r18,lo8(5)
 2330 06e2 2A95      	1:	dec r18
 2331 06e4 01F4      		brne 1b
 2332 06e6 0000      		nop
 2333 06e8 00C0      		rjmp .L88
 2334               	.LVL176:
 2335               	.L90:
 2336               	/* epilogue start */
 2337               	.LBE178:
 2338               	.LBE177:
 895:setup.c       **** 		_delay_us(2);
 896:setup.c       **** 	}
 897:setup.c       **** }
 2339               		.loc 1 897 0
 2340 06ea DF91      		pop r29
 2341 06ec CF91      		pop r28
 2342               	.LVL177:
 2343 06ee FF90      		pop r15
 2344 06f0 EF90      		pop r14
 2345 06f2 DF90      		pop r13
 2346 06f4 CF90      		pop r12
 2347               	.LVL178:
 2348 06f6 0895      		ret
 2349               		.cfi_endproc
 2350               	.LFE44:
 2352               	.global	setup
 2354               	setup:
 2355               	.LFB45:
 898:setup.c       **** 
 899:setup.c       **** 
 900:setup.c       **** // Setup
 901:setup.c       **** void setup(void) {
 2356               		.loc 1 901 0
 2357               		.cfi_startproc
 2358               	/* prologue: function */
 2359               	/* frame size = 0 */
 2360               	/* stack size = 0 */
 2361               	.L__stack_usage = 0
 902:setup.c       **** 	// Turn off watchdog
 903:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2362               		.loc 1 903 0
 2363 06f8 84B7      		in r24,0x34
 2364 06fa 877F      		andi r24,lo8(-9)
 2365 06fc 84BF      		out 0x34,r24
 904:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2366               		.loc 1 904 0
 2367 06fe 88E1      		ldi r24,lo8(24)
 2368 0700 81BD      		out 0x21,r24
 905:setup.c       **** 	WDTCR = 0;
 2369               		.loc 1 905 0
 2370 0702 11BC      		out 0x21,__zero_reg__
 906:setup.c       **** 	
 907:setup.c       **** 	// Reset common lines
 908:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2371               		.loc 1 908 0
 2372 0704 00D0      		rcall rd_wr_csmreq_cs2_reset
 2373               	.LVL179:
 909:setup.c       **** 	
 910:setup.c       **** 	// Set outputs
 911:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V) | (1<<VOLTA
 2374               		.loc 1 911 0
 2375 0706 81B3      		in r24,0x11
 2376 0708 8C6F      		ori r24,lo8(-4)
 2377 070a 81BB      		out 0x11,r24
 912:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2378               		.loc 1 912 0
 2379 070c 86B1      		in r24,0x6
 2380 070e 8560      		ori r24,lo8(5)
 2381 0710 86B9      		out 0x6,r24
 913:setup.c       **** 	
 914:setup.c       **** 	// Set all pins as inputs
 915:setup.c       **** 	PORT_DATA7_0 = 0;
 2382               		.loc 1 915 0
 2383 0712 15BA      		out 0x15,__zero_reg__
 916:setup.c       **** 	DDR_DATA7_0 = 0;
 2384               		.loc 1 916 0
 2385 0714 14BA      		out 0x14,__zero_reg__
 917:setup.c       **** 	PORT_ADDR7_0 = 0;
 2386               		.loc 1 917 0
 2387 0716 18BA      		out 0x18,__zero_reg__
 918:setup.c       **** 	DDR_ADDR7_0 = 0;
 2388               		.loc 1 918 0
 2389 0718 17BA      		out 0x17,__zero_reg__
 919:setup.c       **** 	PORT_ADDR15_8 = 0;
 2390               		.loc 1 919 0
 2391 071a 1BBA      		out 0x1b,__zero_reg__
 920:setup.c       **** 	DDR_ADDR15_8 = 0;
 2392               		.loc 1 920 0
 2393 071c 1ABA      		out 0x1a,__zero_reg__
 921:setup.c       **** 	
 922:setup.c       **** 	// Light up 3.3V or 5V
 923:setup.c       **** 	if (cartMode == GB_MODE) {
 2394               		.loc 1 923 0
 2395 071e 8091 0000 		lds r24,cartMode
 2396 0722 8130      		cpi r24,lo8(1)
 2397 0724 01F4      		brne .L92
 924:setup.c       **** 		PORTD |= (1<<LED_5V);
 2398               		.loc 1 924 0
 2399 0726 979A      		sbi 0x12,7
 925:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2400               		.loc 1 925 0
 2401 0728 3898      		cbi 0x7,0
 2402 072a 00C0      		rjmp .L93
 2403               	.L92:
 926:setup.c       **** 	}
 927:setup.c       **** 	else {
 928:setup.c       **** 		PORTE |= (1<<LED_3V);
 2404               		.loc 1 928 0
 2405 072c 389A      		sbi 0x7,0
 929:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2406               		.loc 1 929 0
 2407 072e 9798      		cbi 0x12,7
 2408               	.L93:
 930:setup.c       **** 	}
 931:setup.c       **** 	
 932:setup.c       **** 	// Light LED
 933:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2409               		.loc 1 933 0
 2410 0730 939A      		sbi 0x12,3
 2411               	.LVL180:
 2412               	.LBB179:
 2413               	.LBB180:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2414               		.loc 2 187 0
 2415 0732 2FEF      		ldi r18,lo8(799999)
 2416 0734 84E3      		ldi r24,hi8(799999)
 2417 0736 9CE0      		ldi r25,hlo8(799999)
 2418 0738 2150      	1:	subi r18,1
 2419 073a 8040      		sbci r24,0
 2420 073c 9040      		sbci r25,0
 2421 073e 01F4      		brne 1b
 2422 0740 00C0      		rjmp .
 2423 0742 0000      		nop
 2424               	.LVL181:
 2425               	.LBE180:
 2426               	.LBE179:
 934:setup.c       **** 	_delay_ms(500);
 935:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2427               		.loc 1 935 0
 2428 0744 9398      		cbi 0x12,3
 936:setup.c       **** 	
 937:setup.c       **** 	// Setup USART
 938:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2429               		.loc 1 938 0
 2430 0746 19B8      		out 0x9,__zero_reg__
 939:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2431               		.loc 1 939 0
 2432 0748 599A      		sbi 0xb,1
 940:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2433               		.loc 1 940 0
 2434 074a 539A      		sbi 0xa,3
 941:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2435               		.loc 1 941 0
 2436 074c 549A      		sbi 0xa,4
 942:setup.c       **** 	
 943:setup.c       **** 	// Turn on interrupts
 944:setup.c       **** 	sei();
 2437               		.loc 1 944 0
 2438               	/* #APP */
 2439               	 ;  944 "setup.c" 1
 2440 074e 7894      		sei
 2441               	 ;  0 "" 2
 2442               	/* #NOAPP */
 2443 0750 0895      		ret
 2444               		.cfi_endproc
 2445               	.LFE45:
 2447               		.section	.text.startup,"ax",@progbits
 2448               	.global	main
 2450               	main:
 2451               	.LFB46:
 2452               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.3
   4:main.c        ****  Firmware version: R16
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 16/01/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 4
  53:main.c        **** #define FIRMWARE_VERSION 16
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2453               		.loc 3 66 0
 2454               		.cfi_startproc
 2455               	/* prologue: function */
 2456               	/* frame size = 0 */
 2457               	/* stack size = 0 */
 2458               	.L__stack_usage = 0
  67:main.c        **** 	setup();
 2459               		.loc 3 67 0
 2460 0000 00D0      		rcall setup
 2461               	.LVL182:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 2462               		.loc 3 71 0
 2463 0002 2224      		clr r2
 2464 0004 2394      		inc r2
  70:main.c        **** 	uint8_t resetCommonLines = 1;
 2465               		.loc 3 70 0
 2466 0006 D1E0      		ldi r29,lo8(1)
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2467               		.loc 3 69 0
 2468 0008 C12C      		mov r12,__zero_reg__
 2469 000a D12C      		mov r13,__zero_reg__
 2470 000c 7601      		movw r14,r12
 2471               	.LBB181:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  78:main.c        **** 		
  79:main.c        **** 		// Return the cart mode in use
  80:main.c        **** 		if (receivedChar == CART_MODE) {
  81:main.c        **** 			USART_Transmit(cartMode);
  82:main.c        **** 		}
  83:main.c        **** 		
  84:main.c        **** 		// Change to GB mode or GBA mode if requested
  85:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  86:main.c        **** 			gb_mode();
  87:main.c        **** 		}
  88:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
  89:main.c        **** 			gba_mode();
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Switch voltage if requested
  93:main.c        **** 		else if (receivedChar == VOLTAGE_3_3V) {
  94:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
  95:main.c        **** 			cartMode = GBA_MODE;
  96:main.c        **** 			PORTE |= (1<<LED_3V);
  97:main.c        **** 			PORTD &= ~(1<<LED_5V);
  98:main.c        **** 		}
  99:main.c        **** 		else if (receivedChar == VOLTAGE_5V) {
 100:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 101:main.c        **** 			cartMode = GB_MODE;
 102:main.c        **** 			PORTD |= (1<<LED_5V);
 103:main.c        **** 			PORTE &= ~(1<<LED_3V);
 104:main.c        **** 		}
 105:main.c        **** 		
 106:main.c        **** 		
 107:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 108:main.c        **** 		
 109:main.c        **** 		// Set address
 110:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 111:main.c        **** 			usart_read_chars(); // Read start address
 112:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 113:main.c        **** 		}
 114:main.c        **** 		
 115:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 116:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 117:main.c        **** 			gb_mode();
 118:main.c        **** 			receivedChar = '1';
 119:main.c        **** 			while (receivedChar == '1') {
 120:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 121:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 122:main.c        **** 					USART_Transmit(read_8bit_data(address));
 123:main.c        **** 					address++;
 124:main.c        **** 				}
 125:main.c        **** 				
 126:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 127:main.c        **** 				receivedChar = USART_Receive();
 128:main.c        **** 			}
 129:main.c        **** 		}
 130:main.c        **** 		
 131:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 132:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 133:main.c        **** 			gb_mode();
 134:main.c        **** 			
 135:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 136:main.c        **** 			usart_read_bytes(64);
 137:main.c        **** 			
 138:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 139:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 140:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 141:main.c        **** 				address++;
 142:main.c        **** 			}
 143:main.c        **** 			
 144:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 145:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 146:main.c        **** 		}
 147:main.c        **** 		
 148:main.c        **** 		// Set bank address and write a byte
 149:main.c        **** 		else if (receivedChar == SET_BANK) {
 150:main.c        **** 			gb_mode();
 151:main.c        **** 			
 152:main.c        **** 			usart_read_chars(); // Read start address
 153:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 154:main.c        **** 			
 155:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 156:main.c        **** 			if (receivedChar == 'B') {
 157:main.c        **** 				usart_read_chars(); // Read data
 158:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 159:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 160:main.c        **** 				
 161:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 162:main.c        **** 			}
 163:main.c        **** 		}
 164:main.c        **** 		
 165:main.c        **** 		
 166:main.c        **** 		// ****** Gameboy Advance ******
 167:main.c        **** 		
 168:main.c        **** 		// ---------- ROM ----------
 169:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 170:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 171:main.c        **** 			gba_mode();
 172:main.c        **** 			
 173:main.c        **** 			uint8_t readEnd = 32;
 174:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 175:main.c        **** 				readEnd = 128;
 176:main.c        **** 			}
 177:main.c        **** 			
 178:main.c        **** 			receivedChar = '1';
 2472               		.loc 3 178 0
 2473 000e 91E3      		ldi r25,lo8(49)
 2474 0010 392E      		mov r3,r25
 2475               	.LBE181:
 2476               	.LBB184:
 2477               	.LBB185:
 179:main.c        **** 			while (receivedChar == '1') {
 180:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 181:main.c        **** 				
 182:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 183:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 184:main.c        **** 					
 185:main.c        **** 					// Low byte & High byte
 186:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 187:main.c        **** 					USART_Transmit(dataRead >> 8);
 188:main.c        **** 					
 189:main.c        **** 					address++;
 190:main.c        **** 				}
 191:main.c        **** 				
 192:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 193:main.c        **** 				receivedChar = USART_Receive();
 194:main.c        **** 			}
 195:main.c        **** 		}
 196:main.c        **** 		
 197:main.c        **** 		// ---------- SRAM ----------
 198:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 199:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 200:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 201:main.c        **** 			
 202:main.c        **** 			receivedChar = '1';
 203:main.c        **** 			while (receivedChar == '1') {
 204:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 205:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 206:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 207:main.c        **** 					address++;
 208:main.c        **** 				}
 209:main.c        **** 				
 210:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 211:main.c        **** 				receivedChar = USART_Receive();
 212:main.c        **** 			}
 213:main.c        **** 			
 214:main.c        **** 			gba_mode(); // Set back
 215:main.c        **** 		}
 216:main.c        **** 		
 217:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 218:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 219:main.c        **** 			gb_mode();
 220:main.c        **** 			
 221:main.c        **** 			usart_read_bytes(64);
 222:main.c        **** 			
 223:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 224:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 225:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 226:main.c        **** 				address++;
 227:main.c        **** 			}
 228:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 229:main.c        **** 			
 230:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 231:main.c        **** 			gba_mode(); // Set back
 232:main.c        **** 		}
 233:main.c        **** 		
 234:main.c        **** 		// Write 1 byte to SRAM address
 235:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 236:main.c        **** 			gb_mode();
 237:main.c        **** 			
 238:main.c        **** 			uint8_t data = USART_Receive();
 239:main.c        **** 			gba_write_ram_8bit_data(address, data);
 240:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 241:main.c        **** 			
 242:main.c        **** 			gba_mode(); // Set back
 243:main.c        **** 		}
 244:main.c        **** 		
 245:main.c        **** 		
 246:main.c        **** 		// ---------- FLASH ----------
 247:main.c        **** 		// Read the Flash Manufacturer and Device ID
 248:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 249:main.c        **** 			gb_mode();
 250:main.c        **** 			
 251:main.c        **** 			flash_read_chip_id();
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 253:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 254:main.c        **** 			
 255:main.c        **** 			gba_mode(); // Set back
 256:main.c        **** 		}
 257:main.c        **** 		
 258:main.c        **** 		// Change bank
 259:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 260:main.c        **** 			usart_read_chars(); // Read data
 261:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 262:main.c        **** 			
 263:main.c        **** 			gb_mode();
 264:main.c        **** 			flash_switch_bank(bank);
 265:main.c        **** 			
 266:main.c        **** 			gba_mode(); // Set back
 267:main.c        **** 		}
 268:main.c        **** 		
 269:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 270:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 271:main.c        **** 			gb_mode();
 272:main.c        **** 			
 273:main.c        **** 			usart_read_chars(); // Read sector
 274:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 275:main.c        **** 			
 276:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 277:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 278:main.c        **** 			
 279:main.c        **** 			gba_mode(); // Set back
 280:main.c        **** 		}
 281:main.c        **** 		
 282:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 283:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 284:main.c        **** 			gb_mode();
 285:main.c        **** 			
 286:main.c        **** 			usart_read_bytes(64);
 287:main.c        **** 			
 288:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 289:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 290:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 291:main.c        **** 				address++;
 292:main.c        **** 			}
 293:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 294:main.c        **** 			
 295:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 296:main.c        **** 			gba_mode(); // Set back
 297:main.c        **** 		}
 298:main.c        **** 		
 299:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 300:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 301:main.c        **** 			gb_mode();
 302:main.c        **** 			
 303:main.c        **** 			usart_read_bytes(128);
 304:main.c        **** 			
 305:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 306:main.c        **** 			flash_write_sector(address); // Address used as sector number
 307:main.c        **** 			address++;
 308:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 309:main.c        **** 			
 310:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 311:main.c        **** 			gba_mode(); // Set back
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		
 315:main.c        **** 		// ---------- EEPROM ----------
 316:main.c        **** 		// Set EEPROM size
 317:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 318:main.c        **** 			usart_read_chars(); // Read size
 319:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 320:main.c        **** 		}
 321:main.c        **** 		
 322:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 323:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 324:main.c        **** 			gba_eeprom_mode();
 325:main.c        **** 			
 326:main.c        **** 			receivedChar = '1';
 327:main.c        **** 			while (receivedChar == '1') {
 328:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 329:main.c        **** 				gba_eeprom_read(address, eepromSize);
 330:main.c        **** 				
 331:main.c        **** 				// Send back the 8 bytes of data
 332:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 333:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 334:main.c        **** 				}
 335:main.c        **** 				address++; // Increment to next 8 bytes
 336:main.c        **** 				
 337:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 338:main.c        **** 				receivedChar = USART_Receive();
 339:main.c        **** 			}
 340:main.c        **** 			
 341:main.c        **** 			gba_mode(); // Set back
 342:main.c        **** 		}
 343:main.c        **** 		
 344:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 345:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 346:main.c        **** 			gba_eeprom_mode();
 347:main.c        **** 			
 348:main.c        **** 			// Read 8 bytes from USART and place in buffer
 349:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 350:main.c        **** 				eepromBuffer[x] = USART_Receive();
 351:main.c        **** 			}
 352:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 353:main.c        **** 			
 354:main.c        **** 			gba_eeprom_write(address, eepromSize);
 355:main.c        **** 			address++;
 356:main.c        **** 			
 357:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 358:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 359:main.c        **** 			
 360:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 361:main.c        **** 			gba_mode(); // Set back
 362:main.c        **** 		}
 363:main.c        **** 		
 364:main.c        **** 		
 365:main.c        **** 		// ---------- GB FLASH CARTS ----------
 366:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 367:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 368:main.c        **** 			flashWriteWePin = USART_Receive();
 369:main.c        **** 			
 370:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 371:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 372:main.c        **** 				audioPin_high;
 373:main.c        **** 			}
 374:main.c        **** 		}
 375:main.c        **** 		
 376:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 377:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 378:main.c        **** 			flashBank1CommandWrites = 1;
 379:main.c        **** 		}
 380:main.c        **** 		
 381:main.c        **** 		// Load the program method to use
 382:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 383:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 384:main.c        **** 				usart_read_chars(); // Address
 385:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 386:main.c        **** 				USART_Transmit(SEND_ACK);
 387:main.c        **** 				
 388:main.c        **** 				usart_read_chars(); // Data
 389:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 390:main.c        **** 				USART_Transmit(SEND_ACK);
 391:main.c        **** 			}
 392:main.c        **** 		}
 393:main.c        **** 		
 394:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 395:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 396:main.c        **** 			usart_read_chars(); // Read address
 397:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 398:main.c        **** 			
 399:main.c        **** 			usart_read_chars(); // Read data byte
 400:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 401:main.c        **** 			
 402:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 403:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 404:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 405:main.c        **** 			
 406:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 407:main.c        **** 		}
 408:main.c        **** 		
 409:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 410:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 411:main.c        **** 			usart_read_bytes(64);
 412:main.c        **** 			
 413:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 414:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 415:main.c        **** 				if (flashBank1CommandWrites == 0) {
 416:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 417:main.c        **** 				}
 418:main.c        **** 				else { // Some flash carts need to change to bank 1 to issue flash commands
 419:main.c        **** 					gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 420:main.c        **** 				}
 421:main.c        **** 				address++;
 422:main.c        **** 			}
 423:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 424:main.c        **** 			
 425:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 426:main.c        **** 		}
 427:main.c        **** 		
 428:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 429:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 430:main.c        **** 			usart_read_bytes(32);
 431:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 432:main.c        **** 			
 433:main.c        **** 			// Setup buffered write
 434:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 435:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 436:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 437:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 438:main.c        **** 			_delay_us(1);
 439:main.c        **** 			
 440:main.c        **** 			// Write data
 441:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 442:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 443:main.c        **** 				address++;
 444:main.c        **** 			}
 445:main.c        **** 			
 446:main.c        **** 			// Write buffer to flash
 447:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 448:main.c        **** 			_delay_us(200);
 449:main.c        **** 			
 450:main.c        **** 			// Verify last byte written
 451:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 452:main.c        **** 			uint8_t verifyCount = 0;
 453:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 454:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 455:main.c        **** 				_delay_us(5);
 456:main.c        **** 				verifyCount++;
 457:main.c        **** 				if (verifyCount >= 200) {
 458:main.c        **** 					_delay_ms(500);
 459:main.c        **** 					break;
 460:main.c        **** 				}
 461:main.c        **** 			}
 462:main.c        **** 			
 463:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 464:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 465:main.c        **** 		}
 466:main.c        **** 		
 467:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 468:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 469:main.c        **** 			usart_read_bytes(64);
 470:main.c        **** 			
 471:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 472:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 473:main.c        **** 				if (receivedBuffer[x] != 0xFF) { // No need to program 0xFF, skip
 474:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 475:main.c        **** 				}
 476:main.c        **** 				address++;
 477:main.c        **** 			}
 478:main.c        **** 			
 479:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 480:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 481:main.c        **** 		}
 482:main.c        **** 		
 483:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 484:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 485:main.c        **** 			usart_read_bytes(256);
 486:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 487:main.c        **** 			
 488:main.c        **** 			// Setup buffered write
 489:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 490:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 491:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 492:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 493:main.c        **** 			_delay_us(50);
 494:main.c        **** 			
 495:main.c        **** 			// Write data
 496:main.c        **** 			for (int x = 0; x < 256; x++) {
 497:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 498:main.c        **** 				address++;
 499:main.c        **** 			}
 500:main.c        **** 			
 501:main.c        **** 			// Write buffer to flash
 502:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 503:main.c        **** 			
 504:main.c        **** 			// Verify last byte written
 505:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 506:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 507:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 508:main.c        **** 				_delay_us(5);
 509:main.c        **** 			}
 510:main.c        **** 			
 511:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 512:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 513:main.c        **** 		}
 514:main.c        **** 		
 515:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 516:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 517:main.c        **** 			usart_read_bytes(128);
 518:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 519:main.c        **** 			
 520:main.c        **** 			// Enable flash chip access
 521:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 522:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 523:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 524:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 525:main.c        **** 			_delay_us(5);
 526:main.c        **** 			
 527:main.c        **** 			// Re-Enable writes to MBC registers
 528:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 529:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 530:main.c        **** 			_delay_us(5);
 531:main.c        **** 			
 532:main.c        **** 			// Bank 1 for commands
 533:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 534:main.c        **** 			_delay_us(5);
 535:main.c        **** 			
 536:main.c        **** 			
 537:main.c        **** 			// Write setup
 538:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 539:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 540:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 541:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 542:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 543:main.c        **** 			_delay_us(5);
 544:main.c        **** 			
 545:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 546:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 547:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 548:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 549:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 550:main.c        **** 			_delay_us(5);
 551:main.c        **** 			
 552:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 553:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 554:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 555:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 556:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 557:main.c        **** 			_delay_us(5);
 558:main.c        **** 			
 559:main.c        **** 			// Set bank back
 560:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 561:main.c        **** 			_delay_us(5);
 562:main.c        **** 			
 563:main.c        **** 			// Disable writes to MBC registers
 564:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 565:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 566:main.c        **** 			_delay_us(5);
 567:main.c        **** 			
 568:main.c        **** 			// Undo Wakeup
 569:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 570:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 571:main.c        **** 			_delay_us(5);
 572:main.c        **** 			
 573:main.c        **** 			
 574:main.c        **** 			// Write data
 575:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 576:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 577:main.c        **** 				_delay_us(5);
 578:main.c        **** 				address++;
 579:main.c        **** 			}
 580:main.c        **** 			
 581:main.c        **** 			// Write buffer to flash
 582:main.c        **** 			address--;
 583:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 584:main.c        **** 			address++;
 585:main.c        **** 			_delay_ms(10);
 586:main.c        **** 			
 587:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 588:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 589:main.c        **** 		}
 590:main.c        **** 		
 591:main.c        **** 		
 592:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 593:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 594:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 595:main.c        **** 			usart_read_chars(); // Read address
 596:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 597:main.c        **** 			
 598:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 599:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 600:main.c        **** 				usart_read_chars(); // Read data
 601:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 602:main.c        **** 				
 603:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 604:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 605:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 606:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 607:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 608:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 609:main.c        **** 				
 610:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 611:main.c        **** 			}
 612:main.c        **** 		}
 613:main.c        **** 		
 614:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 615:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 616:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 617:main.c        **** 			
 618:main.c        **** 			int readLength = 64;
 619:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 620:main.c        **** 				readLength = 256;
 621:main.c        **** 			}
 622:main.c        **** 			usart_read_bytes(readLength);
 623:main.c        **** 			
 624:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 625:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 626:main.c        **** 				gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 627:main.c        **** 				address++;
 628:main.c        **** 			}
 629:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 630:main.c        **** 			
 631:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 632:main.c        **** 		}
 633:main.c        **** 		
 634:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 635:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 636:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 637:main.c        **** 			
 638:main.c        **** 			int readLength = 256;
 639:main.c        **** 			usart_read_bytes(readLength);
 640:main.c        **** 			
 641:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 642:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 643:main.c        **** 				gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 644:main.c        **** 				address++;
 645:main.c        **** 			}
 646:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 647:main.c        **** 			
 648:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 649:main.c        **** 		}
 650:main.c        **** 		
 651:main.c        **** 		// Intel flash command based chips
 652:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 653:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 654:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 655:main.c        **** 			usart_read_bytes(64);
 656:main.c        **** 			
 657:main.c        **** 			// Set address lines as outputs
 658:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 659:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 660:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 661:main.c        **** 			
 662:main.c        **** 			// Unlock
 663:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 664:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 665:main.c        **** 			
 666:main.c        **** 			// Buffered write command
 667:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 668:main.c        **** 			_delay_us(50);
 669:main.c        **** 			
 670:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 671:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 672:main.c        **** 			while (dataVerify != 0x0080) {
 673:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 674:main.c        **** 				_delay_us(50);
 675:main.c        **** 			}
 676:main.c        **** 			
 677:main.c        **** 			
 678:main.c        **** 			// Set address lines as outputs
 679:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 680:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 681:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 682:main.c        **** 			
 683:main.c        **** 			// Set length
 684:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 685:main.c        **** 			
 686:main.c        **** 			// Write data
 687:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 688:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 689:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 690:main.c        **** 				address++;
 691:main.c        **** 			}
 692:main.c        **** 			
 693:main.c        **** 			// Write buffer to flash
 694:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 695:main.c        **** 			_delay_us(440);
 696:main.c        **** 			
 697:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 698:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 699:main.c        **** 			while (dataVerify != 0x0080) {
 700:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 701:main.c        **** 				_delay_us(50);
 702:main.c        **** 			}
 703:main.c        **** 			
 704:main.c        **** 			
 705:main.c        **** 			// Set address lines as outputs
 706:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 707:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 708:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 709:main.c        **** 			
 710:main.c        **** 			// Back to reading mode
 711:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 712:main.c        **** 			
 713:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 714:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 715:main.c        **** 		}
 716:main.c        **** 		
 717:main.c        **** 		// Intel word programming
 718:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE_WORD) {
 719:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 720:main.c        **** 			usart_read_bytes(64);
 721:main.c        **** 			
 722:main.c        **** 			// Write data
 723:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 724:main.c        **** 				// Set address lines as outputs
 725:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2478               		.loc 3 725 0
 2479 0012 CFEF      		ldi r28,lo8(-1)
 2480               	.LVL183:
 2481               	.L95:
 2482               	.LBE185:
 2483               	.LBE184:
  74:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2484               		.loc 3 74 0
 2485 0014 21E0      		ldi r18,lo8(1)
 2486 0016 2212      		cpse r2,r18
 2487 0018 00C0      		rjmp .L96
 2488               	.LVL184:
 2489               	.L244:
  75:main.c        **** 		}
 2490               		.loc 3 75 0
 2491 001a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2492               	.LVL185:
 2493               	.L96:
  77:main.c        **** 		
 2494               		.loc 3 77 0
 2495 001c 00D0      		rcall USART_Receive
 2496               	.LVL186:
 2497 001e 8093 0000 		sts receivedChar,r24
  80:main.c        **** 			USART_Transmit(cartMode);
 2498               		.loc 3 80 0
 2499 0022 8334      		cpi r24,lo8(67)
 2500 0024 01F4      		brne .L97
  81:main.c        **** 		}
 2501               		.loc 3 81 0
 2502 0026 8091 0000 		lds r24,cartMode
 2503 002a 00C0      		rjmp .L245
 2504               	.L97:
  85:main.c        **** 			gb_mode();
 2505               		.loc 3 85 0
 2506 002c 8734      		cpi r24,lo8(71)
 2507 002e 01F4      		brne .L99
  86:main.c        **** 		}
 2508               		.loc 3 86 0
 2509 0030 00D0      		rcall gb_mode
 2510               	.LVL187:
 2511 0032 00C0      		rjmp .L95
 2512               	.L99:
  88:main.c        **** 			gba_mode();
 2513               		.loc 3 88 0
 2514 0034 8736      		cpi r24,lo8(103)
 2515 0036 01F4      		brne .+2
 2516 0038 00C0      		rjmp .L247
  93:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
 2517               		.loc 3 93 0
 2518 003a 8333      		cpi r24,lo8(51)
 2519 003c 01F4      		brne .L101
  94:main.c        **** 			cartMode = GBA_MODE;
 2520               		.loc 3 94 0
 2521 003e 9298      		cbi 0x12,2
  95:main.c        **** 			PORTE |= (1<<LED_3V);
 2522               		.loc 3 95 0
 2523 0040 82E0      		ldi r24,lo8(2)
 2524 0042 8093 0000 		sts cartMode,r24
  96:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2525               		.loc 3 96 0
 2526 0046 389A      		sbi 0x7,0
  97:main.c        **** 		}
 2527               		.loc 3 97 0
 2528 0048 9798      		cbi 0x12,7
 2529 004a 00C0      		rjmp .L95
 2530               	.L101:
  99:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 2531               		.loc 3 99 0
 2532 004c 8533      		cpi r24,lo8(53)
 2533 004e 01F4      		brne .L102
 100:main.c        **** 			cartMode = GB_MODE;
 2534               		.loc 3 100 0
 2535 0050 929A      		sbi 0x12,2
 101:main.c        **** 			PORTD |= (1<<LED_5V);
 2536               		.loc 3 101 0
 2537 0052 81E0      		ldi r24,lo8(1)
 2538 0054 8093 0000 		sts cartMode,r24
 102:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2539               		.loc 3 102 0
 2540 0058 979A      		sbi 0x12,7
 103:main.c        **** 		}
 2541               		.loc 3 103 0
 2542 005a 3898      		cbi 0x7,0
 2543 005c 00C0      		rjmp .L95
 2544               	.L102:
 110:main.c        **** 			usart_read_chars(); // Read start address
 2545               		.loc 3 110 0
 2546 005e 8134      		cpi r24,lo8(65)
 2547 0060 01F4      		brne .L103
 111:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2548               		.loc 3 111 0
 2549 0062 00D0      		rcall usart_read_chars
 2550               	.LVL188:
 112:main.c        **** 		}
 2551               		.loc 3 112 0
 2552 0064 40E1      		ldi r20,lo8(16)
 2553 0066 50E0      		ldi r21,0
 2554 0068 60E0      		ldi r22,0
 2555 006a 70E0      		ldi r23,0
 2556 006c 80E0      		ldi r24,lo8(receivedBuffer)
 2557 006e 90E0      		ldi r25,hi8(receivedBuffer)
 2558 0070 00D0      		rcall strtol
 2559               	.LVL189:
 2560 0072 6B01      		movw r12,r22
 2561 0074 7C01      		movw r14,r24
 2562               	.LVL190:
 2563 0076 00C0      		rjmp .L95
 2564               	.L103:
 116:main.c        **** 			gb_mode();
 2565               		.loc 3 116 0
 2566 0078 8235      		cpi r24,lo8(82)
 2567 007a 01F4      		brne .L104
 117:main.c        **** 			receivedChar = '1';
 2568               		.loc 3 117 0
 2569 007c 00D0      		rcall gb_mode
 2570               	.LVL191:
 118:main.c        **** 			while (receivedChar == '1') {
 2571               		.loc 3 118 0
 2572 007e 3092 0000 		sts receivedChar,r3
 2573               	.LVL192:
 2574               	.L105:
 119:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2575               		.loc 3 119 0
 2576 0082 8091 0000 		lds r24,receivedChar
 2577 0086 8133      		cpi r24,lo8(49)
 2578 0088 01F4      		brne .L95
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2579               		.loc 3 120 0
 2580 008a 939A      		sbi 0x12,3
 2581               	.LVL193:
 2582 008c 00E0      		ldi r16,0
 2583 008e 10E0      		ldi r17,0
 2584               	.LVL194:
 2585               	.L106:
 2586               	.LBB189:
 122:main.c        **** 					address++;
 2587               		.loc 3 122 0 discriminator 3
 2588 0090 C801      		movw r24,r16
 2589 0092 8C0D      		add r24,r12
 2590 0094 9D1D      		adc r25,r13
 2591 0096 00D0      		rcall read_8bit_data
 2592               	.LVL195:
 2593 0098 00D0      		rcall USART_Transmit
 2594               	.LVL196:
 2595 009a 0F5F      		subi r16,-1
 2596 009c 1F4F      		sbci r17,-1
 2597               	.LVL197:
 121:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2598               		.loc 3 121 0 discriminator 3
 2599 009e 0034      		cpi r16,64
 2600 00a0 1105      		cpc r17,__zero_reg__
 2601 00a2 01F4      		brne .L106
 2602 00a4 80E4      		ldi r24,64
 2603 00a6 C80E      		add r12,r24
 2604 00a8 D11C      		adc r13,__zero_reg__
 2605 00aa E11C      		adc r14,__zero_reg__
 2606 00ac F11C      		adc r15,__zero_reg__
 2607               	.LBE189:
 126:main.c        **** 				receivedChar = USART_Receive();
 2608               		.loc 3 126 0
 2609 00ae 9398      		cbi 0x12,3
 127:main.c        **** 			}
 2610               		.loc 3 127 0
 2611 00b0 00D0      		rcall USART_Receive
 2612               	.LVL198:
 2613 00b2 8093 0000 		sts receivedChar,r24
 2614 00b6 00C0      		rjmp .L105
 2615               	.LVL199:
 2616               	.L104:
 132:main.c        **** 			gb_mode();
 2617               		.loc 3 132 0
 2618 00b8 8735      		cpi r24,lo8(87)
 2619 00ba 01F4      		brne .L108
 133:main.c        **** 			
 2620               		.loc 3 133 0
 2621 00bc 00D0      		rcall gb_mode
 2622               	.LVL200:
 136:main.c        **** 			
 2623               		.loc 3 136 0
 2624 00be 80E4      		ldi r24,lo8(64)
 2625 00c0 90E0      		ldi r25,0
 2626 00c2 00D0      		rcall usart_read_bytes
 2627               	.LVL201:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2628               		.loc 3 138 0
 2629 00c4 939A      		sbi 0x12,3
 2630               	.LVL202:
 2631 00c6 80E0      		ldi r24,lo8(receivedBuffer)
 2632 00c8 A82E      		mov r10,r24
 2633 00ca 80E0      		ldi r24,hi8(receivedBuffer)
 2634 00cc B82E      		mov r11,r24
 2635 00ce 00E0      		ldi r16,0
 2636 00d0 10E0      		ldi r17,0
 2637               	.LVL203:
 2638               	.L109:
 2639               	.LBB190:
 140:main.c        **** 				address++;
 2640               		.loc 3 140 0 discriminator 3
 2641 00d2 F501      		movw r30,r10
 2642 00d4 6191      		ld r22,Z+
 2643 00d6 5F01      		movw r10,r30
 2644 00d8 C801      		movw r24,r16
 2645 00da 8C0D      		add r24,r12
 2646 00dc 9D1D      		adc r25,r13
 2647 00de 41E0      		ldi r20,lo8(1)
 2648 00e0 00D0      		rcall write_8bit_data
 2649               	.LVL204:
 2650 00e2 0F5F      		subi r16,-1
 2651 00e4 1F4F      		sbci r17,-1
 2652               	.LVL205:
 139:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2653               		.loc 3 139 0 discriminator 3
 2654 00e6 0034      		cpi r16,64
 2655 00e8 1105      		cpc r17,__zero_reg__
 2656 00ea 01F4      		brne .L109
 2657 00ec F0E4      		ldi r31,64
 2658 00ee CF0E      		add r12,r31
 2659 00f0 D11C      		adc r13,__zero_reg__
 2660 00f2 E11C      		adc r14,__zero_reg__
 2661 00f4 F11C      		adc r15,__zero_reg__
 2662 00f6 00C0      		rjmp .L264
 2663               	.LVL206:
 2664               	.L108:
 2665               	.LBE190:
 149:main.c        **** 			gb_mode();
 2666               		.loc 3 149 0
 2667 00f8 8234      		cpi r24,lo8(66)
 2668 00fa 01F4      		brne .L110
 2669               	.LBB191:
 150:main.c        **** 			
 2670               		.loc 3 150 0
 2671 00fc 00D0      		rcall gb_mode
 2672               	.LVL207:
 152:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2673               		.loc 3 152 0
 2674 00fe 00D0      		rcall usart_read_chars
 2675               	.LVL208:
 153:main.c        **** 			
 2676               		.loc 3 153 0
 2677 0100 40E1      		ldi r20,lo8(16)
 2678 0102 50E0      		ldi r21,0
 2679 0104 60E0      		ldi r22,0
 2680 0106 70E0      		ldi r23,0
 2681 0108 80E0      		ldi r24,lo8(receivedBuffer)
 2682 010a 90E0      		ldi r25,hi8(receivedBuffer)
 2683 010c 00D0      		rcall strtol
 2684               	.LVL209:
 2685 010e 4B01      		movw r8,r22
 2686 0110 5C01      		movw r10,r24
 2687               	.LVL210:
 155:main.c        **** 			if (receivedChar == 'B') {
 2688               		.loc 3 155 0
 2689 0112 00D0      		rcall USART_Receive
 2690               	.LVL211:
 2691 0114 8093 0000 		sts receivedChar,r24
 156:main.c        **** 				usart_read_chars(); // Read data
 2692               		.loc 3 156 0
 2693 0118 8234      		cpi r24,lo8(66)
 2694 011a 01F0      		breq .+2
 2695 011c 00C0      		rjmp .L95
 2696               	.LBB192:
 157:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2697               		.loc 3 157 0
 2698 011e 00D0      		rcall usart_read_chars
 2699               	.LVL212:
 158:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2700               		.loc 3 158 0
 2701 0120 80E0      		ldi r24,lo8(receivedBuffer)
 2702 0122 90E0      		ldi r25,hi8(receivedBuffer)
 2703 0124 00D0      		rcall atoi
 2704               	.LVL213:
 159:main.c        **** 				
 2705               		.loc 3 159 0
 2706 0126 8093 0000 		sts lastBankAccessed,r24
 161:main.c        **** 			}
 2707               		.loc 3 161 0
 2708 012a 40E0      		ldi r20,0
 2709 012c 682F      		mov r22,r24
 2710 012e C401      		movw r24,r8
 2711               	.LVL214:
 2712 0130 00D0      		rcall write_8bit_data
 2713               	.LVL215:
 2714 0132 00C0      		rjmp .L95
 2715               	.LVL216:
 2716               	.L110:
 2717               	.LBE192:
 2718               	.LBE191:
 170:main.c        **** 			gba_mode();
 2719               		.loc 3 170 0
 2720 0134 8237      		cpi r24,lo8(114)
 2721 0136 01F0      		breq .L111
 170:main.c        **** 			gba_mode();
 2722               		.loc 3 170 0 is_stmt 0 discriminator 1
 2723 0138 8A36      		cpi r24,lo8(106)
 2724 013a 01F4      		brne .L112
 2725               	.L111:
 2726               	.LBB193:
 171:main.c        **** 			
 2727               		.loc 3 171 0 is_stmt 1
 2728 013c 00D0      		rcall gba_mode
 2729               	.LVL217:
 174:main.c        **** 				readEnd = 128;
 2730               		.loc 3 174 0
 2731 013e 8091 0000 		lds r24,receivedChar
 2732 0142 8A36      		cpi r24,lo8(106)
 2733 0144 01F4      		brne .L211
 175:main.c        **** 			}
 2734               		.loc 3 175 0
 2735 0146 10E8      		ldi r17,lo8(-128)
 2736 0148 00C0      		rjmp .L113
 2737               	.L211:
 173:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2738               		.loc 3 173 0
 2739 014a 10E2      		ldi r17,lo8(32)
 2740               	.L113:
 2741               	.LVL218:
 178:main.c        **** 			while (receivedChar == '1') {
 2742               		.loc 3 178 0
 2743 014c 3092 0000 		sts receivedChar,r3
 2744 0150 8824      		clr r8
 2745 0152 8A94      		dec r8
 2746 0154 810E      		add r8,r17
 2747 0156 912C      		mov r9,__zero_reg__
 2748 0158 A12C      		mov r10,__zero_reg__
 2749 015a B12C      		mov r11,__zero_reg__
 2750 015c 2FEF      		ldi r18,-1
 2751 015e 821A      		sub r8,r18
 2752 0160 920A      		sbc r9,r18
 2753 0162 A20A      		sbc r10,r18
 2754 0164 B20A      		sbc r11,r18
 2755               	.LVL219:
 2756               	.L114:
 179:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2757               		.loc 3 179 0
 2758 0166 8091 0000 		lds r24,receivedChar
 2759 016a 8133      		cpi r24,lo8(49)
 2760 016c 01F0      		breq .+2
 2761 016e 00C0      		rjmp .L95
 180:main.c        **** 				
 2762               		.loc 3 180 0
 2763 0170 939A      		sbi 0x12,3
 2764               	.LVL220:
 2765 0172 2601      		movw r4,r12
 2766 0174 3701      		movw r6,r14
 2767               	.LVL221:
 2768               	.L115:
 2769               	.LBB182:
 2770               	.LBB183:
 183:main.c        **** 					
 2771               		.loc 3 183 0 discriminator 3
 2772 0176 C301      		movw r24,r6
 2773 0178 B201      		movw r22,r4
 2774 017a 00D0      		rcall gba_read_16bit_data
 2775               	.LVL222:
 2776 017c 092F      		mov r16,r25
 2777               	.LVL223:
 186:main.c        **** 					USART_Transmit(dataRead >> 8);
 2778               		.loc 3 186 0 discriminator 3
 2779 017e 00D0      		rcall USART_Transmit
 2780               	.LVL224:
 187:main.c        **** 					
 2781               		.loc 3 187 0 discriminator 3
 2782 0180 802F      		mov r24,r16
 2783 0182 00D0      		rcall USART_Transmit
 2784               	.LVL225:
 189:main.c        **** 				}
 2785               		.loc 3 189 0 discriminator 3
 2786 0184 8FEF      		ldi r24,-1
 2787 0186 481A      		sub r4,r24
 2788 0188 580A      		sbc r5,r24
 2789 018a 680A      		sbc r6,r24
 2790 018c 780A      		sbc r7,r24
 2791               	.LVL226:
 2792               	.LBE183:
 182:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2793               		.loc 3 182 0 discriminator 3
 2794 018e 842D      		mov r24,r4
 2795 0190 8C19      		sub r24,r12
 2796 0192 8117      		cp r24,r17
 2797 0194 00F0      		brlo .L115
 2798 0196 C80C      		add r12,r8
 2799 0198 D91C      		adc r13,r9
 2800 019a EA1C      		adc r14,r10
 2801 019c FB1C      		adc r15,r11
 2802               	.LVL227:
 2803               	.LBE182:
 192:main.c        **** 				receivedChar = USART_Receive();
 2804               		.loc 3 192 0
 2805 019e 9398      		cbi 0x12,3
 193:main.c        **** 			}
 2806               		.loc 3 193 0
 2807 01a0 00D0      		rcall USART_Receive
 2808               	.LVL228:
 2809 01a2 8093 0000 		sts receivedChar,r24
 2810 01a6 00C0      		rjmp .L114
 2811               	.LVL229:
 2812               	.L112:
 2813               	.LBE193:
 199:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2814               		.loc 3 199 0
 2815 01a8 8D36      		cpi r24,lo8(109)
 2816 01aa 01F4      		brne .L117
 200:main.c        **** 			
 2817               		.loc 3 200 0
 2818 01ac 00D0      		rcall gb_mode
 2819               	.LVL230:
 202:main.c        **** 			while (receivedChar == '1') {
 2820               		.loc 3 202 0
 2821 01ae 3092 0000 		sts receivedChar,r3
 2822               	.LVL231:
 2823               	.L118:
 203:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2824               		.loc 3 203 0
 2825 01b2 8091 0000 		lds r24,receivedChar
 2826 01b6 8133      		cpi r24,lo8(49)
 2827 01b8 01F4      		brne .L247
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2828               		.loc 3 204 0
 2829 01ba 939A      		sbi 0x12,3
 2830               	.LVL232:
 2831 01bc 00E0      		ldi r16,0
 2832 01be 10E0      		ldi r17,0
 2833               	.LVL233:
 2834               	.L119:
 2835               	.LBB194:
 206:main.c        **** 					address++;
 2836               		.loc 3 206 0 discriminator 3
 2837 01c0 C801      		movw r24,r16
 2838 01c2 8C0D      		add r24,r12
 2839 01c4 9D1D      		adc r25,r13
 2840 01c6 00D0      		rcall gba_read_ram_8bit_data
 2841               	.LVL234:
 2842 01c8 00D0      		rcall USART_Transmit
 2843               	.LVL235:
 2844 01ca 0F5F      		subi r16,-1
 2845 01cc 1F4F      		sbci r17,-1
 2846               	.LVL236:
 205:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2847               		.loc 3 205 0 discriminator 3
 2848 01ce 0034      		cpi r16,64
 2849 01d0 1105      		cpc r17,__zero_reg__
 2850 01d2 01F4      		brne .L119
 2851 01d4 90E4      		ldi r25,64
 2852 01d6 C90E      		add r12,r25
 2853 01d8 D11C      		adc r13,__zero_reg__
 2854 01da E11C      		adc r14,__zero_reg__
 2855 01dc F11C      		adc r15,__zero_reg__
 2856               	.LBE194:
 210:main.c        **** 				receivedChar = USART_Receive();
 2857               		.loc 3 210 0
 2858 01de 9398      		cbi 0x12,3
 211:main.c        **** 			}
 2859               		.loc 3 211 0
 2860 01e0 00D0      		rcall USART_Receive
 2861               	.LVL237:
 2862 01e2 8093 0000 		sts receivedChar,r24
 2863 01e6 00C0      		rjmp .L118
 2864               	.LVL238:
 2865               	.L117:
 218:main.c        **** 			gb_mode();
 2866               		.loc 3 218 0
 2867 01e8 8737      		cpi r24,lo8(119)
 2868 01ea 01F4      		brne .L121
 219:main.c        **** 			
 2869               		.loc 3 219 0
 2870 01ec 00D0      		rcall gb_mode
 2871               	.LVL239:
 221:main.c        **** 			
 2872               		.loc 3 221 0
 2873 01ee 80E4      		ldi r24,lo8(64)
 2874 01f0 90E0      		ldi r25,0
 2875 01f2 00D0      		rcall usart_read_bytes
 2876               	.LVL240:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2877               		.loc 3 223 0
 2878 01f4 939A      		sbi 0x12,3
 2879               	.LVL241:
 2880 01f6 00E0      		ldi r16,lo8(receivedBuffer)
 2881 01f8 A02E      		mov r10,r16
 2882 01fa 00E0      		ldi r16,hi8(receivedBuffer)
 2883 01fc B02E      		mov r11,r16
 2884 01fe 00E0      		ldi r16,0
 2885 0200 10E0      		ldi r17,0
 2886               	.LVL242:
 2887               	.L122:
 2888               	.LBB195:
 225:main.c        **** 				address++;
 2889               		.loc 3 225 0 discriminator 3
 2890 0202 F501      		movw r30,r10
 2891 0204 6191      		ld r22,Z+
 2892 0206 5F01      		movw r10,r30
 2893 0208 C801      		movw r24,r16
 2894 020a 8C0D      		add r24,r12
 2895 020c 9D1D      		adc r25,r13
 2896 020e 00D0      		rcall gba_write_ram_8bit_data
 2897               	.LVL243:
 2898 0210 0F5F      		subi r16,-1
 2899 0212 1F4F      		sbci r17,-1
 2900               	.LVL244:
 224:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2901               		.loc 3 224 0 discriminator 3
 2902 0214 0034      		cpi r16,64
 2903 0216 1105      		cpc r17,__zero_reg__
 2904 0218 01F4      		brne .L122
 2905               	.LVL245:
 2906               	.L250:
 2907 021a F0E4      		ldi r31,64
 2908 021c CF0E      		add r12,r31
 2909 021e D11C      		adc r13,__zero_reg__
 2910 0220 E11C      		adc r14,__zero_reg__
 2911 0222 F11C      		adc r15,__zero_reg__
 2912               	.L249:
 2913               	.LBE195:
 228:main.c        **** 			
 2914               		.loc 3 228 0
 2915 0224 81E3      		ldi r24,lo8(49)
 2916 0226 00D0      		rcall USART_Transmit
 2917               	.LVL246:
 230:main.c        **** 			gba_mode(); // Set back
 2918               		.loc 3 230 0
 2919 0228 9398      		cbi 0x12,3
 2920               	.L247:
 231:main.c        **** 		}
 2921               		.loc 3 231 0
 2922 022a 00D0      		rcall gba_mode
 2923               	.LVL247:
 2924 022c 00C0      		rjmp .L95
 2925               	.LVL248:
 2926               	.L121:
 235:main.c        **** 			gb_mode();
 2927               		.loc 3 235 0
 2928 022e 8F36      		cpi r24,lo8(111)
 2929 0230 01F4      		brne .L123
 2930               	.LBB196:
 236:main.c        **** 			
 2931               		.loc 3 236 0
 2932 0232 00D0      		rcall gb_mode
 2933               	.LVL249:
 238:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2934               		.loc 3 238 0
 2935 0234 00D0      		rcall USART_Receive
 2936               	.LVL250:
 239:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2937               		.loc 3 239 0
 2938 0236 682F      		mov r22,r24
 2939 0238 C601      		movw r24,r12
 2940               	.LVL251:
 2941 023a 00D0      		rcall gba_write_ram_8bit_data
 2942               	.LVL252:
 2943 023c 00C0      		rjmp .L252
 2944               	.L123:
 2945               	.LBE196:
 248:main.c        **** 			gb_mode();
 2946               		.loc 3 248 0
 2947 023e 8936      		cpi r24,lo8(105)
 2948 0240 01F4      		brne .L124
 249:main.c        **** 			
 2949               		.loc 3 249 0
 2950 0242 00D0      		rcall gb_mode
 2951               	.LVL253:
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2952               		.loc 3 251 0
 2953 0244 00D0      		rcall flash_read_chip_id
 2954               	.LVL254:
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2955               		.loc 3 252 0
 2956 0246 8091 0000 		lds r24,flashChipIdBuffer
 2957 024a 00D0      		rcall USART_Transmit
 2958               	.LVL255:
 253:main.c        **** 			
 2959               		.loc 3 253 0
 2960 024c 8091 0000 		lds r24,flashChipIdBuffer+1
 2961               	.L251:
 2962 0250 00D0      		rcall USART_Transmit
 2963               	.LVL256:
 2964 0252 00C0      		rjmp .L247
 2965               	.L124:
 259:main.c        **** 			usart_read_chars(); // Read data
 2966               		.loc 3 259 0
 2967 0254 8B36      		cpi r24,lo8(107)
 2968 0256 01F4      		brne .L125
 2969               	.LBB197:
 260:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2970               		.loc 3 260 0
 2971 0258 00D0      		rcall usart_read_chars
 2972               	.LVL257:
 261:main.c        **** 			
 2973               		.loc 3 261 0
 2974 025a 80E0      		ldi r24,lo8(receivedBuffer)
 2975 025c 90E0      		ldi r25,hi8(receivedBuffer)
 2976 025e 00D0      		rcall atoi
 2977               	.LVL258:
 2978 0260 182F      		mov r17,r24
 2979               	.LVL259:
 263:main.c        **** 			flash_switch_bank(bank);
 2980               		.loc 3 263 0
 2981 0262 00D0      		rcall gb_mode
 2982               	.LVL260:
 264:main.c        **** 			
 2983               		.loc 3 264 0
 2984 0264 812F      		mov r24,r17
 2985 0266 00D0      		rcall flash_switch_bank
 2986               	.LVL261:
 2987 0268 00C0      		rjmp .L247
 2988               	.LVL262:
 2989               	.L125:
 2990               	.LBE197:
 270:main.c        **** 			gb_mode();
 2991               		.loc 3 270 0
 2992 026a 8337      		cpi r24,lo8(115)
 2993 026c 01F4      		brne .L126
 2994               	.LBB198:
 271:main.c        **** 			
 2995               		.loc 3 271 0
 2996 026e 00D0      		rcall gb_mode
 2997               	.LVL263:
 273:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2998               		.loc 3 273 0
 2999 0270 00D0      		rcall usart_read_chars
 3000               	.LVL264:
 274:main.c        **** 			
 3001               		.loc 3 274 0
 3002 0272 40E1      		ldi r20,lo8(16)
 3003 0274 50E0      		ldi r21,0
 3004 0276 60E0      		ldi r22,0
 3005 0278 70E0      		ldi r23,0
 3006 027a 80E0      		ldi r24,lo8(receivedBuffer)
 3007 027c 90E0      		ldi r25,hi8(receivedBuffer)
 3008 027e 00D0      		rcall strtol
 3009               	.LVL265:
 3010 0280 862F      		mov r24,r22
 3011               	.LVL266:
 276:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3012               		.loc 3 276 0
 3013 0282 00D0      		rcall flash_erase_4k_sector
 3014               	.LVL267:
 3015               	.L252:
 277:main.c        **** 			
 3016               		.loc 3 277 0
 3017 0284 81E3      		ldi r24,lo8(49)
 3018 0286 00C0      		rjmp .L251
 3019               	.L126:
 3020               	.LBE198:
 283:main.c        **** 			gb_mode();
 3021               		.loc 3 283 0
 3022 0288 8236      		cpi r24,lo8(98)
 3023 028a 01F4      		brne .L127
 284:main.c        **** 			
 3024               		.loc 3 284 0
 3025 028c 00D0      		rcall gb_mode
 3026               	.LVL268:
 286:main.c        **** 			
 3027               		.loc 3 286 0
 3028 028e 80E4      		ldi r24,lo8(64)
 3029 0290 90E0      		ldi r25,0
 3030 0292 00D0      		rcall usart_read_bytes
 3031               	.LVL269:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3032               		.loc 3 288 0
 3033 0294 939A      		sbi 0x12,3
 3034               	.LVL270:
 3035 0296 10E0      		ldi r17,lo8(receivedBuffer)
 3036 0298 A12E      		mov r10,r17
 3037 029a 10E0      		ldi r17,hi8(receivedBuffer)
 3038 029c B12E      		mov r11,r17
 3039 029e 00E0      		ldi r16,0
 3040 02a0 10E0      		ldi r17,0
 3041               	.LVL271:
 3042               	.L128:
 3043               	.LBB199:
 290:main.c        **** 				address++;
 3044               		.loc 3 290 0 discriminator 3
 3045 02a2 F501      		movw r30,r10
 3046 02a4 6191      		ld r22,Z+
 3047 02a6 5F01      		movw r10,r30
 3048 02a8 C801      		movw r24,r16
 3049 02aa 8C0D      		add r24,r12
 3050 02ac 9D1D      		adc r25,r13
 3051 02ae 00D0      		rcall flash_write_byte
 3052               	.LVL272:
 3053 02b0 0F5F      		subi r16,-1
 3054 02b2 1F4F      		sbci r17,-1
 3055               	.LVL273:
 289:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 3056               		.loc 3 289 0 discriminator 3
 3057 02b4 0034      		cpi r16,64
 3058 02b6 1105      		cpc r17,__zero_reg__
 3059 02b8 01F4      		brne .L128
 3060 02ba 00C0      		rjmp .L250
 3061               	.LVL274:
 3062               	.L127:
 3063               	.LBE199:
 300:main.c        **** 			gb_mode();
 3064               		.loc 3 300 0
 3065 02bc 8136      		cpi r24,lo8(97)
 3066 02be 01F4      		brne .L129
 301:main.c        **** 			
 3067               		.loc 3 301 0
 3068 02c0 00D0      		rcall gb_mode
 3069               	.LVL275:
 303:main.c        **** 			
 3070               		.loc 3 303 0
 3071 02c2 80E8      		ldi r24,lo8(-128)
 3072 02c4 90E0      		ldi r25,0
 3073 02c6 00D0      		rcall usart_read_bytes
 3074               	.LVL276:
 305:main.c        **** 			flash_write_sector(address); // Address used as sector number
 3075               		.loc 3 305 0
 3076 02c8 939A      		sbi 0x12,3
 306:main.c        **** 			address++;
 3077               		.loc 3 306 0
 3078 02ca C601      		movw r24,r12
 3079 02cc 00D0      		rcall flash_write_sector
 3080               	.LVL277:
 307:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3081               		.loc 3 307 0
 3082 02ce 2FEF      		ldi r18,-1
 3083 02d0 C21A      		sub r12,r18
 3084 02d2 D20A      		sbc r13,r18
 3085 02d4 E20A      		sbc r14,r18
 3086 02d6 F20A      		sbc r15,r18
 3087               	.LVL278:
 3088 02d8 00C0      		rjmp .L249
 3089               	.L129:
 317:main.c        **** 			usart_read_chars(); // Read size
 3090               		.loc 3 317 0
 3091 02da 8335      		cpi r24,lo8(83)
 3092 02dc 01F4      		brne .L130
 318:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 3093               		.loc 3 318 0
 3094 02de 00D0      		rcall usart_read_chars
 3095               	.LVL279:
 319:main.c        **** 		}
 3096               		.loc 3 319 0
 3097 02e0 40E1      		ldi r20,lo8(16)
 3098 02e2 50E0      		ldi r21,0
 3099 02e4 60E0      		ldi r22,0
 3100 02e6 70E0      		ldi r23,0
 3101 02e8 80E0      		ldi r24,lo8(receivedBuffer)
 3102 02ea 90E0      		ldi r25,hi8(receivedBuffer)
 3103 02ec 00D0      		rcall strtol
 3104               	.LVL280:
 3105 02ee D62F      		mov r29,r22
 3106               	.LVL281:
 3107 02f0 00C0      		rjmp .L95
 3108               	.LVL282:
 3109               	.L130:
 323:main.c        **** 			gba_eeprom_mode();
 3110               		.loc 3 323 0
 3111 02f2 8536      		cpi r24,lo8(101)
 3112 02f4 01F4      		brne .L131
 324:main.c        **** 			
 3113               		.loc 3 324 0
 3114 02f6 00D0      		rcall gba_eeprom_mode
 3115               	.LVL283:
 326:main.c        **** 			while (receivedChar == '1') {
 3116               		.loc 3 326 0
 3117 02f8 3092 0000 		sts receivedChar,r3
 3118               	.L132:
 327:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3119               		.loc 3 327 0
 3120 02fc 8091 0000 		lds r24,receivedChar
 3121 0300 8133      		cpi r24,lo8(49)
 3122 0302 01F0      		breq .+2
 3123 0304 00C0      		rjmp .L247
 328:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3124               		.loc 3 328 0
 3125 0306 939A      		sbi 0x12,3
 329:main.c        **** 				
 3126               		.loc 3 329 0
 3127 0308 6D2F      		mov r22,r29
 3128 030a C601      		movw r24,r12
 3129 030c 00D0      		rcall gba_eeprom_read
 3130               	.LVL284:
 3131 030e 00E0      		ldi r16,lo8(eepromBuffer)
 3132 0310 10E0      		ldi r17,hi8(eepromBuffer)
 3133               	.LVL285:
 3134               	.L133:
 3135               	.LBB200:
 333:main.c        **** 				}
 3136               		.loc 3 333 0 discriminator 3
 3137 0312 F801      		movw r30,r16
 3138 0314 8191      		ld r24,Z+
 3139 0316 8F01      		movw r16,r30
 3140               	.LVL286:
 3141 0318 00D0      		rcall USART_Transmit
 3142               	.LVL287:
 332:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3143               		.loc 3 332 0 discriminator 3
 3144 031a 80E0      		ldi r24,lo8(eepromBuffer+8)
 3145 031c 90E0      		ldi r25,hi8(eepromBuffer+8)
 3146 031e 8017      		cp r24,r16
 3147 0320 9107      		cpc r25,r17
 3148 0322 01F4      		brne .L133
 3149               	.LBE200:
 335:main.c        **** 				
 3150               		.loc 3 335 0
 3151 0324 9FEF      		ldi r25,-1
 3152 0326 C91A      		sub r12,r25
 3153 0328 D90A      		sbc r13,r25
 3154 032a E90A      		sbc r14,r25
 3155 032c F90A      		sbc r15,r25
 3156               	.LVL288:
 337:main.c        **** 				receivedChar = USART_Receive();
 3157               		.loc 3 337 0
 3158 032e 9398      		cbi 0x12,3
 338:main.c        **** 			}
 3159               		.loc 3 338 0
 3160 0330 00D0      		rcall USART_Receive
 3161               	.LVL289:
 3162 0332 8093 0000 		sts receivedChar,r24
 3163 0336 00C0      		rjmp .L132
 3164               	.LVL290:
 3165               	.L131:
 345:main.c        **** 			gba_eeprom_mode();
 3166               		.loc 3 345 0
 3167 0338 8037      		cpi r24,lo8(112)
 3168 033a 01F4      		brne .L135
 346:main.c        **** 			
 3169               		.loc 3 346 0
 3170 033c 00D0      		rcall gba_eeprom_mode
 3171               	.LVL291:
 3172 033e 00E0      		ldi r16,lo8(eepromBuffer)
 3173 0340 10E0      		ldi r17,hi8(eepromBuffer)
 3174               	.LVL292:
 3175               	.L136:
 3176               	.LBB201:
 350:main.c        **** 			}
 3177               		.loc 3 350 0 discriminator 3
 3178 0342 00D0      		rcall USART_Receive
 3179               	.LVL293:
 3180 0344 F801      		movw r30,r16
 3181 0346 8193      		st Z+,r24
 3182 0348 8F01      		movw r16,r30
 3183               	.LVL294:
 349:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3184               		.loc 3 349 0 discriminator 3
 3185 034a 80E0      		ldi r24,lo8(eepromBuffer+8)
 3186 034c 90E0      		ldi r25,hi8(eepromBuffer+8)
 3187 034e 8E17      		cp r24,r30
 3188 0350 9F07      		cpc r25,r31
 3189 0352 01F4      		brne .L136
 3190               	.LBE201:
 352:main.c        **** 			
 3191               		.loc 3 352 0
 3192 0354 939A      		sbi 0x12,3
 354:main.c        **** 			address++;
 3193               		.loc 3 354 0
 3194 0356 6D2F      		mov r22,r29
 3195 0358 C601      		movw r24,r12
 3196 035a 00D0      		rcall gba_eeprom_write
 3197               	.LVL295:
 355:main.c        **** 			
 3198               		.loc 3 355 0
 3199 035c 9FEF      		ldi r25,-1
 3200 035e C91A      		sub r12,r25
 3201 0360 D90A      		sbc r13,r25
 3202 0362 E90A      		sbc r14,r25
 3203 0364 F90A      		sbc r15,r25
 3204               	.LVL296:
 3205               	.LBB202:
 3206               	.LBB203:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3207               		.loc 2 187 0
 3208 0366 EFE7      		ldi r30,lo8(15999)
 3209 0368 FEE3      		ldi r31,hi8(15999)
 3210 036a 3197      	1:	sbiw r30,1
 3211 036c 01F4      		brne 1b
 3212 036e 00C0      		rjmp .
 3213 0370 0000      		nop
 3214               	.LVL297:
 3215 0372 00C0      		rjmp .L249
 3216               	.LVL298:
 3217               	.L135:
 3218               	.LBE203:
 3219               	.LBE202:
 367:main.c        **** 			flashWriteWePin = USART_Receive();
 3220               		.loc 3 367 0
 3221 0374 8035      		cpi r24,lo8(80)
 3222 0376 01F4      		brne .L137
 368:main.c        **** 			
 3223               		.loc 3 368 0
 3224 0378 00D0      		rcall USART_Receive
 3225               	.LVL299:
 3226 037a 8093 0000 		sts flashWriteWePin,r24
 370:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3227               		.loc 3 370 0
 3228 037e 8134      		cpi r24,lo8(65)
 3229 0380 01F0      		breq .+2
 3230 0382 00C0      		rjmp .L95
 371:main.c        **** 				audioPin_high;
 3231               		.loc 3 371 0
 3232 0384 319A      		sbi 0x6,1
 372:main.c        **** 			}
 3233               		.loc 3 372 0
 3234 0386 399A      		sbi 0x7,1
 3235 0388 00C0      		rjmp .L95
 3236               	.L137:
 377:main.c        **** 			flashBank1CommandWrites = 1;
 3237               		.loc 3 377 0
 3238 038a 8E34      		cpi r24,lo8(78)
 3239 038c 01F4      		brne .L138
 378:main.c        **** 		}
 3240               		.loc 3 378 0
 3241 038e 81E0      		ldi r24,lo8(1)
 3242 0390 8093 0000 		sts flashBank1CommandWrites,r24
 3243 0394 00C0      		rjmp .L95
 3244               	.L138:
 382:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 3245               		.loc 3 382 0
 3246 0396 8534      		cpi r24,lo8(69)
 3247 0398 01F4      		brne .L139
 3248 039a 00E0      		ldi r16,lo8(flashWriteCycle)
 3249 039c 10E0      		ldi r17,hi8(flashWriteCycle)
 3250               	.L140:
 3251               	.LBB204:
 384:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3252               		.loc 3 384 0 discriminator 3
 3253 039e 00D0      		rcall usart_read_chars
 3254               	.LVL300:
 385:main.c        **** 				USART_Transmit(SEND_ACK);
 3255               		.loc 3 385 0 discriminator 3
 3256 03a0 40E1      		ldi r20,lo8(16)
 3257 03a2 50E0      		ldi r21,0
 3258 03a4 60E0      		ldi r22,0
 3259 03a6 70E0      		ldi r23,0
 3260 03a8 80E0      		ldi r24,lo8(receivedBuffer)
 3261 03aa 90E0      		ldi r25,hi8(receivedBuffer)
 3262 03ac 00D0      		rcall strtol
 3263               	.LVL301:
 3264 03ae F801      		movw r30,r16
 3265 03b0 7183      		std Z+1,r23
 3266 03b2 6083      		st Z,r22
 386:main.c        **** 				
 3267               		.loc 3 386 0 discriminator 3
 3268 03b4 81E3      		ldi r24,lo8(49)
 3269 03b6 00D0      		rcall USART_Transmit
 3270               	.LVL302:
 388:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3271               		.loc 3 388 0 discriminator 3
 3272 03b8 00D0      		rcall usart_read_chars
 3273               	.LVL303:
 389:main.c        **** 				USART_Transmit(SEND_ACK);
 3274               		.loc 3 389 0 discriminator 3
 3275 03ba 40E1      		ldi r20,lo8(16)
 3276 03bc 50E0      		ldi r21,0
 3277 03be 60E0      		ldi r22,0
 3278 03c0 70E0      		ldi r23,0
 3279 03c2 80E0      		ldi r24,lo8(receivedBuffer)
 3280 03c4 90E0      		ldi r25,hi8(receivedBuffer)
 3281 03c6 00D0      		rcall strtol
 3282               	.LVL304:
 3283 03c8 F801      		movw r30,r16
 3284 03ca 7383      		std Z+3,r23
 3285 03cc 6283      		std Z+2,r22
 390:main.c        **** 			}
 3286               		.loc 3 390 0 discriminator 3
 3287 03ce 81E3      		ldi r24,lo8(49)
 3288 03d0 00D0      		rcall USART_Transmit
 3289               	.LVL305:
 3290 03d2 0C5F      		subi r16,-4
 3291 03d4 1F4F      		sbci r17,-1
 383:main.c        **** 				usart_read_chars(); // Address
 3292               		.loc 3 383 0 discriminator 3
 3293 03d6 80E0      		ldi r24,lo8(flashWriteCycle+12)
 3294 03d8 90E0      		ldi r25,hi8(flashWriteCycle+12)
 3295 03da 8017      		cp r24,r16
 3296 03dc 9107      		cpc r25,r17
 3297 03de 01F4      		brne .L140
 3298 03e0 00C0      		rjmp .L95
 3299               	.L139:
 3300               	.LBE204:
 395:main.c        **** 			usart_read_chars(); // Read address
 3301               		.loc 3 395 0
 3302 03e2 8634      		cpi r24,lo8(70)
 3303 03e4 01F4      		brne .L141
 3304               	.LBB205:
 396:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3305               		.loc 3 396 0
 3306 03e6 00D0      		rcall usart_read_chars
 3307               	.LVL306:
 397:main.c        **** 			
 3308               		.loc 3 397 0
 3309 03e8 40E1      		ldi r20,lo8(16)
 3310 03ea 50E0      		ldi r21,0
 3311 03ec 60E0      		ldi r22,0
 3312 03ee 70E0      		ldi r23,0
 3313 03f0 80E0      		ldi r24,lo8(receivedBuffer)
 3314 03f2 90E0      		ldi r25,hi8(receivedBuffer)
 3315 03f4 00D0      		rcall strtol
 3316               	.LVL307:
 3317 03f6 4B01      		movw r8,r22
 3318 03f8 5C01      		movw r10,r24
 3319               	.LVL308:
 399:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3320               		.loc 3 399 0
 3321 03fa 00D0      		rcall usart_read_chars
 3322               	.LVL309:
 400:main.c        **** 			
 3323               		.loc 3 400 0
 3324 03fc 40E1      		ldi r20,lo8(16)
 3325 03fe 50E0      		ldi r21,0
 3326 0400 60E0      		ldi r22,0
 3327 0402 70E0      		ldi r23,0
 3328 0404 80E0      		ldi r24,lo8(receivedBuffer)
 3329 0406 90E0      		ldi r25,hi8(receivedBuffer)
 3330 0408 00D0      		rcall strtol
 3331               	.LVL310:
 402:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3332               		.loc 3 402 0
 3333 040a 939A      		sbi 0x12,3
 403:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3334               		.loc 3 403 0
 3335 040c C401      		movw r24,r8
 3336 040e 00D0      		rcall gb_flash_write_bus_cycle
 3337               	.LVL311:
 3338 0410 00C0      		rjmp .L264
 3339               	.LVL312:
 3340               	.L141:
 3341               	.LBE205:
 410:main.c        **** 			usart_read_bytes(64);
 3342               		.loc 3 410 0
 3343 0412 8435      		cpi r24,lo8(84)
 3344 0414 01F4      		brne .L142
 411:main.c        **** 			
 3345               		.loc 3 411 0
 3346 0416 80E4      		ldi r24,lo8(64)
 3347 0418 90E0      		ldi r25,0
 3348 041a 00D0      		rcall usart_read_bytes
 3349               	.LVL313:
 413:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3350               		.loc 3 413 0
 3351 041c 939A      		sbi 0x12,3
 3352               	.LVL314:
 3353 041e A0E0      		ldi r26,lo8(receivedBuffer)
 3354 0420 AA2E      		mov r10,r26
 3355 0422 A0E0      		ldi r26,hi8(receivedBuffer)
 3356 0424 BA2E      		mov r11,r26
 3357 0426 B0E4      		ldi r27,lo8(64)
 3358 0428 9B2E      		mov r9,r27
 3359 042a 8601      		movw r16,r12
 3360 042c 0050      		subi r16,lo8(receivedBuffer)
 3361 042e 1040      		sbci r17,hi8(receivedBuffer)
 3362               	.LVL315:
 3363               	.L145:
 3364               	.LBB206:
 415:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3365               		.loc 3 415 0
 3366 0430 8091 0000 		lds r24,flashBank1CommandWrites
 416:main.c        **** 				}
 3367               		.loc 3 416 0
 3368 0434 F501      		movw r30,r10
 3369 0436 6081      		ld r22,Z
 415:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3370               		.loc 3 415 0
 3371 0438 8111      		cpse r24,__zero_reg__
 3372 043a 00C0      		rjmp .L143
 416:main.c        **** 				}
 3373               		.loc 3 416 0
 3374 043c C801      		movw r24,r16
 3375 043e 8A0D      		add r24,r10
 3376 0440 9B1D      		adc r25,r11
 3377 0442 00D0      		rcall gb_flash_write_byte
 3378               	.LVL316:
 3379 0444 00C0      		rjmp .L144
 3380               	.L143:
 419:main.c        **** 				}
 3381               		.loc 3 419 0
 3382 0446 C801      		movw r24,r16
 3383 0448 8A0D      		add r24,r10
 3384 044a 9B1D      		adc r25,r11
 3385 044c 00D0      		rcall gb_flash_write_byte_bank1_commands
 3386               	.LVL317:
 3387               	.L144:
 3388 044e 9A94      		dec r9
 3389 0450 FFEF      		ldi r31,-1
 3390 0452 AF1A      		sub r10,r31
 3391 0454 BF0A      		sbc r11,r31
 3392               	.LVL318:
 414:main.c        **** 				if (flashBank1CommandWrites == 0) {
 3393               		.loc 3 414 0 discriminator 2
 3394 0456 9110      		cpse r9,__zero_reg__
 3395 0458 00C0      		rjmp .L145
 3396 045a 20E4      		ldi r18,64
 3397 045c C20E      		add r12,r18
 3398 045e D11C      		adc r13,__zero_reg__
 3399 0460 E11C      		adc r14,__zero_reg__
 3400 0462 F11C      		adc r15,__zero_reg__
 3401 0464 00C0      		rjmp .L253
 3402               	.LVL319:
 3403               	.L142:
 3404               	.LBE206:
 429:main.c        **** 			usart_read_bytes(32);
 3405               		.loc 3 429 0
 3406 0466 8935      		cpi r24,lo8(89)
 3407 0468 01F0      		breq .+2
 3408 046a 00C0      		rjmp .L146
 3409               	.LBB207:
 430:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3410               		.loc 3 430 0
 3411 046c 80E2      		ldi r24,lo8(32)
 3412 046e 90E0      		ldi r25,0
 3413 0470 00D0      		rcall usart_read_bytes
 3414               	.LVL320:
 431:main.c        **** 			
 3415               		.loc 3 431 0
 3416 0472 939A      		sbi 0x12,3
 434:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3417               		.loc 3 434 0
 3418 0474 6AEA      		ldi r22,lo8(-86)
 3419 0476 8AEA      		ldi r24,lo8(-86)
 3420 0478 9AE0      		ldi r25,lo8(10)
 3421 047a 00D0      		rcall gb_flash_write_bus_cycle
 3422               	.LVL321:
 435:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3423               		.loc 3 435 0
 3424 047c 65E5      		ldi r22,lo8(85)
 3425 047e 85E5      		ldi r24,lo8(85)
 3426 0480 95E0      		ldi r25,lo8(5)
 3427 0482 00D0      		rcall gb_flash_write_bus_cycle
 3428               	.LVL322:
 436:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3429               		.loc 3 436 0
 3430 0484 5601      		movw r10,r12
 3431 0486 65E2      		ldi r22,lo8(37)
 3432 0488 C601      		movw r24,r12
 3433 048a 00D0      		rcall gb_flash_write_bus_cycle
 3434               	.LVL323:
 437:main.c        **** 			_delay_us(1);
 3435               		.loc 3 437 0
 3436 048c 6FE1      		ldi r22,lo8(31)
 3437 048e C601      		movw r24,r12
 3438 0490 00D0      		rcall gb_flash_write_bus_cycle
 3439               	.LVL324:
 3440               	.LBB208:
 3441               	.LBB209:
 3442               		.loc 2 276 0
 3443 0492 82E0      		ldi r24,lo8(2)
 3444 0494 8A95      	1:	dec r24
 3445 0496 01F4      		brne 1b
 3446 0498 00C0      		rjmp .
 3447               	.LVL325:
 3448 049a 00E0      		ldi r16,lo8(receivedBuffer)
 3449 049c 10E0      		ldi r17,hi8(receivedBuffer)
 3450 049e 812C      		mov r8,__zero_reg__
 3451 04a0 912C      		mov r9,__zero_reg__
 3452               	.LVL326:
 3453               	.L147:
 3454               	.LBE209:
 3455               	.LBE208:
 3456               	.LBB210:
 442:main.c        **** 				address++;
 3457               		.loc 3 442 0 discriminator 3
 3458 04a2 F801      		movw r30,r16
 3459 04a4 6191      		ld r22,Z+
 3460 04a6 8F01      		movw r16,r30
 3461 04a8 C401      		movw r24,r8
 3462 04aa 8A0D      		add r24,r10
 3463 04ac 9B1D      		adc r25,r11
 3464 04ae 00D0      		rcall gb_flash_write_bus_cycle
 3465               	.LVL327:
 3466 04b0 FFEF      		ldi r31,-1
 3467 04b2 8F1A      		sub r8,r31
 3468 04b4 9F0A      		sbc r9,r31
 3469               	.LVL328:
 441:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3470               		.loc 3 441 0 discriminator 3
 3471 04b6 20E2      		ldi r18,32
 3472 04b8 8216      		cp r8,r18
 3473 04ba 9104      		cpc r9,__zero_reg__
 3474 04bc 01F4      		brne .L147
 3475 04be 80E2      		ldi r24,32
 3476 04c0 C80E      		add r12,r24
 3477 04c2 D11C      		adc r13,__zero_reg__
 3478 04c4 E11C      		adc r14,__zero_reg__
 3479 04c6 F11C      		adc r15,__zero_reg__
 3480               	.LBE210:
 447:main.c        **** 			_delay_us(200);
 3481               		.loc 3 447 0
 3482 04c8 C601      		movw r24,r12
 3483 04ca 8097      		sbiw r24,32
 3484 04cc 69E2      		ldi r22,lo8(41)
 3485 04ce 00D0      		rcall gb_flash_write_bus_cycle
 3486               	.LVL329:
 3487               	.LBB211:
 3488               	.LBB212:
 3489               		.loc 2 276 0
 3490 04d0 EFE8      		ldi r30,lo8(399)
 3491 04d2 F1E0      		ldi r31,hi8(399)
 3492 04d4 3197      	1:	sbiw r30,1
 3493 04d6 01F4      		brne 1b
 3494 04d8 00C0      		rjmp .
 3495 04da 0000      		nop
 3496               	.LVL330:
 3497               	.LBE212:
 3498               	.LBE211:
 451:main.c        **** 			uint8_t verifyCount = 0;
 3499               		.loc 3 451 0
 3500 04dc 8601      		movw r16,r12
 3501 04de 0150      		subi r16,1
 3502 04e0 1109      		sbc r17,__zero_reg__
 3503 04e2 C801      		movw r24,r16
 3504 04e4 00D0      		rcall gb_flash_read_byte
 3505               	.LVL331:
 453:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3506               		.loc 3 453 0
 3507 04e6 F8EC      		ldi r31,lo8(-56)
 3508 04e8 BF2E      		mov r11,r31
 3509               	.LVL332:
 3510               	.L148:
 3511 04ea 9091 0000 		lds r25,receivedBuffer+31
 3512 04ee 8917      		cp r24,r25
 3513 04f0 01F4      		brne .+2
 3514 04f2 00C0      		rjmp .L253
 454:main.c        **** 				_delay_us(5);
 3515               		.loc 3 454 0
 3516 04f4 C801      		movw r24,r16
 3517               	.LVL333:
 3518 04f6 00D0      		rcall gb_flash_read_byte
 3519               	.LVL334:
 3520               	.LBB213:
 3521               	.LBB214:
 3522               		.loc 2 276 0
 3523 04f8 FDE0      		ldi r31,lo8(13)
 3524 04fa FA95      	1:	dec r31
 3525 04fc 01F4      		brne 1b
 3526 04fe 0000      		nop
 3527               	.LVL335:
 3528 0500 BA94      		dec r11
 3529               	.LVL336:
 3530               	.LBE214:
 3531               	.LBE213:
 457:main.c        **** 					_delay_ms(500);
 3532               		.loc 3 457 0
 3533 0502 B110      		cpse r11,__zero_reg__
 3534 0504 00C0      		rjmp .L148
 3535               	.LVL337:
 3536               	.LBB215:
 3537               	.LBB216:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3538               		.loc 2 187 0
 3539 0506 2FEF      		ldi r18,lo8(799999)
 3540 0508 84E3      		ldi r24,hi8(799999)
 3541 050a 9CE0      		ldi r25,hlo8(799999)
 3542 050c 2150      	1:	subi r18,1
 3543 050e 8040      		sbci r24,0
 3544 0510 9040      		sbci r25,0
 3545 0512 01F4      		brne 1b
 3546               	.LVL338:
 3547 0514 00C0      		rjmp .L265
 3548               	.LVL339:
 3549               	.L146:
 3550               	.LBE216:
 3551               	.LBE215:
 3552               	.LBE207:
 468:main.c        **** 			usart_read_bytes(64);
 3553               		.loc 3 468 0
 3554 0516 8A34      		cpi r24,lo8(74)
 3555 0518 01F4      		brne .L151
 469:main.c        **** 			
 3556               		.loc 3 469 0
 3557 051a 80E4      		ldi r24,lo8(64)
 3558 051c 90E0      		ldi r25,0
 3559 051e 00D0      		rcall usart_read_bytes
 3560               	.LVL340:
 471:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3561               		.loc 3 471 0
 3562 0520 939A      		sbi 0x12,3
 3563               	.LVL341:
 3564 0522 E0E0      		ldi r30,lo8(receivedBuffer)
 3565 0524 AE2E      		mov r10,r30
 3566 0526 E0E0      		ldi r30,hi8(receivedBuffer)
 3567 0528 BE2E      		mov r11,r30
 3568 052a 00E0      		ldi r16,0
 3569 052c 10E0      		ldi r17,0
 3570               	.LVL342:
 3571               	.L153:
 3572               	.LBB217:
 473:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 3573               		.loc 3 473 0
 3574 052e F501      		movw r30,r10
 3575 0530 6191      		ld r22,Z+
 3576 0532 5F01      		movw r10,r30
 3577 0534 6F3F      		cpi r22,lo8(-1)
 3578 0536 01F0      		breq .L152
 474:main.c        **** 				}
 3579               		.loc 3 474 0
 3580 0538 C801      		movw r24,r16
 3581 053a 8C0D      		add r24,r12
 3582 053c 9D1D      		adc r25,r13
 3583 053e 00D0      		rcall gb_flash_write_byte_special
 3584               	.LVL343:
 3585               	.L152:
 3586 0540 0F5F      		subi r16,-1
 3587 0542 1F4F      		sbci r17,-1
 3588               	.LVL344:
 472:main.c        **** 				if (receivedBuffer[x] != 0xFF) { // No need to program 0xFF, skip
 3589               		.loc 3 472 0 discriminator 2
 3590 0544 0034      		cpi r16,64
 3591 0546 1105      		cpc r17,__zero_reg__
 3592 0548 01F4      		brne .L153
 3593 054a F0E4      		ldi r31,64
 3594 054c CF0E      		add r12,r31
 3595 054e D11C      		adc r13,__zero_reg__
 3596 0550 E11C      		adc r14,__zero_reg__
 3597 0552 F11C      		adc r15,__zero_reg__
 3598 0554 00C0      		rjmp .L253
 3599               	.LVL345:
 3600               	.L151:
 3601               	.LBE217:
 484:main.c        **** 			usart_read_bytes(256);
 3602               		.loc 3 484 0
 3603 0556 8835      		cpi r24,lo8(88)
 3604 0558 01F0      		breq .+2
 3605 055a 00C0      		rjmp .L154
 3606               	.LBB218:
 485:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3607               		.loc 3 485 0
 3608 055c 80E0      		ldi r24,0
 3609 055e 91E0      		ldi r25,lo8(1)
 3610 0560 00D0      		rcall usart_read_bytes
 3611               	.LVL346:
 486:main.c        **** 			
 3612               		.loc 3 486 0
 3613 0562 939A      		sbi 0x12,3
 489:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3614               		.loc 3 489 0
 3615 0564 69EA      		ldi r22,lo8(-87)
 3616 0566 8AEA      		ldi r24,lo8(-86)
 3617 0568 9AE0      		ldi r25,lo8(10)
 3618 056a 00D0      		rcall gb_flash_write_bus_cycle
 3619               	.LVL347:
 490:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3620               		.loc 3 490 0
 3621 056c 66E5      		ldi r22,lo8(86)
 3622 056e 85E5      		ldi r24,lo8(85)
 3623 0570 95E0      		ldi r25,lo8(5)
 3624 0572 00D0      		rcall gb_flash_write_bus_cycle
 3625               	.LVL348:
 491:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3626               		.loc 3 491 0
 3627 0574 5601      		movw r10,r12
 3628 0576 66E2      		ldi r22,lo8(38)
 3629 0578 C601      		movw r24,r12
 3630 057a 00D0      		rcall gb_flash_write_bus_cycle
 3631               	.LVL349:
 492:main.c        **** 			_delay_us(50);
 3632               		.loc 3 492 0
 3633 057c 6FEF      		ldi r22,lo8(-1)
 3634 057e C601      		movw r24,r12
 3635 0580 00D0      		rcall gb_flash_write_bus_cycle
 3636               	.LVL350:
 3637               	.LBB219:
 3638               	.LBB220:
 3639               		.loc 2 276 0
 3640 0582 25E8      		ldi r18,lo8(-123)
 3641 0584 2A95      	1:	dec r18
 3642 0586 01F4      		brne 1b
 3643 0588 0000      		nop
 3644               	.LVL351:
 3645 058a 00E0      		ldi r16,lo8(receivedBuffer)
 3646 058c 10E0      		ldi r17,hi8(receivedBuffer)
 3647               	.LBE220:
 3648               	.LBE219:
 3649               	.LBB221:
 496:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3650               		.loc 3 496 0
 3651 058e 812C      		mov r8,__zero_reg__
 3652 0590 912C      		mov r9,__zero_reg__
 3653               	.LVL352:
 3654               	.L155:
 497:main.c        **** 				address++;
 3655               		.loc 3 497 0 discriminator 3
 3656 0592 F801      		movw r30,r16
 3657 0594 6191      		ld r22,Z+
 3658 0596 8F01      		movw r16,r30
 3659 0598 C401      		movw r24,r8
 3660 059a 8A0D      		add r24,r10
 3661 059c 9B1D      		adc r25,r11
 3662 059e 00D0      		rcall gb_flash_write_bus_cycle
 3663               	.LVL353:
 496:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3664               		.loc 3 496 0 discriminator 3
 3665 05a0 FFEF      		ldi r31,-1
 3666 05a2 8F1A      		sub r8,r31
 3667 05a4 9F0A      		sbc r9,r31
 3668               	.LVL354:
 3669 05a6 8114      		cp r8,__zero_reg__
 3670 05a8 21E0      		ldi r18,1
 3671 05aa 9206      		cpc r9,r18
 3672 05ac 01F4      		brne .L155
 3673 05ae 8FEF      		ldi r24,-1
 3674 05b0 D81A      		sub r13,r24
 3675 05b2 E80A      		sbc r14,r24
 3676 05b4 F80A      		sbc r15,r24
 3677               	.LBE221:
 502:main.c        **** 			
 3678               		.loc 3 502 0
 3679 05b6 C601      		movw r24,r12
 3680 05b8 9A95      		dec r25
 3681 05ba 6AE2      		ldi r22,lo8(42)
 3682 05bc 00D0      		rcall gb_flash_write_bus_cycle
 3683               	.LVL355:
 505:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 3684               		.loc 3 505 0
 3685 05be 8601      		movw r16,r12
 3686 05c0 0150      		subi r16,1
 3687 05c2 1109      		sbc r17,__zero_reg__
 3688 05c4 C801      		movw r24,r16
 3689 05c6 00D0      		rcall gb_flash_read_byte
 3690               	.LVL356:
 3691               	.L156:
 506:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3692               		.loc 3 506 0
 3693 05c8 9091 0000 		lds r25,receivedBuffer+255
 3694 05cc 8917      		cp r24,r25
 3695 05ce 01F4      		brne .+2
 3696 05d0 00C0      		rjmp .L253
 507:main.c        **** 				_delay_us(5);
 3697               		.loc 3 507 0
 3698 05d2 C801      		movw r24,r16
 3699               	.LVL357:
 3700 05d4 00D0      		rcall gb_flash_read_byte
 3701               	.LVL358:
 3702               	.LBB222:
 3703               	.LBB223:
 3704               		.loc 2 276 0
 3705 05d6 9DE0      		ldi r25,lo8(13)
 3706 05d8 9A95      	1:	dec r25
 3707 05da 01F4      		brne 1b
 3708 05dc 0000      		nop
 3709 05de 00C0      		rjmp .L156
 3710               	.LVL359:
 3711               	.L154:
 3712               	.LBE223:
 3713               	.LBE222:
 3714               	.LBE218:
 516:main.c        **** 			usart_read_bytes(128);
 3715               		.loc 3 516 0
 3716 05e0 8A35      		cpi r24,lo8(90)
 3717 05e2 01F0      		breq .+2
 3718 05e4 00C0      		rjmp .L158
 517:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3719               		.loc 3 517 0
 3720 05e6 80E8      		ldi r24,lo8(-128)
 3721 05e8 90E0      		ldi r25,0
 3722 05ea 00D0      		rcall usart_read_bytes
 3723               	.LVL360:
 518:main.c        **** 			
 3724               		.loc 3 518 0
 3725 05ec 939A      		sbi 0x12,3
 521:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 3726               		.loc 3 521 0
 3727 05ee 69E0      		ldi r22,lo8(9)
 3728 05f0 80E2      		ldi r24,lo8(32)
 3729 05f2 91E0      		ldi r25,lo8(1)
 3730 05f4 00D0      		rcall gb_flash_write_bus_cycle
 3731               	.LVL361:
 522:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 3732               		.loc 3 522 0
 3733 05f6 6AEA      		ldi r22,lo8(-86)
 3734 05f8 81E2      		ldi r24,lo8(33)
 3735 05fa 91E0      		ldi r25,lo8(1)
 3736 05fc 00D0      		rcall gb_flash_write_bus_cycle
 3737               	.LVL362:
 523:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3738               		.loc 3 523 0
 3739 05fe 65E5      		ldi r22,lo8(85)
 3740 0600 82E2      		ldi r24,lo8(34)
 3741 0602 91E0      		ldi r25,lo8(1)
 3742 0604 00D0      		rcall gb_flash_write_bus_cycle
 3743               	.LVL363:
 524:main.c        **** 			_delay_us(5);
 3744               		.loc 3 524 0
 3745 0606 65EA      		ldi r22,lo8(-91)
 3746 0608 8FE3      		ldi r24,lo8(63)
 3747 060a 91E0      		ldi r25,lo8(1)
 3748 060c 00D0      		rcall gb_flash_write_bus_cycle
 3749               	.LVL364:
 3750               	.LBB224:
 3751               	.LBB225:
 3752               		.loc 2 276 0
 3753 060e EDE0      		ldi r30,lo8(13)
 3754 0610 EA95      	1:	dec r30
 3755 0612 01F4      		brne 1b
 3756 0614 0000      		nop
 3757               	.LVL365:
 3758               	.LBE225:
 3759               	.LBE224:
 528:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3760               		.loc 3 528 0
 3761 0616 61E1      		ldi r22,lo8(17)
 3762 0618 80E2      		ldi r24,lo8(32)
 3763 061a 91E0      		ldi r25,lo8(1)
 3764 061c 00D0      		rcall gb_flash_write_bus_cycle
 3765               	.LVL366:
 529:main.c        **** 			_delay_us(5);
 3766               		.loc 3 529 0
 3767 061e 65EA      		ldi r22,lo8(-91)
 3768 0620 8FE3      		ldi r24,lo8(63)
 3769 0622 91E0      		ldi r25,lo8(1)
 3770 0624 00D0      		rcall gb_flash_write_bus_cycle
 3771               	.LVL367:
 3772               	.LBB226:
 3773               	.LBB227:
 3774               		.loc 2 276 0
 3775 0626 FDE0      		ldi r31,lo8(13)
 3776 0628 FA95      	1:	dec r31
 3777 062a 01F4      		brne 1b
 3778 062c 0000      		nop
 3779               	.LVL368:
 3780               	.LBE227:
 3781               	.LBE226:
 533:main.c        **** 			_delay_us(5);
 3782               		.loc 3 533 0
 3783 062e 61E0      		ldi r22,lo8(1)
 3784 0630 80E0      		ldi r24,0
 3785 0632 91E2      		ldi r25,lo8(33)
 3786 0634 00D0      		rcall gb_flash_write_bus_cycle
 3787               	.LVL369:
 3788               	.LBB228:
 3789               	.LBB229:
 3790               		.loc 2 276 0
 3791 0636 2DE0      		ldi r18,lo8(13)
 3792 0638 2A95      	1:	dec r18
 3793 063a 01F4      		brne 1b
 3794 063c 0000      		nop
 3795               	.LVL370:
 3796               	.LBE229:
 3797               	.LBE228:
 538:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3798               		.loc 3 538 0
 3799 063e 6FE0      		ldi r22,lo8(15)
 3800 0640 80E2      		ldi r24,lo8(32)
 3801 0642 91E0      		ldi r25,lo8(1)
 3802 0644 00D0      		rcall gb_flash_write_bus_cycle
 3803               	.LVL371:
 539:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3804               		.loc 3 539 0
 3805 0646 65E5      		ldi r22,lo8(85)
 3806 0648 85E2      		ldi r24,lo8(37)
 3807 064a 91E0      		ldi r25,lo8(1)
 3808 064c 00D0      		rcall gb_flash_write_bus_cycle
 3809               	.LVL372:
 540:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 3810               		.loc 3 540 0
 3811 064e 65E5      		ldi r22,lo8(85)
 3812 0650 86E2      		ldi r24,lo8(38)
 3813 0652 91E0      		ldi r25,lo8(1)
 3814 0654 00D0      		rcall gb_flash_write_bus_cycle
 3815               	.LVL373:
 541:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3816               		.loc 3 541 0
 3817 0656 6AEA      		ldi r22,lo8(-86)
 3818 0658 87E2      		ldi r24,lo8(39)
 3819 065a 91E0      		ldi r25,lo8(1)
 3820 065c 00D0      		rcall gb_flash_write_bus_cycle
 3821               	.LVL374:
 542:main.c        **** 			_delay_us(5);
 3822               		.loc 3 542 0
 3823 065e 65EA      		ldi r22,lo8(-91)
 3824 0660 8FE3      		ldi r24,lo8(63)
 3825 0662 91E0      		ldi r25,lo8(1)
 3826 0664 00D0      		rcall gb_flash_write_bus_cycle
 3827               	.LVL375:
 3828               	.LBB230:
 3829               	.LBB231:
 3830               		.loc 2 276 0
 3831 0666 8DE0      		ldi r24,lo8(13)
 3832 0668 8A95      	1:	dec r24
 3833 066a 01F4      		brne 1b
 3834 066c 0000      		nop
 3835               	.LVL376:
 3836               	.LBE231:
 3837               	.LBE230:
 545:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 3838               		.loc 3 545 0
 3839 066e 6FE0      		ldi r22,lo8(15)
 3840 0670 80E2      		ldi r24,lo8(32)
 3841 0672 91E0      		ldi r25,lo8(1)
 3842 0674 00D0      		rcall gb_flash_write_bus_cycle
 3843               	.LVL377:
 546:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 3844               		.loc 3 546 0
 3845 0676 6AE2      		ldi r22,lo8(42)
 3846 0678 85E2      		ldi r24,lo8(37)
 3847 067a 91E0      		ldi r25,lo8(1)
 3848 067c 00D0      		rcall gb_flash_write_bus_cycle
 3849               	.LVL378:
 547:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 3850               		.loc 3 547 0
 3851 067e 6AEA      		ldi r22,lo8(-86)
 3852 0680 86E2      		ldi r24,lo8(38)
 3853 0682 91E0      		ldi r25,lo8(1)
 3854 0684 00D0      		rcall gb_flash_write_bus_cycle
 3855               	.LVL379:
 548:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3856               		.loc 3 548 0
 3857 0686 65E5      		ldi r22,lo8(85)
 3858 0688 87E2      		ldi r24,lo8(39)
 3859 068a 91E0      		ldi r25,lo8(1)
 3860 068c 00D0      		rcall gb_flash_write_bus_cycle
 3861               	.LVL380:
 549:main.c        **** 			_delay_us(5);
 3862               		.loc 3 549 0
 3863 068e 65EA      		ldi r22,lo8(-91)
 3864 0690 8FE3      		ldi r24,lo8(63)
 3865 0692 91E0      		ldi r25,lo8(1)
 3866 0694 00D0      		rcall gb_flash_write_bus_cycle
 3867               	.LVL381:
 3868               	.LBB232:
 3869               	.LBB233:
 3870               		.loc 2 276 0
 3871 0696 9DE0      		ldi r25,lo8(13)
 3872 0698 9A95      	1:	dec r25
 3873 069a 01F4      		brne 1b
 3874 069c 0000      		nop
 3875               	.LVL382:
 3876               	.LBE233:
 3877               	.LBE232:
 552:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3878               		.loc 3 552 0
 3879 069e 6FE0      		ldi r22,lo8(15)
 3880 06a0 80E2      		ldi r24,lo8(32)
 3881 06a2 91E0      		ldi r25,lo8(1)
 3882 06a4 00D0      		rcall gb_flash_write_bus_cycle
 3883               	.LVL383:
 553:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3884               		.loc 3 553 0
 3885 06a6 65E5      		ldi r22,lo8(85)
 3886 06a8 85E2      		ldi r24,lo8(37)
 3887 06aa 91E0      		ldi r25,lo8(1)
 3888 06ac 00D0      		rcall gb_flash_write_bus_cycle
 3889               	.LVL384:
 554:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 3890               		.loc 3 554 0
 3891 06ae 65E5      		ldi r22,lo8(85)
 3892 06b0 86E2      		ldi r24,lo8(38)
 3893 06b2 91E0      		ldi r25,lo8(1)
 3894 06b4 00D0      		rcall gb_flash_write_bus_cycle
 3895               	.LVL385:
 555:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3896               		.loc 3 555 0
 3897 06b6 60EA      		ldi r22,lo8(-96)
 3898 06b8 87E2      		ldi r24,lo8(39)
 3899 06ba 91E0      		ldi r25,lo8(1)
 3900 06bc 00D0      		rcall gb_flash_write_bus_cycle
 3901               	.LVL386:
 556:main.c        **** 			_delay_us(5);
 3902               		.loc 3 556 0
 3903 06be 65EA      		ldi r22,lo8(-91)
 3904 06c0 8FE3      		ldi r24,lo8(63)
 3905 06c2 91E0      		ldi r25,lo8(1)
 3906 06c4 00D0      		rcall gb_flash_write_bus_cycle
 3907               	.LVL387:
 3908               	.LBB234:
 3909               	.LBB235:
 3910               		.loc 2 276 0
 3911 06c6 EDE0      		ldi r30,lo8(13)
 3912 06c8 EA95      	1:	dec r30
 3913 06ca 01F4      		brne 1b
 3914 06cc 0000      		nop
 3915               	.LVL388:
 3916               	.LBE235:
 3917               	.LBE234:
 560:main.c        **** 			_delay_us(5);
 3918               		.loc 3 560 0
 3919 06ce 40E0      		ldi r20,0
 3920 06d0 6091 0000 		lds r22,lastBankAccessed
 3921 06d4 80E0      		ldi r24,0
 3922 06d6 91E2      		ldi r25,lo8(33)
 3923 06d8 00D0      		rcall write_8bit_data
 3924               	.LVL389:
 3925               	.LBB236:
 3926               	.LBB237:
 3927               		.loc 2 276 0
 3928 06da FDE0      		ldi r31,lo8(13)
 3929 06dc FA95      	1:	dec r31
 3930 06de 01F4      		brne 1b
 3931 06e0 0000      		nop
 3932               	.LVL390:
 3933               	.LBE237:
 3934               	.LBE236:
 564:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3935               		.loc 3 564 0
 3936 06e2 60E1      		ldi r22,lo8(16)
 3937 06e4 80E2      		ldi r24,lo8(32)
 3938 06e6 91E0      		ldi r25,lo8(1)
 3939 06e8 00D0      		rcall gb_flash_write_bus_cycle
 3940               	.LVL391:
 565:main.c        **** 			_delay_us(5);
 3941               		.loc 3 565 0
 3942 06ea 65EA      		ldi r22,lo8(-91)
 3943 06ec 8FE3      		ldi r24,lo8(63)
 3944 06ee 91E0      		ldi r25,lo8(1)
 3945 06f0 00D0      		rcall gb_flash_write_bus_cycle
 3946               	.LVL392:
 3947               	.LBB238:
 3948               	.LBB239:
 3949               		.loc 2 276 0
 3950 06f2 2DE0      		ldi r18,lo8(13)
 3951 06f4 2A95      	1:	dec r18
 3952 06f6 01F4      		brne 1b
 3953 06f8 0000      		nop
 3954               	.LVL393:
 3955               	.LBE239:
 3956               	.LBE238:
 569:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3957               		.loc 3 569 0
 3958 06fa 68E0      		ldi r22,lo8(8)
 3959 06fc 80E2      		ldi r24,lo8(32)
 3960 06fe 91E0      		ldi r25,lo8(1)
 3961 0700 00D0      		rcall gb_flash_write_bus_cycle
 3962               	.LVL394:
 570:main.c        **** 			_delay_us(5);
 3963               		.loc 3 570 0
 3964 0702 65EA      		ldi r22,lo8(-91)
 3965 0704 8FE3      		ldi r24,lo8(63)
 3966 0706 91E0      		ldi r25,lo8(1)
 3967 0708 00D0      		rcall gb_flash_write_bus_cycle
 3968               	.LVL395:
 3969               	.LBB240:
 3970               	.LBB241:
 3971               		.loc 2 276 0
 3972 070a 8DE0      		ldi r24,lo8(13)
 3973 070c 8A95      	1:	dec r24
 3974 070e 01F4      		brne 1b
 3975 0710 0000      		nop
 3976               	.LVL396:
 3977 0712 00E0      		ldi r16,lo8(receivedBuffer)
 3978 0714 10E0      		ldi r17,hi8(receivedBuffer)
 3979               	.L159:
 3980               	.LBE241:
 3981               	.LBE240:
 3982               	.LBB242:
 575:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3983               		.loc 3 575 0 discriminator 1
 3984 0716 80E0      		ldi r24,hi8(receivedBuffer+128)
 3985 0718 0030      		cpi r16,lo8(receivedBuffer+128)
 3986 071a 1807      		cpc r17,r24
 3987 071c 01F0      		breq .L266
 576:main.c        **** 				_delay_us(5);
 3988               		.loc 3 576 0 discriminator 3
 3989 071e F801      		movw r30,r16
 3990 0720 6191      		ld r22,Z+
 3991 0722 8F01      		movw r16,r30
 3992 0724 C601      		movw r24,r12
 3993 0726 00D0      		rcall gb_flash_write_bus_cycle
 3994               	.LVL397:
 3995               	.LBB243:
 3996               	.LBB244:
 3997               		.loc 2 276 0 discriminator 3
 3998 0728 FDE0      		ldi r31,lo8(13)
 3999 072a FA95      	1:	dec r31
 4000 072c 01F4      		brne 1b
 4001 072e 0000      		nop
 4002               	.LVL398:
 4003               	.LBE244:
 4004               	.LBE243:
 578:main.c        **** 			}
 4005               		.loc 3 578 0 discriminator 3
 4006 0730 2FEF      		ldi r18,-1
 4007 0732 C21A      		sub r12,r18
 4008 0734 D20A      		sbc r13,r18
 4009 0736 E20A      		sbc r14,r18
 4010 0738 F20A      		sbc r15,r18
 4011               	.LVL399:
 4012 073a 00C0      		rjmp .L159
 4013               	.L266:
 4014               	.LVL400:
 4015               	.LBE242:
 583:main.c        **** 			address++;
 4016               		.loc 3 583 0
 4017 073c 6FEF      		ldi r22,lo8(-1)
 4018 073e D701      		movw r26,r14
 4019 0740 C601      		movw r24,r12
 4020 0742 0197      		sbiw r24,1
 4021 0744 A109      		sbc r26,__zero_reg__
 4022 0746 B109      		sbc r27,__zero_reg__
 4023               	.LVL401:
 4024 0748 00D0      		rcall gb_flash_write_bus_cycle
 4025               	.LVL402:
 4026               	.LBB245:
 4027               	.LBB246:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 4028               		.loc 2 187 0
 4029 074a EFE1      		ldi r30,lo8(19999)
 4030 074c FEE4      		ldi r31,hi8(19999)
 4031 074e 3197      	1:	sbiw r30,1
 4032 0750 01F4      		brne 1b
 4033               	.LVL403:
 4034               	.L265:
 4035 0752 00C0      		rjmp .
 4036 0754 0000      		nop
 4037 0756 00C0      		rjmp .L253
 4038               	.LVL404:
 4039               	.L158:
 4040               	.LBE246:
 4041               	.LBE245:
 594:main.c        **** 			usart_read_chars(); // Read address
 4042               		.loc 3 594 0
 4043 0758 8E36      		cpi r24,lo8(110)
 4044 075a 01F4      		brne .L161
 4045               	.LBB247:
 595:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 4046               		.loc 3 595 0
 4047 075c 00D0      		rcall usart_read_chars
 4048               	.LVL405:
 596:main.c        **** 			
 4049               		.loc 3 596 0
 4050 075e 40E1      		ldi r20,lo8(16)
 4051 0760 50E0      		ldi r21,0
 4052 0762 60E0      		ldi r22,0
 4053 0764 70E0      		ldi r23,0
 4054 0766 80E0      		ldi r24,lo8(receivedBuffer)
 4055 0768 90E0      		ldi r25,hi8(receivedBuffer)
 4056 076a 00D0      		rcall strtol
 4057               	.LVL406:
 4058 076c 4B01      		movw r8,r22
 4059 076e 5C01      		movw r10,r24
 4060               	.LVL407:
 598:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4061               		.loc 3 598 0
 4062 0770 00D0      		rcall USART_Receive
 4063               	.LVL408:
 4064 0772 8093 0000 		sts receivedChar,r24
 599:main.c        **** 				usart_read_chars(); // Read data
 4065               		.loc 3 599 0
 4066 0776 8E36      		cpi r24,lo8(110)
 4067 0778 01F0      		breq .+2
 4068 077a 00C0      		rjmp .L95
 4069               	.LBB248:
 600:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 4070               		.loc 3 600 0
 4071 077c 00D0      		rcall usart_read_chars
 4072               	.LVL409:
 601:main.c        **** 				
 4073               		.loc 3 601 0
 4074 077e 40E1      		ldi r20,lo8(16)
 4075 0780 50E0      		ldi r21,0
 4076 0782 60E0      		ldi r22,0
 4077 0784 70E0      		ldi r23,0
 4078 0786 80E0      		ldi r24,lo8(receivedBuffer)
 4079 0788 90E0      		ldi r25,hi8(receivedBuffer)
 4080 078a 00D0      		rcall strtol
 4081               	.LVL410:
 603:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4082               		.loc 3 603 0
 4083 078c 939A      		sbi 0x12,3
 604:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4084               		.loc 3 604 0
 4085 078e C4BB      		out 0x14,r28
 605:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4086               		.loc 3 605 0
 4087 0790 CABB      		out 0x1a,r28
 606:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 4088               		.loc 3 606 0
 4089 0792 C7BB      		out 0x17,r28
 607:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 4090               		.loc 3 607 0
 4091 0794 AB01      		movw r20,r22
 4092 0796 C501      		movw r24,r10
 4093 0798 B401      		movw r22,r8
 4094               	.LVL411:
 4095 079a 00D0      		rcall gba_flash_write_bus_cycle
 4096               	.LVL412:
 4097               	.L264:
 608:main.c        **** 				
 4098               		.loc 3 608 0
 4099 079c 9398      		cbi 0x12,3
 610:main.c        **** 			}
 4100               		.loc 3 610 0
 4101 079e 81E3      		ldi r24,lo8(49)
 4102 07a0 00C0      		rjmp .L245
 4103               	.LVL413:
 4104               	.L161:
 4105               	.LBE248:
 4106               	.LBE247:
 615:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4107               		.loc 3 615 0
 4108 07a2 8137      		cpi r24,lo8(113)
 4109 07a4 01F0      		breq .L162
 615:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4110               		.loc 3 615 0 is_stmt 0 discriminator 1
 4111 07a6 8437      		cpi r24,lo8(116)
 4112 07a8 01F4      		brne .L163
 4113               	.L162:
 4114               	.LBB249:
 616:main.c        **** 			
 4115               		.loc 3 616 0 is_stmt 1
 4116 07aa 939A      		sbi 0x12,3
 4117               	.LVL414:
 619:main.c        **** 				readLength = 256;
 4118               		.loc 3 619 0
 4119 07ac 8091 0000 		lds r24,receivedChar
 4120 07b0 8437      		cpi r24,lo8(116)
 4121 07b2 01F4      		brne .L212
 620:main.c        **** 			}
 4122               		.loc 3 620 0
 4123 07b4 00E0      		ldi r16,0
 4124 07b6 11E0      		ldi r17,lo8(1)
 4125 07b8 00C0      		rjmp .L164
 4126               	.L212:
 618:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4127               		.loc 3 618 0
 4128 07ba 00E4      		ldi r16,lo8(64)
 4129 07bc 10E0      		ldi r17,0
 4130               	.L164:
 4131               	.LVL415:
 622:main.c        **** 			
 4132               		.loc 3 622 0
 4133 07be C801      		movw r24,r16
 4134 07c0 00D0      		rcall usart_read_bytes
 4135               	.LVL416:
 4136 07c2 70E0      		ldi r23,lo8(receivedBuffer)
 4137 07c4 A72E      		mov r10,r23
 4138 07c6 70E0      		ldi r23,hi8(receivedBuffer)
 4139 07c8 B72E      		mov r11,r23
 4140 07ca 2601      		movw r4,r12
 4141 07cc 3701      		movw r6,r14
 4142               	.LVL417:
 4143               	.L165:
 4144               	.LBB250:
 4145               	.LBB251:
 626:main.c        **** 				address++;
 4146               		.loc 3 626 0 discriminator 3
 4147 07ce F501      		movw r30,r10
 4148 07d0 4181      		ldd r20,Z+1
 4149 07d2 50E0      		ldi r21,0
 4150 07d4 542F      		mov r21,r20
 4151 07d6 4427      		clr r20
 4152 07d8 8081      		ld r24,Z
 4153 07da 482B      		or r20,r24
 4154 07dc 21E0      		ldi r18,lo8(1)
 4155 07de C301      		movw r24,r6
 4156 07e0 B201      		movw r22,r4
 4157 07e2 00D0      		rcall gba_flash_write_byte
 4158               	.LVL418:
 627:main.c        **** 			}
 4159               		.loc 3 627 0 discriminator 3
 4160 07e4 FFEF      		ldi r31,-1
 4161 07e6 4F1A      		sub r4,r31
 4162 07e8 5F0A      		sbc r5,r31
 4163 07ea 6F0A      		sbc r6,r31
 4164 07ec 7F0A      		sbc r7,r31
 4165               	.LVL419:
 4166 07ee 22E0      		ldi r18,2
 4167 07f0 A20E      		add r10,r18
 4168 07f2 B11C      		adc r11,__zero_reg__
 4169               	.LVL420:
 4170               	.LBE251:
 624:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4171               		.loc 3 624 0 discriminator 3
 4172 07f4 C501      		movw r24,r10
 4173 07f6 8050      		subi r24,lo8(receivedBuffer)
 4174 07f8 9040      		sbci r25,hi8(receivedBuffer)
 4175 07fa 8017      		cp r24,r16
 4176 07fc 9107      		cpc r25,r17
 4177 07fe 04F0      		brlt .L165
 4178 0800 8FEF      		ldi r24,-1
 4179 0802 C81A      		sub r12,r24
 4180 0804 D80A      		sbc r13,r24
 4181 0806 E80A      		sbc r14,r24
 4182 0808 F80A      		sbc r15,r24
 4183 080a 0150      		subi r16,1
 4184 080c 1109      		sbc r17,__zero_reg__
 4185               	.LVL421:
 4186 080e 1695      		lsr r17
 4187 0810 0795      		ror r16
 4188               	.LVL422:
 4189 0812 C00E      		add r12,r16
 4190 0814 D11E      		adc r13,r17
 4191 0816 E11C      		adc r14,__zero_reg__
 4192 0818 F11C      		adc r15,__zero_reg__
 4193 081a 00C0      		rjmp .L253
 4194               	.LVL423:
 4195               	.L163:
 4196               	.LBE250:
 4197               	.LBE249:
 635:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4198               		.loc 3 635 0
 4199 081c 8636      		cpi r24,lo8(102)
 4200 081e 01F4      		brne .L166
 4201               	.LBB252:
 636:main.c        **** 			
 4202               		.loc 3 636 0
 4203 0820 939A      		sbi 0x12,3
 4204               	.LVL424:
 639:main.c        **** 			
 4205               		.loc 3 639 0
 4206 0822 80E0      		ldi r24,0
 4207 0824 91E0      		ldi r25,lo8(1)
 4208 0826 00D0      		rcall usart_read_bytes
 4209               	.LVL425:
 4210 0828 00E0      		ldi r16,lo8(receivedBuffer)
 4211 082a 10E0      		ldi r17,hi8(receivedBuffer)
 4212 082c 4601      		movw r8,r12
 4213 082e 5701      		movw r10,r14
 4214               	.LVL426:
 4215               	.L167:
 4216               	.LBB253:
 4217               	.LBB254:
 643:main.c        **** 				address++;
 4218               		.loc 3 643 0 discriminator 3
 4219 0830 F801      		movw r30,r16
 4220 0832 4181      		ldd r20,Z+1
 4221 0834 50E0      		ldi r21,0
 4222 0836 542F      		mov r21,r20
 4223 0838 4427      		clr r20
 4224 083a 8081      		ld r24,Z
 4225 083c 482B      		or r20,r24
 4226 083e 20E0      		ldi r18,0
 4227 0840 C501      		movw r24,r10
 4228 0842 B401      		movw r22,r8
 4229 0844 00D0      		rcall gba_flash_write_byte
 4230               	.LVL427:
 644:main.c        **** 			}
 4231               		.loc 3 644 0 discriminator 3
 4232 0846 FFEF      		ldi r31,-1
 4233 0848 8F1A      		sub r8,r31
 4234 084a 9F0A      		sbc r9,r31
 4235 084c AF0A      		sbc r10,r31
 4236 084e BF0A      		sbc r11,r31
 4237               	.LVL428:
 4238 0850 0E5F      		subi r16,-2
 4239 0852 1F4F      		sbci r17,-1
 4240               	.LVL429:
 4241               	.LBE254:
 641:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4242               		.loc 3 641 0 discriminator 3
 4243 0854 20E0      		ldi r18,hi8(receivedBuffer+256)
 4244 0856 0030      		cpi r16,lo8(receivedBuffer+256)
 4245 0858 1207      		cpc r17,r18
 4246 085a 01F4      		brne .L167
 4247 085c 80E8      		ldi r24,-128
 4248 085e C80E      		add r12,r24
 4249 0860 D11C      		adc r13,__zero_reg__
 4250 0862 E11C      		adc r14,__zero_reg__
 4251 0864 F11C      		adc r15,__zero_reg__
 4252 0866 00C0      		rjmp .L253
 4253               	.LVL430:
 4254               	.L166:
 4255               	.LBE253:
 4256               	.LBE252:
 653:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4257               		.loc 3 653 0
 4258 0868 8C36      		cpi r24,lo8(108)
 4259 086a 01F0      		breq .+2
 4260 086c 00C0      		rjmp .L168
 4261               	.LBB255:
 654:main.c        **** 			usart_read_bytes(64);
 4262               		.loc 3 654 0
 4263 086e 939A      		sbi 0x12,3
 655:main.c        **** 			
 4264               		.loc 3 655 0
 4265 0870 80E4      		ldi r24,lo8(64)
 4266 0872 90E0      		ldi r25,0
 4267 0874 00D0      		rcall usart_read_bytes
 4268               	.LVL431:
 658:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4269               		.loc 3 658 0
 4270 0876 C4BB      		out 0x14,r28
 659:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4271               		.loc 3 659 0
 4272 0878 CABB      		out 0x1a,r28
 660:main.c        **** 			
 4273               		.loc 3 660 0
 4274 087a C7BB      		out 0x17,r28
 663:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4275               		.loc 3 663 0
 4276 087c 40E6      		ldi r20,lo8(96)
 4277 087e 50E0      		ldi r21,0
 4278 0880 C701      		movw r24,r14
 4279 0882 B601      		movw r22,r12
 4280 0884 00D0      		rcall gba_flash_write_bus_cycle
 4281               	.LVL432:
 664:main.c        **** 			
 4282               		.loc 3 664 0
 4283 0886 40ED      		ldi r20,lo8(-48)
 4284 0888 50E0      		ldi r21,0
 4285 088a C701      		movw r24,r14
 4286 088c B601      		movw r22,r12
 4287 088e 00D0      		rcall gba_flash_write_bus_cycle
 4288               	.LVL433:
 667:main.c        **** 			_delay_us(50);
 4289               		.loc 3 667 0
 4290 0890 48EE      		ldi r20,lo8(-24)
 4291 0892 50E0      		ldi r21,0
 4292 0894 C701      		movw r24,r14
 4293 0896 B601      		movw r22,r12
 4294 0898 00D0      		rcall gba_flash_write_bus_cycle
 4295               	.LVL434:
 4296               	.LBB256:
 4297               	.LBB257:
 4298               		.loc 2 276 0
 4299 089a 95E8      		ldi r25,lo8(-123)
 4300 089c 9A95      	1:	dec r25
 4301 089e 01F4      		brne 1b
 4302 08a0 0000      		nop
 4303               	.LVL435:
 4304               	.LBE257:
 4305               	.LBE256:
 671:main.c        **** 			while (dataVerify != 0x0080) {
 4306               		.loc 3 671 0
 4307 08a2 C701      		movw r24,r14
 4308 08a4 B601      		movw r22,r12
 4309 08a6 00D0      		rcall gba_read_16bit_data
 4310               	.LVL436:
 4311               	.L169:
 672:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4312               		.loc 3 672 0
 4313 08a8 8038      		cpi r24,-128
 4314 08aa 9105      		cpc r25,__zero_reg__
 4315 08ac 01F0      		breq .L267
 673:main.c        **** 				_delay_us(50);
 4316               		.loc 3 673 0
 4317 08ae C701      		movw r24,r14
 4318 08b0 B601      		movw r22,r12
 4319 08b2 00D0      		rcall gba_read_16bit_data
 4320               	.LVL437:
 4321               	.LBB258:
 4322               	.LBB259:
 4323               		.loc 2 276 0
 4324 08b4 E5E8      		ldi r30,lo8(-123)
 4325 08b6 EA95      	1:	dec r30
 4326 08b8 01F4      		brne 1b
 4327 08ba 0000      		nop
 4328 08bc 00C0      		rjmp .L169
 4329               	.LVL438:
 4330               	.L267:
 4331               	.LBE259:
 4332               	.LBE258:
 679:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4333               		.loc 3 679 0
 4334 08be C4BB      		out 0x14,r28
 680:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4335               		.loc 3 680 0
 4336 08c0 CABB      		out 0x1a,r28
 681:main.c        **** 			
 4337               		.loc 3 681 0
 4338 08c2 C7BB      		out 0x17,r28
 684:main.c        **** 			
 4339               		.loc 3 684 0
 4340 08c4 4FE1      		ldi r20,lo8(31)
 4341 08c6 50E0      		ldi r21,0
 4342 08c8 C701      		movw r24,r14
 4343 08ca B601      		movw r22,r12
 4344 08cc 00D0      		rcall gba_flash_write_bus_cycle
 4345               	.LVL439:
 4346 08ce 00E0      		ldi r16,lo8(receivedBuffer)
 4347 08d0 10E0      		ldi r17,hi8(receivedBuffer)
 4348 08d2 4601      		movw r8,r12
 4349 08d4 5701      		movw r10,r14
 4350               	.LVL440:
 4351               	.L171:
 4352               	.LBB260:
 4353               	.LBB261:
 689:main.c        **** 				address++;
 4354               		.loc 3 689 0 discriminator 3
 4355 08d6 F801      		movw r30,r16
 4356 08d8 4181      		ldd r20,Z+1
 4357 08da 50E0      		ldi r21,0
 4358 08dc 542F      		mov r21,r20
 4359 08de 4427      		clr r20
 4360 08e0 8081      		ld r24,Z
 4361 08e2 482B      		or r20,r24
 4362 08e4 C501      		movw r24,r10
 4363 08e6 B401      		movw r22,r8
 4364 08e8 00D0      		rcall gba_flash_write_bus_cycle
 4365               	.LVL441:
 690:main.c        **** 			}
 4366               		.loc 3 690 0 discriminator 3
 4367 08ea FFEF      		ldi r31,-1
 4368 08ec 8F1A      		sub r8,r31
 4369 08ee 9F0A      		sbc r9,r31
 4370 08f0 AF0A      		sbc r10,r31
 4371 08f2 BF0A      		sbc r11,r31
 4372               	.LVL442:
 4373 08f4 0E5F      		subi r16,-2
 4374 08f6 1F4F      		sbci r17,-1
 4375               	.LVL443:
 4376               	.LBE261:
 687:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4377               		.loc 3 687 0 discriminator 3
 4378 08f8 20E0      		ldi r18,hi8(receivedBuffer+64)
 4379 08fa 0030      		cpi r16,lo8(receivedBuffer+64)
 4380 08fc 1207      		cpc r17,r18
 4381 08fe 01F4      		brne .L171
 4382 0900 80E2      		ldi r24,32
 4383 0902 C80E      		add r12,r24
 4384 0904 D11C      		adc r13,__zero_reg__
 4385 0906 E11C      		adc r14,__zero_reg__
 4386 0908 F11C      		adc r15,__zero_reg__
 4387               	.LBE260:
 694:main.c        **** 			_delay_us(440);
 4388               		.loc 3 694 0
 4389 090a 40ED      		ldi r20,lo8(-48)
 4390 090c 50E0      		ldi r21,0
 4391 090e C701      		movw r24,r14
 4392 0910 B601      		movw r22,r12
 4393 0912 00D0      		rcall gba_flash_write_bus_cycle
 4394               	.LVL444:
 4395               	.LBB262:
 4396               	.LBB263:
 4397               		.loc 2 276 0
 4398 0914 EFE6      		ldi r30,lo8(879)
 4399 0916 F3E0      		ldi r31,hi8(879)
 4400 0918 3197      	1:	sbiw r30,1
 4401 091a 01F4      		brne 1b
 4402 091c 00C0      		rjmp .
 4403 091e 0000      		nop
 4404               	.LVL445:
 4405               	.LBE263:
 4406               	.LBE262:
 698:main.c        **** 			while (dataVerify != 0x0080) {
 4407               		.loc 3 698 0
 4408 0920 C701      		movw r24,r14
 4409 0922 B601      		movw r22,r12
 4410 0924 00D0      		rcall gba_read_16bit_data
 4411               	.LVL446:
 4412               	.L172:
 699:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4413               		.loc 3 699 0
 4414 0926 8038      		cpi r24,-128
 4415 0928 9105      		cpc r25,__zero_reg__
 4416 092a 01F0      		breq .L268
 700:main.c        **** 				_delay_us(50);
 4417               		.loc 3 700 0
 4418 092c C701      		movw r24,r14
 4419 092e B601      		movw r22,r12
 4420 0930 00D0      		rcall gba_read_16bit_data
 4421               	.LVL447:
 4422               	.LBB264:
 4423               	.LBB265:
 4424               		.loc 2 276 0
 4425 0932 F5E8      		ldi r31,lo8(-123)
 4426 0934 FA95      	1:	dec r31
 4427 0936 01F4      		brne 1b
 4428 0938 0000      		nop
 4429 093a 00C0      		rjmp .L172
 4430               	.LVL448:
 4431               	.L268:
 4432               	.LBE265:
 4433               	.LBE264:
 706:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4434               		.loc 3 706 0
 4435 093c C4BB      		out 0x14,r28
 707:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4436               		.loc 3 707 0
 4437 093e CABB      		out 0x1a,r28
 708:main.c        **** 			
 4438               		.loc 3 708 0
 4439 0940 C7BB      		out 0x17,r28
 711:main.c        **** 			
 4440               		.loc 3 711 0
 4441 0942 4FEF      		ldi r20,lo8(-1)
 4442 0944 50E0      		ldi r21,0
 4443 0946 C701      		movw r24,r14
 4444 0948 B601      		movw r22,r12
 4445 094a 00D0      		rcall gba_flash_write_bus_cycle
 4446               	.LVL449:
 4447 094c 00C0      		rjmp .L253
 4448               	.LVL450:
 4449               	.L168:
 4450               	.LBE255:
 718:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4451               		.loc 3 718 0
 4452 094e 8537      		cpi r24,lo8(117)
 4453 0950 01F4      		brne .L174
 719:main.c        **** 			usart_read_bytes(64);
 4454               		.loc 3 719 0
 4455 0952 939A      		sbi 0x12,3
 720:main.c        **** 			
 4456               		.loc 3 720 0
 4457 0954 80E4      		ldi r24,lo8(64)
 4458 0956 90E0      		ldi r25,0
 4459 0958 00D0      		rcall usart_read_bytes
 4460               	.LVL451:
 4461 095a 90E0      		ldi r25,lo8(receivedBuffer)
 4462 095c A92E      		mov r10,r25
 4463 095e 90E0      		ldi r25,hi8(receivedBuffer)
 4464 0960 B92E      		mov r11,r25
 4465 0962 2601      		movw r4,r12
 4466 0964 3701      		movw r6,r14
 4467               	.LVL452:
 4468               	.L177:
 4469               	.LBB266:
 4470               	.LBB188:
 4471               		.loc 3 725 0
 4472 0966 C4BB      		out 0x14,r28
 726:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4473               		.loc 3 726 0
 4474 0968 CABB      		out 0x1a,r28
 727:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4475               		.loc 3 727 0
 4476 096a C7BB      		out 0x17,r28
 728:main.c        **** 				
 729:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4477               		.loc 3 729 0
 4478 096c F501      		movw r30,r10
 4479 096e 0181      		ldd r16,Z+1
 4480 0970 10E0      		ldi r17,0
 4481 0972 102F      		mov r17,r16
 4482 0974 0027      		clr r16
 4483 0976 8081      		ld r24,Z
 4484 0978 082B      		or r16,r24
 4485               	.LVL453:
 730:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 4486               		.loc 3 730 0
 4487 097a 40E4      		ldi r20,lo8(64)
 4488 097c 50E0      		ldi r21,0
 4489 097e C301      		movw r24,r6
 4490 0980 B201      		movw r22,r4
 4491 0982 00D0      		rcall gba_flash_write_bus_cycle
 4492               	.LVL454:
 731:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4493               		.loc 3 731 0
 4494 0984 A801      		movw r20,r16
 4495 0986 C301      		movw r24,r6
 4496 0988 B201      		movw r22,r4
 4497 098a 00D0      		rcall gba_flash_write_bus_cycle
 4498               	.LVL455:
 732:main.c        **** 				
 733:main.c        **** 				// Verify status ok
 734:main.c        **** 				uint16_t status = gba_read_16bit_data(address);
 4499               		.loc 3 734 0
 4500 098c C301      		movw r24,r6
 4501 098e B201      		movw r22,r4
 4502 0990 00D0      		rcall gba_read_16bit_data
 4503               	.LVL456:
 4504               	.L175:
 735:main.c        **** 				while ((status & 0x80) == 0) {
 4505               		.loc 3 735 0
 4506 0992 87FD      		sbrc r24,7
 4507 0994 00C0      		rjmp .L269
 736:main.c        **** 					status = gba_read_16bit_data(address);
 4508               		.loc 3 736 0
 4509 0996 C301      		movw r24,r6
 4510 0998 B201      		movw r22,r4
 4511 099a 00D0      		rcall gba_read_16bit_data
 4512               	.LVL457:
 4513               	.LBB186:
 4514               	.LBB187:
 4515               		.loc 2 276 0
 4516 099c F5E0      		ldi r31,lo8(5)
 4517 099e FA95      	1:	dec r31
 4518 09a0 01F4      		brne 1b
 4519 09a2 0000      		nop
 4520 09a4 00C0      		rjmp .L175
 4521               	.LVL458:
 4522               	.L269:
 4523               	.LBE187:
 4524               	.LBE186:
 737:main.c        **** 					_delay_us(2);
 738:main.c        **** 				}
 739:main.c        **** 				address++;
 4525               		.loc 3 739 0 discriminator 2
 4526 09a6 2FEF      		ldi r18,-1
 4527 09a8 421A      		sub r4,r18
 4528 09aa 520A      		sbc r5,r18
 4529 09ac 620A      		sbc r6,r18
 4530 09ae 720A      		sbc r7,r18
 4531               	.LVL459:
 4532 09b0 82E0      		ldi r24,2
 4533 09b2 A80E      		add r10,r24
 4534 09b4 B11C      		adc r11,__zero_reg__
 4535               	.LVL460:
 4536               	.LBE188:
 723:main.c        **** 				// Set address lines as outputs
 4537               		.loc 3 723 0 discriminator 2
 4538 09b6 E0E0      		ldi r30,lo8(receivedBuffer+64)
 4539 09b8 F0E0      		ldi r31,hi8(receivedBuffer+64)
 4540 09ba EA15      		cp r30,r10
 4541 09bc FB05      		cpc r31,r11
 4542 09be 01F4      		brne .L177
 4543 09c0 F0E2      		ldi r31,32
 4544 09c2 CF0E      		add r12,r31
 4545 09c4 D11C      		adc r13,__zero_reg__
 4546 09c6 E11C      		adc r14,__zero_reg__
 4547 09c8 F11C      		adc r15,__zero_reg__
 4548               	.LVL461:
 4549               	.L253:
 4550               	.LBE266:
 740:main.c        **** 			}
 741:main.c        **** 			
 742:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 4551               		.loc 3 742 0
 4552 09ca 81E3      		ldi r24,lo8(49)
 4553 09cc 00C0      		rjmp .L248
 4554               	.LVL462:
 4555               	.L174:
 743:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 744:main.c        **** 		}
 745:main.c        **** 		
 746:main.c        **** 		
 747:main.c        **** 		// ---------- General commands ----------
 748:main.c        **** 		// Set any pin as input/output
 749:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 750:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 4556               		.loc 3 750 0
 4557 09ce 8934      		cpi r24,lo8(73)
 4558 09d0 01F0      		breq .L178
 4559               		.loc 3 750 0 is_stmt 0 discriminator 1
 4560 09d2 8F34      		cpi r24,lo8(79)
 4561 09d4 01F0      		breq .+2
 4562 09d6 00C0      		rjmp .L179
 4563               	.L178:
 4564               	.LBB267:
 751:main.c        **** 			char portChar = USART_Receive();
 4565               		.loc 3 751 0 is_stmt 1
 4566 09d8 00D0      		rcall USART_Receive
 4567               	.LVL463:
 4568 09da 182F      		mov r17,r24
 4569               	.LVL464:
 752:main.c        **** 			usart_read_chars();
 4570               		.loc 3 752 0
 4571 09dc 00D0      		rcall usart_read_chars
 4572               	.LVL465:
 753:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4573               		.loc 3 753 0
 4574 09de 40E1      		ldi r20,lo8(16)
 4575 09e0 50E0      		ldi r21,0
 4576 09e2 60E0      		ldi r22,0
 4577 09e4 70E0      		ldi r23,0
 4578 09e6 80E0      		ldi r24,lo8(receivedBuffer)
 4579 09e8 90E0      		ldi r25,hi8(receivedBuffer)
 4580 09ea 00D0      		rcall strtol
 4581               	.LVL466:
 754:main.c        **** 			
 755:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4582               		.loc 3 755 0
 4583 09ec 939A      		sbi 0x12,3
 756:main.c        **** 			if (receivedChar == SET_INPUT) {
 4584               		.loc 3 756 0
 4585 09ee 8091 0000 		lds r24,receivedChar
 4586 09f2 8934      		cpi r24,lo8(73)
 4587 09f4 01F4      		brne .L180
 757:main.c        **** 				if (portChar == 'A') {
 4588               		.loc 3 757 0
 4589 09f6 1134      		cpi r17,lo8(65)
 4590 09f8 01F4      		brne .L181
 758:main.c        **** 					DDRA &= ~(setValue);
 4591               		.loc 3 758 0
 4592 09fa 8AB3      		in r24,0x1a
 4593 09fc 6095      		com r22
 4594               	.LVL467:
 4595 09fe 6823      		and r22,r24
 4596               	.LVL468:
 4597 0a00 00C0      		rjmp .L255
 4598               	.LVL469:
 4599               	.L181:
 759:main.c        **** 				}
 760:main.c        **** 				else if (portChar == 'B') {
 4600               		.loc 3 760 0
 4601 0a02 1234      		cpi r17,lo8(66)
 4602 0a04 01F4      		brne .L183
 761:main.c        **** 					DDRB &= ~(setValue);
 4603               		.loc 3 761 0
 4604 0a06 87B3      		in r24,0x17
 4605 0a08 6095      		com r22
 4606               	.LVL470:
 4607 0a0a 6823      		and r22,r24
 4608               	.LVL471:
 4609 0a0c 00C0      		rjmp .L256
 4610               	.LVL472:
 4611               	.L183:
 762:main.c        **** 				}
 763:main.c        **** 				else if (portChar == 'C') {
 4612               		.loc 3 763 0
 4613 0a0e 1334      		cpi r17,lo8(67)
 4614 0a10 01F4      		brne .L184
 764:main.c        **** 					DDRC &= ~(setValue);
 4615               		.loc 3 764 0
 4616 0a12 84B3      		in r24,0x14
 4617 0a14 6095      		com r22
 4618               	.LVL473:
 4619 0a16 6823      		and r22,r24
 4620               	.LVL474:
 4621 0a18 00C0      		rjmp .L261
 4622               	.LVL475:
 4623               	.L184:
 765:main.c        **** 				}
 766:main.c        **** 				else if (portChar == 'D') {
 4624               		.loc 3 766 0
 4625 0a1a 1434      		cpi r17,lo8(68)
 4626 0a1c 01F4      		brne .L185
 767:main.c        **** 					DDRD &= ~(setValue);
 4627               		.loc 3 767 0
 4628 0a1e 81B3      		in r24,0x11
 4629 0a20 6095      		com r22
 4630               	.LVL476:
 4631 0a22 6823      		and r22,r24
 4632               	.LVL477:
 4633 0a24 00C0      		rjmp .L262
 4634               	.LVL478:
 4635               	.L185:
 768:main.c        **** 				}
 769:main.c        **** 				else if (portChar == 'E') {
 4636               		.loc 3 769 0
 4637 0a26 1534      		cpi r17,lo8(69)
 4638 0a28 01F0      		breq .+2
 4639 0a2a 00C0      		rjmp .L204
 770:main.c        **** 					DDRE &= ~(setValue);
 4640               		.loc 3 770 0
 4641 0a2c 86B1      		in r24,0x6
 4642 0a2e 6095      		com r22
 4643               	.LVL479:
 4644 0a30 6823      		and r22,r24
 4645               	.LVL480:
 4646 0a32 00C0      		rjmp .L263
 4647               	.LVL481:
 4648               	.L180:
 771:main.c        **** 				}
 772:main.c        **** 			}
 773:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 4649               		.loc 3 773 0
 4650 0a34 8F34      		cpi r24,lo8(79)
 4651 0a36 01F0      		breq .+2
 4652 0a38 00C0      		rjmp .L204
 774:main.c        **** 				if (portChar == 'A') {
 4653               		.loc 3 774 0
 4654 0a3a 1134      		cpi r17,lo8(65)
 4655 0a3c 01F4      		brne .L186
 775:main.c        **** 					DDRA |= (setValue);
 4656               		.loc 3 775 0
 4657 0a3e 8AB3      		in r24,0x1a
 4658 0a40 682B      		or r22,r24
 4659               	.LVL482:
 4660               	.L255:
 4661 0a42 6ABB      		out 0x1a,r22
 4662 0a44 00C0      		rjmp .L204
 4663               	.LVL483:
 4664               	.L186:
 776:main.c        **** 				}
 777:main.c        **** 				else if (portChar == 'B') {
 4665               		.loc 3 777 0
 4666 0a46 1234      		cpi r17,lo8(66)
 4667 0a48 01F4      		brne .L187
 778:main.c        **** 					DDRB |= (setValue);
 4668               		.loc 3 778 0
 4669 0a4a 87B3      		in r24,0x17
 4670 0a4c 682B      		or r22,r24
 4671               	.LVL484:
 4672               	.L256:
 4673 0a4e 67BB      		out 0x17,r22
 4674 0a50 00C0      		rjmp .L204
 4675               	.LVL485:
 4676               	.L187:
 779:main.c        **** 				}
 780:main.c        **** 				else if (portChar == 'C') {
 4677               		.loc 3 780 0
 4678 0a52 1334      		cpi r17,lo8(67)
 4679 0a54 01F4      		brne .L188
 781:main.c        **** 					DDRC |= (setValue);
 4680               		.loc 3 781 0
 4681 0a56 84B3      		in r24,0x14
 4682 0a58 682B      		or r22,r24
 4683               	.LVL486:
 4684               	.L261:
 4685 0a5a 64BB      		out 0x14,r22
 4686 0a5c 00C0      		rjmp .L204
 4687               	.LVL487:
 4688               	.L188:
 782:main.c        **** 				}
 783:main.c        **** 				else if (portChar == 'D') {
 4689               		.loc 3 783 0
 4690 0a5e 1434      		cpi r17,lo8(68)
 4691 0a60 01F4      		brne .L189
 784:main.c        **** 					DDRD |= (setValue);
 4692               		.loc 3 784 0
 4693 0a62 81B3      		in r24,0x11
 4694 0a64 682B      		or r22,r24
 4695               	.LVL488:
 4696               	.L262:
 4697 0a66 61BB      		out 0x11,r22
 4698 0a68 00C0      		rjmp .L204
 4699               	.LVL489:
 4700               	.L189:
 785:main.c        **** 				}
 786:main.c        **** 				else if (portChar == 'E') {
 4701               		.loc 3 786 0
 4702 0a6a 1534      		cpi r17,lo8(69)
 4703 0a6c 01F0      		breq .+2
 4704 0a6e 00C0      		rjmp .L204
 787:main.c        **** 					DDRE |= (setValue);
 4705               		.loc 3 787 0
 4706 0a70 86B1      		in r24,0x6
 4707 0a72 682B      		or r22,r24
 4708               	.LVL490:
 4709               	.L263:
 4710 0a74 66B9      		out 0x6,r22
 4711 0a76 00C0      		rjmp .L204
 4712               	.LVL491:
 4713               	.L179:
 4714               	.LBE267:
 788:main.c        **** 				}
 789:main.c        **** 			}
 790:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 791:main.c        **** 		}
 792:main.c        **** 		
 793:main.c        **** 		// Set pin output as low
 794:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 4715               		.loc 3 794 0
 4716 0a78 8C34      		cpi r24,lo8(76)
 4717 0a7a 01F4      		brne .L190
 4718               	.LBB268:
 795:main.c        **** 			char portChar = USART_Receive();			
 4719               		.loc 3 795 0
 4720 0a7c 00D0      		rcall USART_Receive
 4721               	.LVL492:
 4722 0a7e 182F      		mov r17,r24
 4723               	.LVL493:
 796:main.c        **** 			usart_read_chars();
 4724               		.loc 3 796 0
 4725 0a80 00D0      		rcall usart_read_chars
 4726               	.LVL494:
 797:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4727               		.loc 3 797 0
 4728 0a82 40E1      		ldi r20,lo8(16)
 4729 0a84 50E0      		ldi r21,0
 4730 0a86 60E0      		ldi r22,0
 4731 0a88 70E0      		ldi r23,0
 4732 0a8a 80E0      		ldi r24,lo8(receivedBuffer)
 4733 0a8c 90E0      		ldi r25,hi8(receivedBuffer)
 4734 0a8e 00D0      		rcall strtol
 4735               	.LVL495:
 798:main.c        **** 			
 799:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4736               		.loc 3 799 0
 4737 0a90 939A      		sbi 0x12,3
 800:main.c        **** 			if (portChar == 'A') {
 4738               		.loc 3 800 0
 4739 0a92 1134      		cpi r17,lo8(65)
 4740 0a94 01F4      		brne .L191
 801:main.c        **** 				PORTA &= ~(setValue);
 4741               		.loc 3 801 0
 4742 0a96 8BB3      		in r24,0x1b
 4743 0a98 6095      		com r22
 4744               	.LVL496:
 4745 0a9a 6823      		and r22,r24
 4746               	.LVL497:
 4747 0a9c 00C0      		rjmp .L260
 4748               	.LVL498:
 4749               	.L191:
 802:main.c        **** 			}
 803:main.c        **** 			else if (portChar == 'B') {
 4750               		.loc 3 803 0
 4751 0a9e 1234      		cpi r17,lo8(66)
 4752 0aa0 01F4      		brne .L193
 804:main.c        **** 				PORTB &= ~(setValue);
 4753               		.loc 3 804 0
 4754 0aa2 88B3      		in r24,0x18
 4755 0aa4 6095      		com r22
 4756               	.LVL499:
 4757 0aa6 6823      		and r22,r24
 4758               	.LVL500:
 4759 0aa8 00C0      		rjmp .L259
 4760               	.LVL501:
 4761               	.L193:
 805:main.c        **** 			}
 806:main.c        **** 			else if (portChar == 'C') {
 4762               		.loc 3 806 0
 4763 0aaa 1334      		cpi r17,lo8(67)
 4764 0aac 01F4      		brne .L194
 807:main.c        **** 				PORTC &= ~(setValue);
 4765               		.loc 3 807 0
 4766 0aae 85B3      		in r24,0x15
 4767 0ab0 6095      		com r22
 4768               	.LVL502:
 4769 0ab2 6823      		and r22,r24
 4770               	.LVL503:
 4771 0ab4 00C0      		rjmp .L258
 4772               	.LVL504:
 4773               	.L194:
 808:main.c        **** 			}
 809:main.c        **** 			else if (portChar == 'D') {
 4774               		.loc 3 809 0
 4775 0ab6 1434      		cpi r17,lo8(68)
 4776 0ab8 01F4      		brne .L195
 810:main.c        **** 				PORTD &= ~(setValue);
 4777               		.loc 3 810 0
 4778 0aba 82B3      		in r24,0x12
 4779 0abc 6095      		com r22
 4780               	.LVL505:
 4781 0abe 6823      		and r22,r24
 4782               	.LVL506:
 4783 0ac0 00C0      		rjmp .L257
 4784               	.LVL507:
 4785               	.L195:
 811:main.c        **** 			}
 812:main.c        **** 			else if (portChar == 'E') {
 4786               		.loc 3 812 0
 4787 0ac2 1534      		cpi r17,lo8(69)
 4788 0ac4 01F0      		breq .+2
 4789 0ac6 00C0      		rjmp .L204
 813:main.c        **** 				PORTE &= ~(setValue);
 4790               		.loc 3 813 0
 4791 0ac8 87B1      		in r24,0x7
 4792 0aca 6095      		com r22
 4793               	.LVL508:
 4794 0acc 6823      		and r22,r24
 4795               	.LVL509:
 4796 0ace 00C0      		rjmp .L254
 4797               	.LVL510:
 4798               	.L190:
 4799               	.LBE268:
 814:main.c        **** 			}
 815:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 816:main.c        **** 		}
 817:main.c        **** 		
 818:main.c        **** 		// Set pin output as high
 819:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 4800               		.loc 3 819 0
 4801 0ad0 8834      		cpi r24,lo8(72)
 4802 0ad2 01F4      		brne .L196
 4803               	.LBB269:
 820:main.c        **** 			char portChar = USART_Receive();			
 4804               		.loc 3 820 0
 4805 0ad4 00D0      		rcall USART_Receive
 4806               	.LVL511:
 4807 0ad6 182F      		mov r17,r24
 4808               	.LVL512:
 821:main.c        **** 			usart_read_chars();
 4809               		.loc 3 821 0
 4810 0ad8 00D0      		rcall usart_read_chars
 4811               	.LVL513:
 822:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4812               		.loc 3 822 0
 4813 0ada 40E1      		ldi r20,lo8(16)
 4814 0adc 50E0      		ldi r21,0
 4815 0ade 60E0      		ldi r22,0
 4816 0ae0 70E0      		ldi r23,0
 4817 0ae2 80E0      		ldi r24,lo8(receivedBuffer)
 4818 0ae4 90E0      		ldi r25,hi8(receivedBuffer)
 4819 0ae6 00D0      		rcall strtol
 4820               	.LVL514:
 823:main.c        **** 			
 824:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4821               		.loc 3 824 0
 4822 0ae8 939A      		sbi 0x12,3
 825:main.c        **** 			if (portChar == 'A') {
 4823               		.loc 3 825 0
 4824 0aea 1134      		cpi r17,lo8(65)
 4825 0aec 01F4      		brne .L197
 826:main.c        **** 				PORTA |= (setValue);
 4826               		.loc 3 826 0
 4827 0aee 8BB3      		in r24,0x1b
 4828 0af0 682B      		or r22,r24
 4829               	.LVL515:
 4830               	.L260:
 4831 0af2 6BBB      		out 0x1b,r22
 4832 0af4 00C0      		rjmp .L204
 4833               	.LVL516:
 4834               	.L197:
 827:main.c        **** 			}
 828:main.c        **** 			else if (portChar == 'B') {
 4835               		.loc 3 828 0
 4836 0af6 1234      		cpi r17,lo8(66)
 4837 0af8 01F4      		brne .L199
 829:main.c        **** 				PORTB |= (setValue);
 4838               		.loc 3 829 0
 4839 0afa 88B3      		in r24,0x18
 4840 0afc 682B      		or r22,r24
 4841               	.LVL517:
 4842               	.L259:
 4843 0afe 68BB      		out 0x18,r22
 4844 0b00 00C0      		rjmp .L204
 4845               	.LVL518:
 4846               	.L199:
 830:main.c        **** 			}
 831:main.c        **** 			else if (portChar == 'C') {
 4847               		.loc 3 831 0
 4848 0b02 1334      		cpi r17,lo8(67)
 4849 0b04 01F4      		brne .L200
 832:main.c        **** 				PORTC |= (setValue);
 4850               		.loc 3 832 0
 4851 0b06 85B3      		in r24,0x15
 4852 0b08 682B      		or r22,r24
 4853               	.LVL519:
 4854               	.L258:
 4855 0b0a 65BB      		out 0x15,r22
 4856 0b0c 00C0      		rjmp .L204
 4857               	.LVL520:
 4858               	.L200:
 833:main.c        **** 			}
 834:main.c        **** 			else if (portChar == 'D') {
 4859               		.loc 3 834 0
 4860 0b0e 1434      		cpi r17,lo8(68)
 4861 0b10 01F4      		brne .L201
 835:main.c        **** 				PORTD |= (setValue);
 4862               		.loc 3 835 0
 4863 0b12 82B3      		in r24,0x12
 4864 0b14 682B      		or r22,r24
 4865               	.LVL521:
 4866               	.L257:
 4867 0b16 62BB      		out 0x12,r22
 4868 0b18 00C0      		rjmp .L204
 4869               	.LVL522:
 4870               	.L201:
 836:main.c        **** 			}
 837:main.c        **** 			else if (portChar == 'E') {
 4871               		.loc 3 837 0
 4872 0b1a 1534      		cpi r17,lo8(69)
 4873 0b1c 01F4      		brne .L204
 838:main.c        **** 				PORTE |= (setValue);
 4874               		.loc 3 838 0
 4875 0b1e 87B1      		in r24,0x7
 4876 0b20 682B      		or r22,r24
 4877               	.LVL523:
 4878               	.L254:
 4879 0b22 67B9      		out 0x7,r22
 4880 0b24 00C0      		rjmp .L204
 4881               	.L196:
 4882               	.LBE269:
 839:main.c        **** 			}
 840:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 841:main.c        **** 		}
 842:main.c        **** 		
 843:main.c        **** 		// Read all pins of a PORT and return the value
 844:main.c        **** 		else if (receivedChar == READ_INPUT) {
 4883               		.loc 3 844 0
 4884 0b26 8434      		cpi r24,lo8(68)
 4885 0b28 01F4      		brne .L202
 4886               	.LBB270:
 845:main.c        **** 			char portChar = USART_Receive();			
 4887               		.loc 3 845 0
 4888 0b2a 00D0      		rcall USART_Receive
 4889               	.LVL524:
 846:main.c        **** 			
 847:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4890               		.loc 3 847 0
 4891 0b2c 939A      		sbi 0x12,3
 848:main.c        **** 			if (portChar == 'A') {
 4892               		.loc 3 848 0
 4893 0b2e 8134      		cpi r24,lo8(65)
 4894 0b30 01F4      		brne .L203
 849:main.c        **** 				USART_Transmit(PINA);
 4895               		.loc 3 849 0
 4896 0b32 89B3      		in r24,0x19
 4897               	.LVL525:
 4898 0b34 00C0      		rjmp .L248
 4899               	.LVL526:
 4900               	.L203:
 850:main.c        **** 			}
 851:main.c        **** 			else if (portChar == 'B') {
 4901               		.loc 3 851 0
 4902 0b36 8234      		cpi r24,lo8(66)
 4903 0b38 01F4      		brne .L205
 852:main.c        **** 				USART_Transmit(PINB);
 4904               		.loc 3 852 0
 4905 0b3a 86B3      		in r24,0x16
 4906               	.LVL527:
 4907 0b3c 00C0      		rjmp .L248
 4908               	.LVL528:
 4909               	.L205:
 853:main.c        **** 			}
 854:main.c        **** 			else if (portChar == 'C') {
 4910               		.loc 3 854 0
 4911 0b3e 8334      		cpi r24,lo8(67)
 4912 0b40 01F4      		brne .L206
 855:main.c        **** 				USART_Transmit(PINC);
 4913               		.loc 3 855 0
 4914 0b42 83B3      		in r24,0x13
 4915               	.LVL529:
 4916 0b44 00C0      		rjmp .L248
 4917               	.LVL530:
 4918               	.L206:
 856:main.c        **** 			}
 857:main.c        **** 			else if (portChar == 'D') {
 4919               		.loc 3 857 0
 4920 0b46 8434      		cpi r24,lo8(68)
 4921 0b48 01F4      		brne .L207
 858:main.c        **** 				USART_Transmit(PIND);
 4922               		.loc 3 858 0
 4923 0b4a 80B3      		in r24,0x10
 4924               	.LVL531:
 4925 0b4c 00C0      		rjmp .L248
 4926               	.LVL532:
 4927               	.L207:
 859:main.c        **** 			}
 860:main.c        **** 			else if (portChar == 'E') {
 4928               		.loc 3 860 0
 4929 0b4e 8534      		cpi r24,lo8(69)
 4930 0b50 01F4      		brne .L204
 861:main.c        **** 				USART_Transmit(PINE);
 4931               		.loc 3 861 0
 4932 0b52 85B1      		in r24,0x5
 4933               	.LVL533:
 4934               	.L248:
 4935 0b54 00D0      		rcall USART_Transmit
 4936               	.LVL534:
 4937               	.L204:
 862:main.c        **** 			}
 863:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 4938               		.loc 3 863 0
 4939 0b56 9398      		cbi 0x12,3
 4940               	.LBE270:
 4941 0b58 00C0      		rjmp .L95
 4942               	.LVL535:
 4943               	.L202:
 864:main.c        **** 		}
 865:main.c        **** 		
 866:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 867:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 4944               		.loc 3 867 0
 4945 0b5a 8D34      		cpi r24,lo8(77)
 4946 0b5c 01F4      		brne .L208
 4947               	.LBB271:
 868:main.c        **** 			char commonChar = USART_Receive();
 4948               		.loc 3 868 0
 4949 0b5e 00D0      		rcall USART_Receive
 4950               	.LVL536:
 869:main.c        **** 			if (commonChar == '1') {
 4951               		.loc 3 869 0
 4952 0b60 8133      		cpi r24,lo8(49)
 4953 0b62 01F4      		brne .L270
 870:main.c        **** 				resetCommonLines = 1;
 4954               		.loc 3 870 0
 4955 0b64 2224      		clr r2
 4956 0b66 2394      		inc r2
 4957 0b68 00C0      		rjmp .L244
 4958               	.L270:
 871:main.c        **** 			}
 872:main.c        **** 			else if (commonChar == '0') {
 4959               		.loc 3 872 0
 4960 0b6a 8033      		cpi r24,lo8(48)
 4961 0b6c 01F0      		breq .+2
 4962 0b6e 00C0      		rjmp .L95
 873:main.c        **** 				resetCommonLines = 0;
 4963               		.loc 3 873 0
 4964 0b70 212C      		mov r2,__zero_reg__
 4965 0b72 00C0      		rjmp .L96
 4966               	.LVL537:
 4967               	.L208:
 4968               	.LBE271:
 874:main.c        **** 			}
 875:main.c        **** 		}
 876:main.c        **** 		
 877:main.c        **** 		// Send back the PCB version number
 878:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 4969               		.loc 3 878 0
 4970 0b74 8836      		cpi r24,lo8(104)
 4971 0b76 01F4      		brne .L209
 879:main.c        **** 			USART_Transmit(PCB_VERSION);
 4972               		.loc 3 879 0
 4973 0b78 84E0      		ldi r24,lo8(4)
 4974 0b7a 00C0      		rjmp .L245
 4975               	.L209:
 880:main.c        **** 		}
 881:main.c        **** 		
 882:main.c        **** 		// Send back the firmware version number
 883:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 4976               		.loc 3 883 0
 4977 0b7c 8635      		cpi r24,lo8(86)
 4978 0b7e 01F4      		brne .L210
 884:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 4979               		.loc 3 884 0
 4980 0b80 80E1      		ldi r24,lo8(16)
 4981               	.LVL538:
 4982               	.L245:
 4983 0b82 00D0      		rcall USART_Transmit
 4984               	.LVL539:
 4985 0b84 00C0      		rjmp .L95
 4986               	.LVL540:
 4987               	.L210:
 885:main.c        **** 		}
 886:main.c        **** 		
 887:main.c        **** 		// Reset the AVR if it matches the number
 888:main.c        **** 		else if (receivedChar == RESET_AVR) {
 4988               		.loc 3 888 0
 4989 0b86 8A32      		cpi r24,lo8(42)
 4990 0b88 01F0      		breq .+2
 4991 0b8a 00C0      		rjmp .L95
 4992               	.LBB272:
 889:main.c        **** 			usart_read_chars();
 4993               		.loc 3 889 0
 4994 0b8c 00D0      		rcall usart_read_chars
 4995               	.LVL541:
 890:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 4996               		.loc 3 890 0
 4997 0b8e 40E1      		ldi r20,lo8(16)
 4998 0b90 50E0      		ldi r21,0
 4999 0b92 60E0      		ldi r22,0
 5000 0b94 70E0      		ldi r23,0
 5001 0b96 80E0      		ldi r24,lo8(receivedBuffer)
 5002 0b98 90E0      		ldi r25,hi8(receivedBuffer)
 5003 0b9a 00D0      		rcall strtol
 5004               	.LVL542:
 891:main.c        **** 			if (resetValue == RESET_VALUE) {
 5005               		.loc 3 891 0
 5006 0b9c 613E      		cpi r22,-31
 5007 0b9e 754E      		sbci r23,-27
 5008 0ba0 8740      		sbci r24,7
 5009 0ba2 9105      		cpc r25,__zero_reg__
 5010 0ba4 01F0      		breq .+2
 5011 0ba6 00C0      		rjmp .L95
 892:main.c        **** 				// Clear watchdog flag
 893:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 5012               		.loc 3 893 0
 5013 0ba8 84B7      		in r24,0x34
 5014 0baa 877F      		andi r24,lo8(-9)
 5015 0bac 84BF      		out 0x34,r24
 894:main.c        **** 				
 895:main.c        **** 				// Start timed sequence
 896:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 5016               		.loc 3 896 0
 5017 0bae 88E1      		ldi r24,lo8(24)
 5018 0bb0 81BD      		out 0x21,r24
 897:main.c        **** 				
 898:main.c        **** 				// Reset in 250 ms
 899:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 5019               		.loc 3 899 0
 5020 0bb2 9CE0      		ldi r25,lo8(12)
 5021 0bb4 91BD      		out 0x21,r25
 5022               	.LVL543:
 5023               	.LBB273:
 5024               	.LBB274:
 5025               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 5026               		.loc 4 105 0
 5027 0bb6 8FEF      		ldi r24,lo8(-1)
 5028 0bb8 9FEF      		ldi r25,lo8(-1)
 5029               	/* #APP */
 5030               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 5031 0bba 0197      		1: sbiw r24,1
 5032 0bbc 01F4      		brne 1b
 5033               	 ;  0 "" 2
 5034               	.LVL544:
 5035               	/* #NOAPP */
 5036 0bbe 00C0      		rjmp .L95
 5037               	.LBE274:
 5038               	.LBE273:
 5039               	.LBE272:
 5040               		.cfi_endproc
 5041               	.LFE46:
 5043               	.global	cartMode
 5044               		.data
 5047               	cartMode:
 5048 0000 02        		.byte	2
 5049               	.global	lastBankAccessed
 5050               		.section .bss
 5053               	lastBankAccessed:
 5054 0000 00        		.zero	1
 5055               	.global	flashBank1CommandWrites
 5058               	flashBank1CommandWrites:
 5059 0001 00        		.zero	1
 5060               		.comm	flashWriteCycle,12,1
 5061               		.comm	flashWriteWePin,1,1
 5062               		.comm	flashChipIdBuffer,2,1
 5063               		.comm	eepromBuffer,8,1
 5064               		.comm	receivedChar,1,1
 5065               		.comm	receivedBuffer,256,1
 5066               		.text
 5067               	.Letext0:
 5068               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 5069               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1467   .text:0000040a gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1546   .text:0000043c gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1646   .text:000004a0 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:5058   .bss:00000001 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:5053   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1771   .text:00000522 gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:1934   .text:000005b6 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:2000   .text:000005e6 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:2124   .text:00000646 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:2246   .text:000006a2 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:2354   .text:000006f8 setup
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:5047   .data:00000000 cartMode
C:\Users\Alex\AppData\Local\Temp\cc8Z9nkH.s:2450   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
