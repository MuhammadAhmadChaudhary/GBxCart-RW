   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.3
   4:setup.c       ****  Firmware version: R15
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 8/08/2019
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define VOLTAGE_SELECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 144:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 145:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 146:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
 147:setup.c       **** 
 148:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 149:setup.c       **** 
 150:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 151:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 152:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 153:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 154:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 155:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE_WORD 'u'
 156:setup.c       **** 
 157:setup.c       **** #define D0D1_NOT_SWAPPED 0
 158:setup.c       **** #define D0D1_SWAPPED 1
 159:setup.c       **** 
 160:setup.c       **** // General commands
 161:setup.c       **** #define SEND_ACK '1'
 162:setup.c       **** #define CART_MODE 'C'
 163:setup.c       **** #define SET_INPUT 'I'
 164:setup.c       **** #define SET_OUTPUT 'O'
 165:setup.c       **** #define SET_OUTPUT_LOW 'L'
 166:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 167:setup.c       **** #define READ_INPUT 'D'
 168:setup.c       **** #define RESET_COMMON_LINES 'M'
 169:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 170:setup.c       **** #define READ_PCB_VERSION 'h'
 171:setup.c       **** #define VOLTAGE_3_3V '3'
 172:setup.c       **** #define VOLTAGE_5V '5'
 173:setup.c       **** 
 174:setup.c       **** #define RESET_AVR '*'
 175:setup.c       **** #define RESET_VALUE 0x7E5E1
 176:setup.c       **** 
 177:setup.c       **** 
 178:setup.c       **** char receivedBuffer[256];
 179:setup.c       **** char receivedChar;
 180:setup.c       **** uint8_t eepromBuffer[8];
 181:setup.c       **** uint8_t flashChipIdBuffer[2];
 182:setup.c       **** 
 183:setup.c       **** char flashWriteWePin;
 184:setup.c       **** uint16_t flashWriteCycle[3][2];
 185:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 186:setup.c       **** uint8_t lastBankAccessed = 0;
 187:setup.c       **** 
 188:setup.c       **** uint8_t cartMode = GBA_MODE;
 189:setup.c       **** 
 190:setup.c       **** // Receive USART data
 191:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 191 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 192:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 192 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 193:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 193 0
  26 0004 8CB1      		in r24,0xc
 194:setup.c       **** }
  27               		.loc 1 194 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 195:setup.c       **** 
 196:setup.c       **** // Transmit USART data
 197:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 197 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 198:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 198 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 199:setup.c       **** 	UDR = data;
  47               		.loc 1 199 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 200:setup.c       **** }
 201:setup.c       **** 
 202:setup.c       **** // Read 1-256 bytes from the USART 
 203:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 203 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB125:
 204:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 204 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 204 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 205:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 205 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE125:
 206:setup.c       **** 	}
 207:setup.c       **** }
 106               		.loc 1 207 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 208:setup.c       **** 
 209:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 210:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 210 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 211:setup.c       **** 	int x = 0;
 212:setup.c       **** 	while (1) {
 213:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 213 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 214:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 214 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 215:setup.c       **** 			break;
 216:setup.c       **** 		}
 217:setup.c       **** 		x++;
 218:setup.c       **** 	}
 219:setup.c       **** }
 148               		.loc 1 219 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 220:setup.c       **** 
 221:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 222:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 222 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 223:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 223 0
 167 0050 3A9A      		sbi 0x7,2
 224:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 224 0
 169 0052 949A      		sbi 0x12,4
 225:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 225 0
 171 0054 959A      		sbi 0x12,5
 226:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 226 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 227:setup.c       **** }
 228:setup.c       **** 
 229:setup.c       **** 
 230:setup.c       **** 
 231:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 232:setup.c       **** 
 233:setup.c       **** // Set Gameboy mode
 234:setup.c       **** void gb_mode(void) {
 182               		.loc 1 234 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 235:setup.c       **** 	// Set inputs
 236:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 236 0
 189 005a 15BA      		out 0x15,__zero_reg__
 237:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 237 0
 191 005c 14BA      		out 0x14,__zero_reg__
 238:setup.c       **** 	
 239:setup.c       **** 	// Set outputs
 240:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 240 0
 193 005e 18BA      		out 0x18,__zero_reg__
 241:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 241 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 242:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 242 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 243:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 243 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 244:setup.c       **** }
 245:setup.c       **** 
 246:setup.c       **** // Set the 16 bit address on A15-0
 247:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 247 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 248:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 248 0
 217 006a 9BBB      		out 0x1b,r25
 249:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 249 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 250:setup.c       **** }
 251:setup.c       **** 
 252:setup.c       **** // Set the address and read a byte from the 8 bit data line
 253:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 253 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 254:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 254 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 255:setup.c       **** 	
 256:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 256 0
 239 0072 9498      		cbi 0x12,4
 257:setup.c       **** 	rdPin_low;
 240               		.loc 1 257 0
 241 0074 9598      		cbi 0x12,5
 258:setup.c       **** 	
 259:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 259 0
 243               	/* #APP */
 244               	 ;  259 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 260:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 260 0
 248               	 ;  260 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 261:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 261 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 262:setup.c       **** 	
 263:setup.c       **** 	rdPin_high;
 255               		.loc 1 263 0
 256 007c 959A      		sbi 0x12,5
 264:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 264 0
 258 007e 949A      		sbi 0x12,4
 265:setup.c       **** 	
 266:setup.c       **** 	return data;
 267:setup.c       **** }
 259               		.loc 1 267 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 268:setup.c       **** 
 269:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 270:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 270 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 271:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 271 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 272:setup.c       **** 	
 273:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 273 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 274:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 274 0
 292 0090 D5BB      		out 0x15,r29
 275:setup.c       **** 	
 276:setup.c       **** 	// Pulse WR and mREQ if the type matches
 277:setup.c       **** 	wrPin_low;
 293               		.loc 1 277 0
 294 0092 9698      		cbi 0x12,6
 278:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 278 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 279:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 279 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 280:setup.c       **** 	}
 281:setup.c       **** 	
 282:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 282 0
 302               	/* #APP */
 303               	 ;  282 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 283:setup.c       **** 	
 284:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 284 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 285:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 285 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 286:setup.c       **** 	}
 287:setup.c       **** 	wrPin_high;
 313               		.loc 1 287 0
 314 00a2 969A      		sbi 0x12,6
 288:setup.c       **** 	
 289:setup.c       **** 	// Clear data outputs and set data pins as inputs
 290:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 290 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 291:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 291 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 292:setup.c       **** }
 320               		.loc 1 292 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 293:setup.c       **** 
 294:setup.c       **** 
 295:setup.c       **** 
 296:setup.c       **** // ****** Gameboy Advance functions ****** 
 297:setup.c       **** 
 298:setup.c       **** // Set GBA mode
 299:setup.c       **** void gba_mode(void) {
 333               		.loc 1 299 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 300:setup.c       **** 	// Set outputs for reading ROM addresses as default
 301:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 301 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 302:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 302 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 303:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 303 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 304:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 304 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 305:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 305 0
 349 00b8 8ABB      		out 0x1a,r24
 306:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 306 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 307:setup.c       **** }
 308:setup.c       **** 
 309:setup.c       **** // Set the 24 bit address on A23-0
 310:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 310 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 311:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 311 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 312:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 312 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 313:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 313 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 314:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 314 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 315:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 315 0
 385 00cc 2ABB      		out 0x1a,r18
 316:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 316 0
 387 00ce 27BB      		out 0x17,r18
 317:setup.c       **** 	
 318:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 318 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 319:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 319 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 320:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 320 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 321:setup.c       **** }
 402               		.loc 1 321 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 322:setup.c       **** 
 323:setup.c       **** 
 324:setup.c       **** 
 325:setup.c       **** // ---------- ROM/SRAM ----------
 326:setup.c       **** 
 327:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 328:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 328 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 329:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 329 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 330:setup.c       **** 	
 331:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 331 0
 424 00ec 9498      		cbi 0x12,4
 332:setup.c       **** 	
 333:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 333 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 334:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 334 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 335:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 335 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 336:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 336 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 337:setup.c       **** 	
 338:setup.c       **** 	rdPin_low;
 433               		.loc 1 338 0
 434 00f6 9598      		cbi 0x12,5
 339:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 339 0
 436               	/* #APP */
 437               	 ;  339 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 340:setup.c       **** 	
 341:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 341 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 342:setup.c       **** 	
 343:setup.c       **** 	rdPin_high;
 445               		.loc 1 343 0
 446 00fe 959A      		sbi 0x12,5
 344:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 344 0
 448 0100 949A      		sbi 0x12,4
 345:setup.c       **** 	
 346:setup.c       **** 	return data;
 449               		.loc 1 346 0
 450 0102 90E0      		ldi r25,0
 347:setup.c       **** }
 451               		.loc 1 347 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 348:setup.c       **** 
 349:setup.c       **** // Set the address and read a byte from the 8 bit data line
 350:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 350 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 351:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 351 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 352:setup.c       **** 	
 353:setup.c       **** 	rdPin_low;
 471               		.loc 1 353 0
 472 010a 9598      		cbi 0x12,5
 354:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 473               		.loc 1 354 0
 474 010c 3A98      		cbi 0x7,2
 355:setup.c       **** 	
 356:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 356 0
 476               	/* #APP */
 477               	 ;  356 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 357:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 357 0
 481               	 ;  357 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 358:setup.c       **** 	
 359:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 359 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 360:setup.c       **** 	
 361:setup.c       **** 	cs2Pin_high;
 488               		.loc 1 361 0
 489 0114 3A9A      		sbi 0x7,2
 362:setup.c       **** 	rdPin_high;
 490               		.loc 1 362 0
 491 0116 959A      		sbi 0x12,5
 363:setup.c       **** 	
 364:setup.c       **** 	return data;
 365:setup.c       **** }
 492               		.loc 1 365 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 366:setup.c       **** 
 367:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 368:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 368 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 369:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 369 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 370:setup.c       **** 	
 371:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 371 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 372:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 372 0
 520 0124 C5BB      		out 0x15,r28
 373:setup.c       **** 	
 374:setup.c       **** 	// Pulse WR
 375:setup.c       **** 	wrPin_low;
 521               		.loc 1 375 0
 522 0126 9698      		cbi 0x12,6
 376:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 523               		.loc 1 376 0
 524 0128 3A98      		cbi 0x7,2
 377:setup.c       **** 	
 378:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 378 0
 526               	/* #APP */
 527               	 ;  378 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 379:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 379 0
 531               	 ;  379 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 380:setup.c       **** 	
 381:setup.c       **** 	cs2Pin_high;
 534               		.loc 1 381 0
 535               	/* #NOAPP */
 536 012e 3A9A      		sbi 0x7,2
 382:setup.c       **** 	wrPin_high;
 537               		.loc 1 382 0
 538 0130 969A      		sbi 0x12,6
 383:setup.c       **** 	
 384:setup.c       **** 	// Clear data outputs and set data pins as inputs
 385:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 385 0
 540 0132 15BA      		out 0x15,__zero_reg__
 386:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 386 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 387:setup.c       **** }
 544               		.loc 1 387 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 388:setup.c       **** 
 389:setup.c       **** 
 390:setup.c       **** 
 391:setup.c       **** // ---------- EEPROM ----------
 392:setup.c       **** 
 393:setup.c       **** // Set address/data all high (includes AD0/A23)
 394:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 394 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 395:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 395 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 396:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 396 0
 565 013e 8ABB      		out 0x1a,r24
 397:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 397 0
 567 0140 84BB      		out 0x14,r24
 398:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 398 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 399:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 399 0
 572 0146 8BBB      		out 0x1b,r24
 400:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 400 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 401:setup.c       **** }
 402:setup.c       **** 
 403:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 404:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 404 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 405:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 405 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 406:setup.c       **** 	
 407:setup.c       **** 	int8_t x = 0;
 408:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 408 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 409:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 409 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 410:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 410 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 411:setup.c       **** 		}
 412:setup.c       **** 		else {
 413:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 414:setup.c       **** 		}
 415:setup.c       **** 		x = 15;
 603               		.loc 1 415 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 416:setup.c       **** 	}
 417:setup.c       **** 	else {
 418:setup.c       **** 		if (command == EEPROM_READ) {
 419:setup.c       **** 			address |= (1<<7) | (1<<6);
 420:setup.c       **** 		}
 421:setup.c       **** 		else {
 422:setup.c       **** 			address |= (1<<7);
 423:setup.c       **** 		}
 424:setup.c       **** 		x = 7;
 425:setup.c       **** 	}
 426:setup.c       **** 	
 427:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 428:setup.c       **** 	while (x >= 0) {
 429:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 429 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 413:setup.c       **** 		}
 613               		.loc 1 413 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 418:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 418 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 419:setup.c       **** 		}
 621               		.loc 1 419 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 422:setup.c       **** 		}
 626               		.loc 1 422 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 424:setup.c       **** 	}
 630               		.loc 1 424 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 430:setup.c       **** 			ad0Pin_high;
 431:setup.c       **** 		}
 432:setup.c       **** 		else {
 433:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 433 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 434:setup.c       **** 		}
 435:setup.c       **** 		
 436:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 436 0
 639 0174 9698      		cbi 0x12,6
 437:setup.c       **** 		asm ("nop");
 640               		.loc 1 437 0
 641               	/* #APP */
 642               	 ;  437 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 438:setup.c       **** 		asm ("nop");
 645               		.loc 1 438 0
 646               	 ;  438 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 439:setup.c       **** 		wrPin_high; 
 649               		.loc 1 439 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 440:setup.c       **** 		asm ("nop");
 652               		.loc 1 440 0
 653               	/* #APP */
 654               	 ;  440 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 441:setup.c       **** 		asm ("nop");
 657               		.loc 1 441 0
 658               	 ;  441 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 428:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 428 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 429:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 429 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 430:setup.c       **** 		}
 682               		.loc 1 430 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 442:setup.c       **** 		
 443:setup.c       **** 		x--;
 444:setup.c       **** 	}
 445:setup.c       **** 	
 446:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 447:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 447 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 448:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 448 0
 690 01a4 C098      		cbi 0x18,0
 449:setup.c       **** 		asm ("nop");
 691               		.loc 1 449 0
 692               	/* #APP */
 693               	 ;  449 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 450:setup.c       **** 		wrPin_low;
 696               		.loc 1 450 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 451:setup.c       **** 		asm ("nop");
 699               		.loc 1 451 0
 700               	/* #APP */
 701               	 ;  451 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 452:setup.c       **** 		asm ("nop");
 704               		.loc 1 452 0
 705               	 ;  452 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 453:setup.c       **** 		
 454:setup.c       **** 		wrPin_high;
 708               		.loc 1 454 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 455:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 455 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 456:setup.c       **** 	}
 457:setup.c       **** }
 458:setup.c       **** 
 459:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 460:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 460 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 461:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 461 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 462:setup.c       **** 	
 463:setup.c       **** 	// Set AD0 pin as input
 464:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 464 0
 734 01b8 C098      		cbi 0x18,0
 465:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 465 0
 736 01ba B898      		cbi 0x17,0
 466:setup.c       **** 	
 467:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 467 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB126:
 468:setup.c       **** 	
 469:setup.c       **** 	// Ignore first 4 bits
 470:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 471:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 471 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 472:setup.c       **** 		asm ("nop");
 746               		.loc 1 472 0 discriminator 3
 747               	/* #APP */
 748               	 ;  472 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 473:setup.c       **** 		asm ("nop");
 751               		.loc 1 473 0 discriminator 3
 752               	 ;  473 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 474:setup.c       **** 		rdPin_high; 
 755               		.loc 1 474 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 475:setup.c       **** 		asm ("nop");
 758               		.loc 1 475 0 discriminator 3
 759               	/* #APP */
 760               	 ;  475 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 476:setup.c       **** 		asm ("nop");
 763               		.loc 1 476 0 discriminator 3
 764               	 ;  476 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 470:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 470 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE126:
 776               	.LBB127:
 777               	.LBB128:
 778               	.LBB129:
 477:setup.c       **** 	}
 478:setup.c       **** 	
 479:setup.c       **** 	// Read out 64 bits
 480:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 481:setup.c       **** 		uint8_t data = 0;
 482:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 483:setup.c       **** 			rdPin_low; // CLK
 484:setup.c       **** 			asm ("nop");
 485:setup.c       **** 			asm ("nop");
 486:setup.c       **** 			rdPin_high;
 487:setup.c       **** 			
 488:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 489:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 489 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE129:
 785               	.LBE128:
 786               	.LBE127:
 467:setup.c       **** 	
 787               		.loc 1 467 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB132:
 794               	.LBB131:
 795               	.LBB130:
 483:setup.c       **** 			asm ("nop");
 796               		.loc 1 483 0
 797 01de 9598      		cbi 0x12,5
 484:setup.c       **** 			asm ("nop");
 798               		.loc 1 484 0
 799               	/* #APP */
 800               	 ;  484 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 485:setup.c       **** 			rdPin_high;
 803               		.loc 1 485 0
 804               	 ;  485 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 486:setup.c       **** 			
 807               		.loc 1 486 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 488:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 488 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 489 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE130:
 490:setup.c       **** 			}
 491:setup.c       **** 		}
 492:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 492 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE131:
 480:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 480 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE132:
 493:setup.c       **** 	}
 494:setup.c       **** 	
 495:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 495 0
 841 0206 949A      		sbi 0x12,4
 496:setup.c       **** 	
 497:setup.c       **** 	// Set AD0 pin as output
 498:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 498 0
 843 0208 C09A      		sbi 0x18,0
 499:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 499 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 500:setup.c       **** }
 501:setup.c       **** 
 502:setup.c       **** // Write 8 bytes to the EEPROM address
 503:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 503 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 504:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 504 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 503:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 503 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB133:
 876               	.LBB134:
 505:setup.c       **** 	
 506:setup.c       **** 	// Write 64 bits
 507:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 508:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 509:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 509 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 510:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 510 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 511:setup.c       **** 			}
 512:setup.c       **** 			else {
 513:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 513 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 514:setup.c       **** 			}
 515:setup.c       **** 			
 516:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 516 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 517:setup.c       **** 			asm ("nop");
 899               		.loc 1 517 0 discriminator 2
 900               	/* #APP */
 901               	 ;  517 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 518:setup.c       **** 			asm ("nop");
 904               		.loc 1 518 0 discriminator 2
 905               	 ;  518 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 519:setup.c       **** 			wrPin_high; 
 908               		.loc 1 519 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 520:setup.c       **** 			asm ("nop");
 911               		.loc 1 520 0 discriminator 2
 912               	/* #APP */
 913               	 ;  520 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 521:setup.c       **** 			asm ("nop");
 916               		.loc 1 521 0 discriminator 2
 917               	 ;  521 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE134:
 507:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 507 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE133:
 522:setup.c       **** 		}
 523:setup.c       **** 	}
 524:setup.c       **** 	
 525:setup.c       **** 	// Last bit low
 526:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 526 0
 935 0250 C098      		cbi 0x18,0
 527:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 527 0
 937 0252 9698      		cbi 0x12,6
 528:setup.c       **** 	asm ("nop");
 938               		.loc 1 528 0
 939               	/* #APP */
 940               	 ;  528 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 529:setup.c       **** 	asm ("nop");
 943               		.loc 1 529 0
 944               	 ;  529 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 530:setup.c       **** 	wrPin_high; 
 947               		.loc 1 530 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 531:setup.c       **** 	asm ("nop");
 950               		.loc 1 531 0
 951               	/* #APP */
 952               	 ;  531 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 532:setup.c       **** 	asm ("nop");
 955               		.loc 1 532 0
 956               	 ;  532 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 533:setup.c       **** 	
 534:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 534 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 535:setup.c       **** }
 536:setup.c       **** 
 537:setup.c       **** 
 538:setup.c       **** 
 539:setup.c       **** // ---------- FLASH ----------
 540:setup.c       **** 
 541:setup.c       **** // Set the address and data for the write byte cycle to the flash
 542:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 542 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 543:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 543 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 544:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 544 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 545:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 545 0
 989 026c C5BB      		out 0x15,r28
 546:setup.c       **** 	
 547:setup.c       **** 	wrPin_low;
 990               		.loc 1 547 0
 991 026e 9698      		cbi 0x12,6
 548:setup.c       **** 	cs2Pin_low;
 992               		.loc 1 548 0
 993 0270 3A98      		cbi 0x7,2
 549:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 549 0
 995               	/* #APP */
 996               	 ;  549 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 550:setup.c       **** 	wrPin_high;
 999               		.loc 1 550 0
 1000               	/* #NOAPP */
 1001 0274 969A      		sbi 0x12,6
 551:setup.c       **** 	cs2Pin_high;
 1002               		.loc 1 551 0
 1003 0276 3A9A      		sbi 0x7,2
 1004               	/* epilogue start */
 552:setup.c       **** }
 1005               		.loc 1 552 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 553:setup.c       **** 
 554:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 555:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 555 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 556:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 556 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 557:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 557 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 558:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 558 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB135:
 1049               	.LBB136:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE136:
 1060               	.LBE135:
 559:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 560:setup.c       **** 	
 561:setup.c       **** 	// Set data as inputs
 562:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 562 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 563:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 563 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 564:setup.c       **** 	
 565:setup.c       **** 	// Read and transmit the 2 bytes
 566:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 566 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 567:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 567 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 568:setup.c       **** 	
 569:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 569 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 570:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 570 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 571:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 571 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB137:
 1098               	.LBB138:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE138:
 1109               	.LBE137:
 572:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 573:setup.c       **** }
 1110               		.loc 1 573 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 574:setup.c       **** 
 575:setup.c       **** // Switch banks on the Flash
 576:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 576 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 577:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 577 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 578:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 578 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 579:setup.c       **** 	
 580:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 580 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 581:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 581 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 582:setup.c       **** }
 1157               		.loc 1 582 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 581:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 581 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 583:setup.c       **** 
 584:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 585:setup.c       **** // Takes 25ms after last command to erase sector
 586:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 586 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 587:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 587 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 588:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 588 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 589:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 589 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 590:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 590 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 591:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 591 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 592:setup.c       **** 	
 593:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 593 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB139:
 1222               	.LBB140:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE140:
 1233               	.LBE139:
 594:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 595:setup.c       **** }
 1234               		.loc 1 595 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 596:setup.c       **** 
 597:setup.c       **** // Write a single byte to the Flash address
 598:setup.c       **** // Takes 20us to program Flash
 599:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 599 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 600:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 600 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 601:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 601 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 602:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 602 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 603:setup.c       **** 	
 604:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 604 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB141:
 1292               	.LBB142:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE142:
 1301               	.LBE141:
 605:setup.c       **** 	_delay_us(20); // Wait byte program time
 606:setup.c       **** }
 1302               		.loc 1 606 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 607:setup.c       **** 
 608:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 609:setup.c       **** // Takes 20ms for write cycle
 610:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 610 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 611:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 611 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 612:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 612 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 613:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 613 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB143:
 614:setup.c       **** 	
 615:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 616:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 617:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 617 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 617 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 616:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 616 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE143:
 1400               	.LBB144:
 1401               	.LBB145:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE145:
 1412               	.LBE144:
 618:setup.c       **** 	}
 619:setup.c       **** 	_delay_ms(20); // Wait sector program time
 620:setup.c       **** }
 1413               		.loc 1 620 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 621:setup.c       **** 
 622:setup.c       **** 
 623:setup.c       **** 
 624:setup.c       **** // ---------- GB FLASH CARTS ----------
 625:setup.c       **** 
 626:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 627:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 627 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 628:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 628 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 629:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 629 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 630:setup.c       **** 	
 631:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 631 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 632:setup.c       **** 	
 633:setup.c       **** 	rdPin_low;
 1443               		.loc 1 633 0
 1444 03fe 9598      		cbi 0x12,5
 634:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 634 0
 1446               	/* #APP */
 1447               	 ;  634 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 635:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 635 0
 1451               	 ;  635 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 636:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 636 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 637:setup.c       **** 	rdPin_high;
 1458               		.loc 1 637 0
 1459 0406 959A      		sbi 0x12,5
 638:setup.c       **** 	
 639:setup.c       **** 	return data;
 640:setup.c       **** }
 1460               		.loc 1 640 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_write_bus_cycle
 1467               	gb_flash_write_bus_cycle:
 1468               	.LFB37:
 641:setup.c       **** 
 642:setup.c       **** // Set the address and data for the write byte cycle to the flash
 643:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 643 0
 1470               		.cfi_startproc
 1471               	.LVL116:
 1472 040a CF93      		push r28
 1473               	.LCFI25:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 1 */
 1479               	.L__stack_usage = 1
 1480 040c C62F      		mov r28,r22
 644:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1481               		.loc 1 644 0
 1482 040e 2FEF      		ldi r18,lo8(-1)
 1483 0410 24BB      		out 0x14,r18
 645:setup.c       **** 	set_16bit_address(address);
 1484               		.loc 1 645 0
 1485 0412 00D0      		rcall set_16bit_address
 1486               	.LVL117:
 646:setup.c       **** 	PORT_DATA7_0 = data;
 1487               		.loc 1 646 0
 1488 0414 C5BB      		out 0x15,r28
 647:setup.c       **** 	
 648:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1489               		.loc 1 648 0
 1490 0416 8091 0000 		lds r24,flashWriteWePin
 1491 041a 8134      		cpi r24,lo8(65)
 1492 041c 01F4      		brne .L70
 649:setup.c       **** 		audioPin_low; // WE low
 1493               		.loc 1 649 0
 1494 041e 3998      		cbi 0x7,1
 650:setup.c       **** 		asm volatile("nop");
 1495               		.loc 1 650 0
 1496               	/* #APP */
 1497               	 ;  650 "setup.c" 1
 1498 0420 0000      		nop
 1499               	 ;  0 "" 2
 651:setup.c       **** 		asm volatile("nop");
 1500               		.loc 1 651 0
 1501               	 ;  651 "setup.c" 1
 1502 0422 0000      		nop
 1503               	 ;  0 "" 2
 652:setup.c       **** 		asm volatile("nop");
 1504               		.loc 1 652 0
 1505               	 ;  652 "setup.c" 1
 1506 0424 0000      		nop
 1507               	 ;  0 "" 2
 653:setup.c       **** 		audioPin_high; // WE high
 1508               		.loc 1 653 0
 1509               	/* #NOAPP */
 1510 0426 399A      		sbi 0x7,1
 1511 0428 00C0      		rjmp .L71
 1512               	.L70:
 654:setup.c       **** 	}
 655:setup.c       **** 	else { // WR pin
 656:setup.c       **** 		wrPin_low; // WE low
 1513               		.loc 1 656 0
 1514 042a 9698      		cbi 0x12,6
 657:setup.c       **** 		asm volatile("nop");
 1515               		.loc 1 657 0
 1516               	/* #APP */
 1517               	 ;  657 "setup.c" 1
 1518 042c 0000      		nop
 1519               	 ;  0 "" 2
 658:setup.c       **** 		asm volatile("nop");
 1520               		.loc 1 658 0
 1521               	 ;  658 "setup.c" 1
 1522 042e 0000      		nop
 1523               	 ;  0 "" 2
 659:setup.c       **** 		asm volatile("nop");
 1524               		.loc 1 659 0
 1525               	 ;  659 "setup.c" 1
 1526 0430 0000      		nop
 1527               	 ;  0 "" 2
 660:setup.c       **** 		wrPin_high; // WE high
 1528               		.loc 1 660 0
 1529               	/* #NOAPP */
 1530 0432 969A      		sbi 0x12,6
 1531               	.L71:
 661:setup.c       **** 	}
 662:setup.c       **** 	
 663:setup.c       **** 	// Clear data outputs and set data pins as inputs
 664:setup.c       **** 	PORT_DATA7_0 = 0;
 1532               		.loc 1 664 0
 1533 0434 15BA      		out 0x15,__zero_reg__
 665:setup.c       **** 	DDR_DATA7_0 = 0;
 1534               		.loc 1 665 0
 1535 0436 14BA      		out 0x14,__zero_reg__
 1536               	/* epilogue start */
 666:setup.c       **** }
 1537               		.loc 1 666 0
 1538 0438 CF91      		pop r28
 1539               	.LVL118:
 1540 043a 0895      		ret
 1541               		.cfi_endproc
 1542               	.LFE37:
 1544               	.global	gb_flash_write_byte
 1546               	gb_flash_write_byte:
 1547               	.LFB38:
 667:setup.c       **** 
 668:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 669:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1548               		.loc 1 669 0
 1549               		.cfi_startproc
 1550               	.LVL119:
 1551 043c 1F93      		push r17
 1552               	.LCFI26:
 1553               		.cfi_def_cfa_offset 3
 1554               		.cfi_offset 17, -2
 1555 043e CF93      		push r28
 1556               	.LCFI27:
 1557               		.cfi_def_cfa_offset 4
 1558               		.cfi_offset 28, -3
 1559 0440 DF93      		push r29
 1560               	.LCFI28:
 1561               		.cfi_def_cfa_offset 5
 1562               		.cfi_offset 29, -4
 1563               	/* prologue: function */
 1564               	/* frame size = 0 */
 1565               	/* stack size = 3 */
 1566               	.L__stack_usage = 3
 1567 0442 EC01      		movw r28,r24
 1568 0444 162F      		mov r17,r22
 670:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1569               		.loc 1 670 0
 1570 0446 6091 0000 		lds r22,flashWriteCycle+2
 1571               	.LVL120:
 1572 044a 8091 0000 		lds r24,flashWriteCycle
 1573 044e 9091 0000 		lds r25,flashWriteCycle+1
 1574               	.LVL121:
 1575 0452 00D0      		rcall gb_flash_write_bus_cycle
 1576               	.LVL122:
 671:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1577               		.loc 1 671 0
 1578 0454 6091 0000 		lds r22,flashWriteCycle+6
 1579 0458 8091 0000 		lds r24,flashWriteCycle+4
 1580 045c 9091 0000 		lds r25,flashWriteCycle+4+1
 1581 0460 00D0      		rcall gb_flash_write_bus_cycle
 1582               	.LVL123:
 672:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1583               		.loc 1 672 0
 1584 0462 6091 0000 		lds r22,flashWriteCycle+10
 1585 0466 8091 0000 		lds r24,flashWriteCycle+8
 1586 046a 9091 0000 		lds r25,flashWriteCycle+8+1
 1587 046e 00D0      		rcall gb_flash_write_bus_cycle
 1588               	.LVL124:
 673:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1589               		.loc 1 673 0
 1590 0470 612F      		mov r22,r17
 1591 0472 CE01      		movw r24,r28
 1592 0474 00D0      		rcall gb_flash_write_bus_cycle
 1593               	.LVL125:
 1594               	.LBB146:
 1595               	.LBB147:
 1596               		.loc 2 276 0
 1597 0476 8AE1      		ldi r24,lo8(26)
 1598 0478 8A95      	1:	dec r24
 1599 047a 01F4      		brne 1b
 1600 047c 00C0      		rjmp .
 1601               	.LVL126:
 1602               	.LBE147:
 1603               	.LBE146:
 674:setup.c       **** 	_delay_us(10); // Wait byte program time
 675:setup.c       **** 	
 676:setup.c       **** 	// Set data pins inputs
 677:setup.c       **** 	PORT_DATA7_0 = 0;
 1604               		.loc 1 677 0
 1605 047e 15BA      		out 0x15,__zero_reg__
 678:setup.c       **** 	DDR_DATA7_0 = 0;
 1606               		.loc 1 678 0
 1607 0480 14BA      		out 0x14,__zero_reg__
 679:setup.c       **** 	
 680:setup.c       **** 	// Verify data
 681:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1608               		.loc 1 681 0
 1609 0482 CE01      		movw r24,r28
 1610 0484 00D0      		rcall gb_flash_read_byte
 1611               	.LVL127:
 1612               	.L73:
 682:setup.c       **** 	while (data != dataVerify) {
 1613               		.loc 1 682 0
 1614 0486 8117      		cp r24,r17
 1615 0488 01F0      		breq .L75
 683:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1616               		.loc 1 683 0
 1617 048a CE01      		movw r24,r28
 1618               	.LVL128:
 1619 048c 00D0      		rcall gb_flash_read_byte
 1620               	.LVL129:
 1621               	.LBB148:
 1622               	.LBB149:
 1623               		.loc 2 276 0
 1624 048e 9DE0      		ldi r25,lo8(13)
 1625 0490 9A95      	1:	dec r25
 1626 0492 01F4      		brne 1b
 1627 0494 0000      		nop
 1628 0496 00C0      		rjmp .L73
 1629               	.LVL130:
 1630               	.L75:
 1631               	/* epilogue start */
 1632               	.LBE149:
 1633               	.LBE148:
 684:setup.c       **** 		_delay_us(5);
 685:setup.c       **** 	}
 686:setup.c       **** }
 1634               		.loc 1 686 0
 1635 0498 DF91      		pop r29
 1636 049a CF91      		pop r28
 1637               	.LVL131:
 1638 049c 1F91      		pop r17
 1639               	.LVL132:
 1640 049e 0895      		ret
 1641               		.cfi_endproc
 1642               	.LFE38:
 1644               	.global	gb_flash_write_byte_bank1_commands
 1646               	gb_flash_write_byte_bank1_commands:
 1647               	.LFB39:
 687:setup.c       **** 
 688:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 689:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 690:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1648               		.loc 1 690 0
 1649               		.cfi_startproc
 1650               	.LVL133:
 1651 04a0 FF92      		push r15
 1652               	.LCFI29:
 1653               		.cfi_def_cfa_offset 3
 1654               		.cfi_offset 15, -2
 1655 04a2 0F93      		push r16
 1656               	.LCFI30:
 1657               		.cfi_def_cfa_offset 4
 1658               		.cfi_offset 16, -3
 1659 04a4 1F93      		push r17
 1660               	.LCFI31:
 1661               		.cfi_def_cfa_offset 5
 1662               		.cfi_offset 17, -4
 1663 04a6 CF93      		push r28
 1664               	.LCFI32:
 1665               		.cfi_def_cfa_offset 6
 1666               		.cfi_offset 28, -5
 1667 04a8 DF93      		push r29
 1668               	.LCFI33:
 1669               		.cfi_def_cfa_offset 7
 1670               		.cfi_offset 29, -6
 1671               	/* prologue: function */
 1672               	/* frame size = 0 */
 1673               	/* stack size = 5 */
 1674               	.L__stack_usage = 5
 1675 04aa EC01      		movw r28,r24
 1676 04ac 162F      		mov r17,r22
 691:setup.c       **** 	// Set bank 1
 692:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1677               		.loc 1 692 0
 1678 04ae FF24      		clr r15
 1679 04b0 FA94      		dec r15
 1680 04b2 F4BA      		out 0x14,r15
 1681               	.LVL134:
 1682               	.LBB150:
 1683               	.LBB151:
 248:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1684               		.loc 1 248 0
 1685 04b4 01E2      		ldi r16,lo8(33)
 1686 04b6 0BBB      		out 0x1b,r16
 249:setup.c       **** }
 1687               		.loc 1 249 0
 1688 04b8 18BA      		out 0x18,__zero_reg__
 1689               	.LVL135:
 1690               	.LBE151:
 1691               	.LBE150:
 693:setup.c       **** 	set_16bit_address(0x2100);
 694:setup.c       **** 	PORT_DATA7_0 = 1;
 1692               		.loc 1 694 0
 1693 04ba 81E0      		ldi r24,lo8(1)
 1694               	.LVL136:
 1695 04bc 85BB      		out 0x15,r24
 695:setup.c       **** 	wrPin_low; // Pulse WR
 1696               		.loc 1 695 0
 1697 04be 9698      		cbi 0x12,6
 696:setup.c       **** 	asm volatile("nop");
 1698               		.loc 1 696 0
 1699               	/* #APP */
 1700               	 ;  696 "setup.c" 1
 1701 04c0 0000      		nop
 1702               	 ;  0 "" 2
 697:setup.c       **** 	wrPin_high;
 1703               		.loc 1 697 0
 1704               	/* #NOAPP */
 1705 04c2 969A      		sbi 0x12,6
 698:setup.c       **** 	
 699:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1706               		.loc 1 699 0
 1707 04c4 6091 0000 		lds r22,flashWriteCycle+2
 1708               	.LVL137:
 1709 04c8 8091 0000 		lds r24,flashWriteCycle
 1710 04cc 9091 0000 		lds r25,flashWriteCycle+1
 1711 04d0 00D0      		rcall gb_flash_write_bus_cycle
 1712               	.LVL138:
 700:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1713               		.loc 1 700 0
 1714 04d2 6091 0000 		lds r22,flashWriteCycle+6
 1715 04d6 8091 0000 		lds r24,flashWriteCycle+4
 1716 04da 9091 0000 		lds r25,flashWriteCycle+4+1
 1717 04de 00D0      		rcall gb_flash_write_bus_cycle
 1718               	.LVL139:
 701:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1719               		.loc 1 701 0
 1720 04e0 6091 0000 		lds r22,flashWriteCycle+10
 1721 04e4 8091 0000 		lds r24,flashWriteCycle+8
 1722 04e8 9091 0000 		lds r25,flashWriteCycle+8+1
 1723 04ec 00D0      		rcall gb_flash_write_bus_cycle
 1724               	.LVL140:
 702:setup.c       **** 	
 703:setup.c       **** 	
 704:setup.c       **** 	// Set bank back
 705:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1725               		.loc 1 705 0
 1726 04ee F4BA      		out 0x14,r15
 1727               	.LVL141:
 1728               	.LBB152:
 1729               	.LBB153:
 248:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1730               		.loc 1 248 0
 1731 04f0 0BBB      		out 0x1b,r16
 249:setup.c       **** }
 1732               		.loc 1 249 0
 1733 04f2 18BA      		out 0x18,__zero_reg__
 1734               	.LVL142:
 1735               	.LBE153:
 1736               	.LBE152:
 706:setup.c       **** 	set_16bit_address(0x2100);
 707:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1737               		.loc 1 707 0
 1738 04f4 8091 0000 		lds r24,lastBankAccessed
 1739 04f8 85BB      		out 0x15,r24
 708:setup.c       **** 	wrPin_low; // Pulse WR
 1740               		.loc 1 708 0
 1741 04fa 9698      		cbi 0x12,6
 709:setup.c       **** 	asm volatile("nop");
 1742               		.loc 1 709 0
 1743               	/* #APP */
 1744               	 ;  709 "setup.c" 1
 1745 04fc 0000      		nop
 1746               	 ;  0 "" 2
 710:setup.c       **** 	wrPin_high;
 1747               		.loc 1 710 0
 1748               	/* #NOAPP */
 1749 04fe 969A      		sbi 0x12,6
 711:setup.c       **** 	
 712:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1750               		.loc 1 712 0
 1751 0500 612F      		mov r22,r17
 1752 0502 CE01      		movw r24,r28
 1753 0504 00D0      		rcall gb_flash_write_bus_cycle
 1754               	.LVL143:
 1755               	.LBB154:
 1756               	.LBB155:
 1757               		.loc 2 276 0
 1758 0506 8AE1      		ldi r24,lo8(26)
 1759 0508 8A95      	1:	dec r24
 1760 050a 01F4      		brne 1b
 1761 050c 00C0      		rjmp .
 1762               	.LVL144:
 1763               	.LBE155:
 1764               	.LBE154:
 713:setup.c       **** 	_delay_us(10); // Wait byte program time
 714:setup.c       **** 	
 715:setup.c       **** 	// Set data pins inputs
 716:setup.c       **** 	PORT_DATA7_0 = 0;
 1765               		.loc 1 716 0
 1766 050e 15BA      		out 0x15,__zero_reg__
 717:setup.c       **** 	DDR_DATA7_0 = 0;
 1767               		.loc 1 717 0
 1768 0510 14BA      		out 0x14,__zero_reg__
 718:setup.c       **** 	
 719:setup.c       **** 	// Verify data
 720:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1769               		.loc 1 720 0
 1770 0512 CE01      		movw r24,r28
 1771 0514 00D0      		rcall gb_flash_read_byte
 1772               	.LVL145:
 1773               	.L77:
 721:setup.c       **** 	while (data != dataVerify) {
 1774               		.loc 1 721 0
 1775 0516 8117      		cp r24,r17
 1776 0518 01F0      		breq .L79
 722:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1777               		.loc 1 722 0
 1778 051a CE01      		movw r24,r28
 1779               	.LVL146:
 1780 051c 00D0      		rcall gb_flash_read_byte
 1781               	.LVL147:
 1782               	.LBB156:
 1783               	.LBB157:
 1784               		.loc 2 276 0
 1785 051e 9DE0      		ldi r25,lo8(13)
 1786 0520 9A95      	1:	dec r25
 1787 0522 01F4      		brne 1b
 1788 0524 0000      		nop
 1789 0526 00C0      		rjmp .L77
 1790               	.LVL148:
 1791               	.L79:
 1792               	/* epilogue start */
 1793               	.LBE157:
 1794               	.LBE156:
 723:setup.c       **** 		_delay_us(5);
 724:setup.c       **** 	}
 725:setup.c       **** }
 1795               		.loc 1 725 0
 1796 0528 DF91      		pop r29
 1797 052a CF91      		pop r28
 1798               	.LVL149:
 1799 052c 1F91      		pop r17
 1800               	.LVL150:
 1801 052e 0F91      		pop r16
 1802 0530 FF90      		pop r15
 1803 0532 0895      		ret
 1804               		.cfi_endproc
 1805               	.LFE39:
 1807               	.global	gba_flash_write_bus_cycle
 1809               	gba_flash_write_bus_cycle:
 1810               	.LFB40:
 726:setup.c       **** 
 727:setup.c       **** 
 728:setup.c       **** 
 729:setup.c       **** // ---------- GBA FLASH CARTS ----------
 730:setup.c       **** 
 731:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 732:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1811               		.loc 1 732 0
 1812               		.cfi_startproc
 1813               	.LVL151:
 1814 0534 0F93      		push r16
 1815               	.LCFI34:
 1816               		.cfi_def_cfa_offset 3
 1817               		.cfi_offset 16, -2
 1818 0536 1F93      		push r17
 1819               	.LCFI35:
 1820               		.cfi_def_cfa_offset 4
 1821               		.cfi_offset 17, -3
 1822               	/* prologue: function */
 1823               	/* frame size = 0 */
 1824               	/* stack size = 2 */
 1825               	.L__stack_usage = 2
 733:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 1826               		.loc 1 733 0
 1827 0538 8C01      		movw r16,r24
 1828 053a 2227      		clr r18
 1829 053c 3327      		clr r19
 1830 053e 05BB      		out 0x15,r16
 734:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 1831               		.loc 1 734 0
 1832 0540 072F      		mov r16,r23
 1833 0542 182F      		mov r17,r24
 1834 0544 292F      		mov r18,r25
 1835 0546 3327      		clr r19
 1836 0548 0BBB      		out 0x1b,r16
 735:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 1837               		.loc 1 735 0
 1838 054a 68BB      		out 0x18,r22
 736:setup.c       **** 	
 737:setup.c       **** 	cs_mreqPin_low;
 1839               		.loc 1 737 0
 1840 054c 9498      		cbi 0x12,4
 738:setup.c       **** 	
 739:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1841               		.loc 1 739 0
 1842 054e 5BBB      		out 0x1b,r21
 740:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1843               		.loc 1 740 0
 1844 0550 48BB      		out 0x18,r20
 741:setup.c       **** 	
 742:setup.c       **** 	wrPin_low;
 1845               		.loc 1 742 0
 1846 0552 9698      		cbi 0x12,6
 743:setup.c       **** 	asm volatile("nop");
 1847               		.loc 1 743 0
 1848               	/* #APP */
 1849               	 ;  743 "setup.c" 1
 1850 0554 0000      		nop
 1851               	 ;  0 "" 2
 744:setup.c       **** 	asm volatile("nop");
 1852               		.loc 1 744 0
 1853               	 ;  744 "setup.c" 1
 1854 0556 0000      		nop
 1855               	 ;  0 "" 2
 745:setup.c       **** 	asm volatile("nop");
 1856               		.loc 1 745 0
 1857               	 ;  745 "setup.c" 1
 1858 0558 0000      		nop
 1859               	 ;  0 "" 2
 746:setup.c       **** 	wrPin_high;
 1860               		.loc 1 746 0
 1861               	/* #NOAPP */
 1862 055a 969A      		sbi 0x12,6
 747:setup.c       **** 	cs_mreqPin_high;
 1863               		.loc 1 747 0
 1864 055c 949A      		sbi 0x12,4
 1865               	/* epilogue start */
 748:setup.c       **** }
 1866               		.loc 1 748 0
 1867 055e 1F91      		pop r17
 1868 0560 0F91      		pop r16
 1869 0562 0895      		ret
 1870               		.cfi_endproc
 1871               	.LFE40:
 1873               	.global	gba_flash_write_cycle_start_swapped
 1875               	gba_flash_write_cycle_start_swapped:
 1876               	.LFB41:
 749:setup.c       **** 
 750:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 751:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 1877               		.loc 1 751 0
 1878               		.cfi_startproc
 1879               	/* prologue: function */
 1880               	/* frame size = 0 */
 1881               	/* stack size = 0 */
 1882               	.L__stack_usage = 0
 752:setup.c       **** 	// Set outputs
 753:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 1883               		.loc 1 753 0
 1884 0564 8FEF      		ldi r24,lo8(-1)
 1885 0566 84BB      		out 0x14,r24
 754:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 1886               		.loc 1 754 0
 1887 0568 8ABB      		out 0x1a,r24
 755:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 1888               		.loc 1 755 0
 1889 056a 87BB      		out 0x17,r24
 756:setup.c       **** 	
 757:setup.c       **** 	// 0x555, 0xA9
 758:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1890               		.loc 1 758 0
 1891 056c 15BA      		out 0x15,__zero_reg__
 759:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1892               		.loc 1 759 0
 1893 056e 95E0      		ldi r25,lo8(5)
 1894 0570 9BBB      		out 0x1b,r25
 760:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1895               		.loc 1 760 0
 1896 0572 85E5      		ldi r24,lo8(85)
 1897 0574 88BB      		out 0x18,r24
 761:setup.c       **** 	cs_mreqPin_low;
 1898               		.loc 1 761 0
 1899 0576 9498      		cbi 0x12,4
 762:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1900               		.loc 1 762 0
 1901 0578 1BBA      		out 0x1b,__zero_reg__
 763:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 1902               		.loc 1 763 0
 1903 057a 29EA      		ldi r18,lo8(-87)
 1904 057c 28BB      		out 0x18,r18
 764:setup.c       **** 	wrPin_low;
 1905               		.loc 1 764 0
 1906 057e 9698      		cbi 0x12,6
 765:setup.c       **** 	asm volatile("nop");
 1907               		.loc 1 765 0
 1908               	/* #APP */
 1909               	 ;  765 "setup.c" 1
 1910 0580 0000      		nop
 1911               	 ;  0 "" 2
 766:setup.c       **** 	asm volatile("nop");
 1912               		.loc 1 766 0
 1913               	 ;  766 "setup.c" 1
 1914 0582 0000      		nop
 1915               	 ;  0 "" 2
 767:setup.c       **** 	asm volatile("nop");
 1916               		.loc 1 767 0
 1917               	 ;  767 "setup.c" 1
 1918 0584 0000      		nop
 1919               	 ;  0 "" 2
 768:setup.c       **** 	wrPin_high;
 1920               		.loc 1 768 0
 1921               	/* #NOAPP */
 1922 0586 969A      		sbi 0x12,6
 769:setup.c       **** 	cs_mreqPin_high;
 1923               		.loc 1 769 0
 1924 0588 949A      		sbi 0x12,4
 770:setup.c       **** 	
 771:setup.c       **** 	// 0x2AA, 0x56
 772:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1925               		.loc 1 772 0
 1926 058a 15BA      		out 0x15,__zero_reg__
 773:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 1927               		.loc 1 773 0
 1928 058c 22E0      		ldi r18,lo8(2)
 1929 058e 2BBB      		out 0x1b,r18
 774:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 1930               		.loc 1 774 0
 1931 0590 2AEA      		ldi r18,lo8(-86)
 1932 0592 28BB      		out 0x18,r18
 775:setup.c       **** 	cs_mreqPin_low;
 1933               		.loc 1 775 0
 1934 0594 9498      		cbi 0x12,4
 776:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1935               		.loc 1 776 0
 1936 0596 1BBA      		out 0x1b,__zero_reg__
 777:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 1937               		.loc 1 777 0
 1938 0598 26E5      		ldi r18,lo8(86)
 1939 059a 28BB      		out 0x18,r18
 778:setup.c       **** 	wrPin_low;
 1940               		.loc 1 778 0
 1941 059c 9698      		cbi 0x12,6
 779:setup.c       **** 	asm volatile("nop");
 1942               		.loc 1 779 0
 1943               	/* #APP */
 1944               	 ;  779 "setup.c" 1
 1945 059e 0000      		nop
 1946               	 ;  0 "" 2
 780:setup.c       **** 	asm volatile("nop");
 1947               		.loc 1 780 0
 1948               	 ;  780 "setup.c" 1
 1949 05a0 0000      		nop
 1950               	 ;  0 "" 2
 781:setup.c       **** 	asm volatile("nop");
 1951               		.loc 1 781 0
 1952               	 ;  781 "setup.c" 1
 1953 05a2 0000      		nop
 1954               	 ;  0 "" 2
 782:setup.c       **** 	wrPin_high;
 1955               		.loc 1 782 0
 1956               	/* #NOAPP */
 1957 05a4 969A      		sbi 0x12,6
 783:setup.c       **** 	cs_mreqPin_high;
 1958               		.loc 1 783 0
 1959 05a6 949A      		sbi 0x12,4
 784:setup.c       **** 	
 785:setup.c       **** 	// 0x555, 0xA0;
 786:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1960               		.loc 1 786 0
 1961 05a8 15BA      		out 0x15,__zero_reg__
 787:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1962               		.loc 1 787 0
 1963 05aa 9BBB      		out 0x1b,r25
 788:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1964               		.loc 1 788 0
 1965 05ac 88BB      		out 0x18,r24
 789:setup.c       **** 	cs_mreqPin_low;
 1966               		.loc 1 789 0
 1967 05ae 9498      		cbi 0x12,4
 790:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1968               		.loc 1 790 0
 1969 05b0 1BBA      		out 0x1b,__zero_reg__
 791:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 1970               		.loc 1 791 0
 1971 05b2 80EA      		ldi r24,lo8(-96)
 1972 05b4 88BB      		out 0x18,r24
 792:setup.c       **** 	wrPin_low;
 1973               		.loc 1 792 0
 1974 05b6 9698      		cbi 0x12,6
 793:setup.c       **** 	asm volatile("nop");
 1975               		.loc 1 793 0
 1976               	/* #APP */
 1977               	 ;  793 "setup.c" 1
 1978 05b8 0000      		nop
 1979               	 ;  0 "" 2
 794:setup.c       **** 	asm volatile("nop");
 1980               		.loc 1 794 0
 1981               	 ;  794 "setup.c" 1
 1982 05ba 0000      		nop
 1983               	 ;  0 "" 2
 795:setup.c       **** 	asm volatile("nop");
 1984               		.loc 1 795 0
 1985               	 ;  795 "setup.c" 1
 1986 05bc 0000      		nop
 1987               	 ;  0 "" 2
 796:setup.c       **** 	wrPin_high;
 1988               		.loc 1 796 0
 1989               	/* #NOAPP */
 1990 05be 969A      		sbi 0x12,6
 797:setup.c       **** 	cs_mreqPin_high;
 1991               		.loc 1 797 0
 1992 05c0 949A      		sbi 0x12,4
 1993 05c2 0895      		ret
 1994               		.cfi_endproc
 1995               	.LFE41:
 1997               	.global	gba_flash_write_cycle_start
 1999               	gba_flash_write_cycle_start:
 2000               	.LFB42:
 798:setup.c       **** }
 799:setup.c       **** 
 800:setup.c       **** 
 801:setup.c       **** // Send the first 3 write cycles to the flash
 802:setup.c       **** void gba_flash_write_cycle_start(void) {
 2001               		.loc 1 802 0
 2002               		.cfi_startproc
 2003               	/* prologue: function */
 2004               	/* frame size = 0 */
 2005               	/* stack size = 0 */
 2006               	.L__stack_usage = 0
 803:setup.c       **** 	// Set outputs
 804:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2007               		.loc 1 804 0
 2008 05c4 8FEF      		ldi r24,lo8(-1)
 2009 05c6 84BB      		out 0x14,r24
 805:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2010               		.loc 1 805 0
 2011 05c8 8ABB      		out 0x1a,r24
 806:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2012               		.loc 1 806 0
 2013 05ca 87BB      		out 0x17,r24
 807:setup.c       **** 	
 808:setup.c       **** 	// 0x555, 0xAA
 809:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2014               		.loc 1 809 0
 2015 05cc 15BA      		out 0x15,__zero_reg__
 810:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2016               		.loc 1 810 0
 2017 05ce 95E0      		ldi r25,lo8(5)
 2018 05d0 9BBB      		out 0x1b,r25
 811:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2019               		.loc 1 811 0
 2020 05d2 85E5      		ldi r24,lo8(85)
 2021 05d4 88BB      		out 0x18,r24
 812:setup.c       **** 	cs_mreqPin_low;
 2022               		.loc 1 812 0
 2023 05d6 9498      		cbi 0x12,4
 813:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2024               		.loc 1 813 0
 2025 05d8 1BBA      		out 0x1b,__zero_reg__
 814:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2026               		.loc 1 814 0
 2027 05da 2AEA      		ldi r18,lo8(-86)
 2028 05dc 28BB      		out 0x18,r18
 815:setup.c       **** 	wrPin_low;
 2029               		.loc 1 815 0
 2030 05de 9698      		cbi 0x12,6
 816:setup.c       **** 	asm volatile("nop");
 2031               		.loc 1 816 0
 2032               	/* #APP */
 2033               	 ;  816 "setup.c" 1
 2034 05e0 0000      		nop
 2035               	 ;  0 "" 2
 817:setup.c       **** 	asm volatile("nop");
 2036               		.loc 1 817 0
 2037               	 ;  817 "setup.c" 1
 2038 05e2 0000      		nop
 2039               	 ;  0 "" 2
 818:setup.c       **** 	asm volatile("nop");
 2040               		.loc 1 818 0
 2041               	 ;  818 "setup.c" 1
 2042 05e4 0000      		nop
 2043               	 ;  0 "" 2
 819:setup.c       **** 	wrPin_high;
 2044               		.loc 1 819 0
 2045               	/* #NOAPP */
 2046 05e6 969A      		sbi 0x12,6
 820:setup.c       **** 	cs_mreqPin_high;
 2047               		.loc 1 820 0
 2048 05e8 949A      		sbi 0x12,4
 821:setup.c       **** 	
 822:setup.c       **** 	// 0x2AA, 0x55
 823:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2049               		.loc 1 823 0
 2050 05ea 15BA      		out 0x15,__zero_reg__
 824:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2051               		.loc 1 824 0
 2052 05ec 32E0      		ldi r19,lo8(2)
 2053 05ee 3BBB      		out 0x1b,r19
 825:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2054               		.loc 1 825 0
 2055 05f0 28BB      		out 0x18,r18
 826:setup.c       **** 	cs_mreqPin_low;
 2056               		.loc 1 826 0
 2057 05f2 9498      		cbi 0x12,4
 827:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2058               		.loc 1 827 0
 2059 05f4 1BBA      		out 0x1b,__zero_reg__
 828:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2060               		.loc 1 828 0
 2061 05f6 88BB      		out 0x18,r24
 829:setup.c       **** 	wrPin_low;
 2062               		.loc 1 829 0
 2063 05f8 9698      		cbi 0x12,6
 830:setup.c       **** 	asm volatile("nop");
 2064               		.loc 1 830 0
 2065               	/* #APP */
 2066               	 ;  830 "setup.c" 1
 2067 05fa 0000      		nop
 2068               	 ;  0 "" 2
 831:setup.c       **** 	asm volatile("nop");
 2069               		.loc 1 831 0
 2070               	 ;  831 "setup.c" 1
 2071 05fc 0000      		nop
 2072               	 ;  0 "" 2
 832:setup.c       **** 	asm volatile("nop");
 2073               		.loc 1 832 0
 2074               	 ;  832 "setup.c" 1
 2075 05fe 0000      		nop
 2076               	 ;  0 "" 2
 833:setup.c       **** 	wrPin_high;
 2077               		.loc 1 833 0
 2078               	/* #NOAPP */
 2079 0600 969A      		sbi 0x12,6
 834:setup.c       **** 	cs_mreqPin_high;
 2080               		.loc 1 834 0
 2081 0602 949A      		sbi 0x12,4
 835:setup.c       **** 	
 836:setup.c       **** 	// 0x555, 0xA0;
 837:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2082               		.loc 1 837 0
 2083 0604 15BA      		out 0x15,__zero_reg__
 838:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2084               		.loc 1 838 0
 2085 0606 9BBB      		out 0x1b,r25
 839:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2086               		.loc 1 839 0
 2087 0608 88BB      		out 0x18,r24
 840:setup.c       **** 	cs_mreqPin_low;
 2088               		.loc 1 840 0
 2089 060a 9498      		cbi 0x12,4
 841:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2090               		.loc 1 841 0
 2091 060c 1BBA      		out 0x1b,__zero_reg__
 842:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2092               		.loc 1 842 0
 2093 060e 80EA      		ldi r24,lo8(-96)
 2094 0610 88BB      		out 0x18,r24
 843:setup.c       **** 	wrPin_low;
 2095               		.loc 1 843 0
 2096 0612 9698      		cbi 0x12,6
 844:setup.c       **** 	asm volatile("nop");
 2097               		.loc 1 844 0
 2098               	/* #APP */
 2099               	 ;  844 "setup.c" 1
 2100 0614 0000      		nop
 2101               	 ;  0 "" 2
 845:setup.c       **** 	asm volatile("nop");
 2102               		.loc 1 845 0
 2103               	 ;  845 "setup.c" 1
 2104 0616 0000      		nop
 2105               	 ;  0 "" 2
 846:setup.c       **** 	asm volatile("nop");
 2106               		.loc 1 846 0
 2107               	 ;  846 "setup.c" 1
 2108 0618 0000      		nop
 2109               	 ;  0 "" 2
 847:setup.c       **** 	wrPin_high;
 2110               		.loc 1 847 0
 2111               	/* #NOAPP */
 2112 061a 969A      		sbi 0x12,6
 848:setup.c       **** 	cs_mreqPin_high;
 2113               		.loc 1 848 0
 2114 061c 949A      		sbi 0x12,4
 2115 061e 0895      		ret
 2116               		.cfi_endproc
 2117               	.LFE42:
 2119               	.global	gba_flash_write_byte
 2121               	gba_flash_write_byte:
 2122               	.LFB43:
 849:setup.c       **** }	
 850:setup.c       **** 
 851:setup.c       **** 
 852:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 853:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 854:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2123               		.loc 1 854 0
 2124               		.cfi_startproc
 2125               	.LVL152:
 2126 0620 CF92      		push r12
 2127               	.LCFI36:
 2128               		.cfi_def_cfa_offset 3
 2129               		.cfi_offset 12, -2
 2130 0622 DF92      		push r13
 2131               	.LCFI37:
 2132               		.cfi_def_cfa_offset 4
 2133               		.cfi_offset 13, -3
 2134 0624 EF92      		push r14
 2135               	.LCFI38:
 2136               		.cfi_def_cfa_offset 5
 2137               		.cfi_offset 14, -4
 2138 0626 FF92      		push r15
 2139               	.LCFI39:
 2140               		.cfi_def_cfa_offset 6
 2141               		.cfi_offset 15, -5
 2142 0628 CF93      		push r28
 2143               	.LCFI40:
 2144               		.cfi_def_cfa_offset 7
 2145               		.cfi_offset 28, -6
 2146 062a DF93      		push r29
 2147               	.LCFI41:
 2148               		.cfi_def_cfa_offset 8
 2149               		.cfi_offset 29, -7
 2150               	/* prologue: function */
 2151               	/* frame size = 0 */
 2152               	/* stack size = 6 */
 2153               	.L__stack_usage = 6
 2154 062c 6B01      		movw r12,r22
 2155 062e 7C01      		movw r14,r24
 2156 0630 EA01      		movw r28,r20
 855:setup.c       **** 	if (isD0D1Swapped == 0) {
 2157               		.loc 1 855 0
 2158 0632 2111      		cpse r18,__zero_reg__
 2159 0634 00C0      		rjmp .L84
 856:setup.c       **** 		gba_flash_write_cycle_start();
 2160               		.loc 1 856 0
 2161 0636 00D0      		rcall gba_flash_write_cycle_start
 2162               	.LVL153:
 2163 0638 00C0      		rjmp .L85
 2164               	.LVL154:
 2165               	.L84:
 857:setup.c       **** 	}
 858:setup.c       **** 	else {
 859:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2166               		.loc 1 859 0
 2167 063a 00D0      		rcall gba_flash_write_cycle_start_swapped
 2168               	.LVL155:
 2169               	.L85:
 860:setup.c       **** 	}
 861:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2170               		.loc 1 861 0
 2171 063c AE01      		movw r20,r28
 2172 063e C701      		movw r24,r14
 2173 0640 B601      		movw r22,r12
 2174 0642 00D0      		rcall gba_flash_write_bus_cycle
 2175               	.LVL156:
 2176               	.LBB158:
 2177               	.LBB159:
 2178               		.loc 2 276 0
 2179 0644 25E0      		ldi r18,lo8(5)
 2180 0646 2A95      	1:	dec r18
 2181 0648 01F4      		brne 1b
 2182 064a 0000      		nop
 2183               	.LVL157:
 2184               	.LBE159:
 2185               	.LBE158:
 862:setup.c       **** 	_delay_us(2); // Wait byte program time
 863:setup.c       **** 	
 864:setup.c       **** 	// Verify data
 865:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2186               		.loc 1 865 0
 2187 064c C701      		movw r24,r14
 2188 064e B601      		movw r22,r12
 2189 0650 00D0      		rcall gba_read_16bit_data
 2190               	.LVL158:
 2191               	.L86:
 866:setup.c       **** 	while (data != dataVerify) {
 2192               		.loc 1 866 0
 2193 0652 8C17      		cp r24,r28
 2194 0654 9D07      		cpc r25,r29
 2195 0656 01F0      		breq .L88
 867:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2196               		.loc 1 867 0
 2197 0658 C701      		movw r24,r14
 2198 065a B601      		movw r22,r12
 2199 065c 00D0      		rcall gba_read_16bit_data
 2200               	.LVL159:
 2201               	.LBB160:
 2202               	.LBB161:
 2203               		.loc 2 276 0
 2204 065e 25E0      		ldi r18,lo8(5)
 2205 0660 2A95      	1:	dec r18
 2206 0662 01F4      		brne 1b
 2207 0664 0000      		nop
 2208 0666 00C0      		rjmp .L86
 2209               	.LVL160:
 2210               	.L88:
 2211               	/* epilogue start */
 2212               	.LBE161:
 2213               	.LBE160:
 868:setup.c       **** 		_delay_us(2);
 869:setup.c       **** 	}
 870:setup.c       **** }
 2214               		.loc 1 870 0
 2215 0668 DF91      		pop r29
 2216 066a CF91      		pop r28
 2217               	.LVL161:
 2218 066c FF90      		pop r15
 2219 066e EF90      		pop r14
 2220 0670 DF90      		pop r13
 2221 0672 CF90      		pop r12
 2222               	.LVL162:
 2223 0674 0895      		ret
 2224               		.cfi_endproc
 2225               	.LFE43:
 2227               	.global	setup
 2229               	setup:
 2230               	.LFB44:
 871:setup.c       **** 
 872:setup.c       **** 
 873:setup.c       **** // Setup
 874:setup.c       **** void setup(void) {
 2231               		.loc 1 874 0
 2232               		.cfi_startproc
 2233               	/* prologue: function */
 2234               	/* frame size = 0 */
 2235               	/* stack size = 0 */
 2236               	.L__stack_usage = 0
 875:setup.c       **** 	// Turn off watchdog
 876:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2237               		.loc 1 876 0
 2238 0676 84B7      		in r24,0x34
 2239 0678 877F      		andi r24,lo8(-9)
 2240 067a 84BF      		out 0x34,r24
 877:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2241               		.loc 1 877 0
 2242 067c 88E1      		ldi r24,lo8(24)
 2243 067e 81BD      		out 0x21,r24
 878:setup.c       **** 	WDTCR = 0;
 2244               		.loc 1 878 0
 2245 0680 11BC      		out 0x21,__zero_reg__
 879:setup.c       **** 	
 880:setup.c       **** 	// Reset common lines
 881:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2246               		.loc 1 881 0
 2247 0682 00D0      		rcall rd_wr_csmreq_cs2_reset
 2248               	.LVL163:
 882:setup.c       **** 	
 883:setup.c       **** 	// Set outputs
 884:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V) | (1<<VOLTA
 2249               		.loc 1 884 0
 2250 0684 81B3      		in r24,0x11
 2251 0686 8C6F      		ori r24,lo8(-4)
 2252 0688 81BB      		out 0x11,r24
 885:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2253               		.loc 1 885 0
 2254 068a 86B1      		in r24,0x6
 2255 068c 8560      		ori r24,lo8(5)
 2256 068e 86B9      		out 0x6,r24
 886:setup.c       **** 	
 887:setup.c       **** 	// Set all pins as inputs
 888:setup.c       **** 	PORT_DATA7_0 = 0;
 2257               		.loc 1 888 0
 2258 0690 15BA      		out 0x15,__zero_reg__
 889:setup.c       **** 	DDR_DATA7_0 = 0;
 2259               		.loc 1 889 0
 2260 0692 14BA      		out 0x14,__zero_reg__
 890:setup.c       **** 	PORT_ADDR7_0 = 0;
 2261               		.loc 1 890 0
 2262 0694 18BA      		out 0x18,__zero_reg__
 891:setup.c       **** 	DDR_ADDR7_0 = 0;
 2263               		.loc 1 891 0
 2264 0696 17BA      		out 0x17,__zero_reg__
 892:setup.c       **** 	PORT_ADDR15_8 = 0;
 2265               		.loc 1 892 0
 2266 0698 1BBA      		out 0x1b,__zero_reg__
 893:setup.c       **** 	DDR_ADDR15_8 = 0;
 2267               		.loc 1 893 0
 2268 069a 1ABA      		out 0x1a,__zero_reg__
 894:setup.c       **** 	
 895:setup.c       **** 	// Light up 3.3V or 5V
 896:setup.c       **** 	if (cartMode == GB_MODE) {
 2269               		.loc 1 896 0
 2270 069c 8091 0000 		lds r24,cartMode
 2271 06a0 8130      		cpi r24,lo8(1)
 2272 06a2 01F4      		brne .L90
 897:setup.c       **** 		PORTD |= (1<<LED_5V);
 2273               		.loc 1 897 0
 2274 06a4 979A      		sbi 0x12,7
 898:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2275               		.loc 1 898 0
 2276 06a6 3898      		cbi 0x7,0
 2277 06a8 00C0      		rjmp .L91
 2278               	.L90:
 899:setup.c       **** 	}
 900:setup.c       **** 	else {
 901:setup.c       **** 		PORTE |= (1<<LED_3V);
 2279               		.loc 1 901 0
 2280 06aa 389A      		sbi 0x7,0
 902:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2281               		.loc 1 902 0
 2282 06ac 9798      		cbi 0x12,7
 2283               	.L91:
 903:setup.c       **** 	}
 904:setup.c       **** 	
 905:setup.c       **** 	// Light LED
 906:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2284               		.loc 1 906 0
 2285 06ae 939A      		sbi 0x12,3
 2286               	.LVL164:
 2287               	.LBB162:
 2288               	.LBB163:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2289               		.loc 2 187 0
 2290 06b0 2FEF      		ldi r18,lo8(799999)
 2291 06b2 84E3      		ldi r24,hi8(799999)
 2292 06b4 9CE0      		ldi r25,hlo8(799999)
 2293 06b6 2150      	1:	subi r18,1
 2294 06b8 8040      		sbci r24,0
 2295 06ba 9040      		sbci r25,0
 2296 06bc 01F4      		brne 1b
 2297 06be 00C0      		rjmp .
 2298 06c0 0000      		nop
 2299               	.LVL165:
 2300               	.LBE163:
 2301               	.LBE162:
 907:setup.c       **** 	_delay_ms(500);
 908:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2302               		.loc 1 908 0
 2303 06c2 9398      		cbi 0x12,3
 909:setup.c       **** 	
 910:setup.c       **** 	// Setup USART
 911:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2304               		.loc 1 911 0
 2305 06c4 19B8      		out 0x9,__zero_reg__
 912:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2306               		.loc 1 912 0
 2307 06c6 599A      		sbi 0xb,1
 913:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2308               		.loc 1 913 0
 2309 06c8 539A      		sbi 0xa,3
 914:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2310               		.loc 1 914 0
 2311 06ca 549A      		sbi 0xa,4
 915:setup.c       **** 	
 916:setup.c       **** 	// Turn on interrupts
 917:setup.c       **** 	sei();
 2312               		.loc 1 917 0
 2313               	/* #APP */
 2314               	 ;  917 "setup.c" 1
 2315 06cc 7894      		sei
 2316               	 ;  0 "" 2
 2317               	/* #NOAPP */
 2318 06ce 0895      		ret
 2319               		.cfi_endproc
 2320               	.LFE44:
 2322               		.section	.text.startup,"ax",@progbits
 2323               	.global	main
 2325               	main:
 2326               	.LFB45:
 2327               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.3
   4:main.c        ****  Firmware version: R15
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 8/08/2019
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 4
  53:main.c        **** #define FIRMWARE_VERSION 15
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2328               		.loc 3 66 0
 2329               		.cfi_startproc
 2330               	/* prologue: function */
 2331               	/* frame size = 0 */
 2332               	/* stack size = 0 */
 2333               	.L__stack_usage = 0
  67:main.c        **** 	setup();
 2334               		.loc 3 67 0
 2335 0000 00D0      		rcall setup
 2336               	.LVL166:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 2337               		.loc 3 71 0
 2338 0002 2224      		clr r2
 2339 0004 2394      		inc r2
  70:main.c        **** 	uint8_t resetCommonLines = 1;
 2340               		.loc 3 70 0
 2341 0006 D1E0      		ldi r29,lo8(1)
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2342               		.loc 3 69 0
 2343 0008 C12C      		mov r12,__zero_reg__
 2344 000a D12C      		mov r13,__zero_reg__
 2345 000c 7601      		movw r14,r12
 2346               	.LBB164:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  78:main.c        **** 		
  79:main.c        **** 		// Return the cart mode in use
  80:main.c        **** 		if (receivedChar == CART_MODE) {
  81:main.c        **** 			USART_Transmit(cartMode);
  82:main.c        **** 		}
  83:main.c        **** 		
  84:main.c        **** 		// Change to GB mode or GBA mode if requested
  85:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  86:main.c        **** 			gb_mode();
  87:main.c        **** 		}
  88:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
  89:main.c        **** 			gba_mode();
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Switch voltage if requested
  93:main.c        **** 		else if (receivedChar == VOLTAGE_3_3V) {
  94:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
  95:main.c        **** 			cartMode = GBA_MODE;
  96:main.c        **** 			PORTE |= (1<<LED_3V);
  97:main.c        **** 			PORTD &= ~(1<<LED_5V);
  98:main.c        **** 		}
  99:main.c        **** 		else if (receivedChar == VOLTAGE_5V) {
 100:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 101:main.c        **** 			cartMode = GB_MODE;
 102:main.c        **** 			PORTD |= (1<<LED_5V);
 103:main.c        **** 			PORTE &= ~(1<<LED_3V);
 104:main.c        **** 		}
 105:main.c        **** 		
 106:main.c        **** 		
 107:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 108:main.c        **** 		
 109:main.c        **** 		// Set address
 110:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 111:main.c        **** 			usart_read_chars(); // Read start address
 112:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 113:main.c        **** 		}
 114:main.c        **** 		
 115:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 116:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 117:main.c        **** 			gb_mode();
 118:main.c        **** 			receivedChar = '1';
 119:main.c        **** 			while (receivedChar == '1') {
 120:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 121:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 122:main.c        **** 					USART_Transmit(read_8bit_data(address));
 123:main.c        **** 					address++;
 124:main.c        **** 				}
 125:main.c        **** 				
 126:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 127:main.c        **** 				receivedChar = USART_Receive();
 128:main.c        **** 			}
 129:main.c        **** 		}
 130:main.c        **** 		
 131:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 132:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 133:main.c        **** 			gb_mode();
 134:main.c        **** 			
 135:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 136:main.c        **** 			usart_read_bytes(64);
 137:main.c        **** 			
 138:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 139:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 140:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 141:main.c        **** 				address++;
 142:main.c        **** 			}
 143:main.c        **** 			
 144:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 145:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 146:main.c        **** 		}
 147:main.c        **** 		
 148:main.c        **** 		// Set bank address and write a byte
 149:main.c        **** 		else if (receivedChar == SET_BANK) {
 150:main.c        **** 			gb_mode();
 151:main.c        **** 			
 152:main.c        **** 			usart_read_chars(); // Read start address
 153:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 154:main.c        **** 			
 155:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 156:main.c        **** 			if (receivedChar == 'B') {
 157:main.c        **** 				usart_read_chars(); // Read data
 158:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 159:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 160:main.c        **** 				
 161:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 162:main.c        **** 			}
 163:main.c        **** 		}
 164:main.c        **** 		
 165:main.c        **** 		
 166:main.c        **** 		// ****** Gameboy Advance ******
 167:main.c        **** 		
 168:main.c        **** 		// ---------- ROM ----------
 169:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 170:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 171:main.c        **** 			gba_mode();
 172:main.c        **** 			
 173:main.c        **** 			uint8_t readEnd = 32;
 174:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 175:main.c        **** 				readEnd = 128;
 176:main.c        **** 			}
 177:main.c        **** 			
 178:main.c        **** 			receivedChar = '1';
 2347               		.loc 3 178 0
 2348 000e 81E3      		ldi r24,lo8(49)
 2349 0010 382E      		mov r3,r24
 2350               	.LBE164:
 2351               	.LBB167:
 2352               	.LBB168:
 179:main.c        **** 			while (receivedChar == '1') {
 180:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 181:main.c        **** 				
 182:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 183:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 184:main.c        **** 					
 185:main.c        **** 					// Low byte & High byte
 186:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 187:main.c        **** 					USART_Transmit(dataRead >> 8);
 188:main.c        **** 					
 189:main.c        **** 					address++;
 190:main.c        **** 				}
 191:main.c        **** 				
 192:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 193:main.c        **** 				receivedChar = USART_Receive();
 194:main.c        **** 			}
 195:main.c        **** 		}
 196:main.c        **** 		
 197:main.c        **** 		// ---------- SRAM ----------
 198:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 199:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 200:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 201:main.c        **** 			
 202:main.c        **** 			receivedChar = '1';
 203:main.c        **** 			while (receivedChar == '1') {
 204:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 205:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 206:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 207:main.c        **** 					address++;
 208:main.c        **** 				}
 209:main.c        **** 				
 210:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 211:main.c        **** 				receivedChar = USART_Receive();
 212:main.c        **** 			}
 213:main.c        **** 			
 214:main.c        **** 			gba_mode(); // Set back
 215:main.c        **** 		}
 216:main.c        **** 		
 217:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 218:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 219:main.c        **** 			gb_mode();
 220:main.c        **** 			
 221:main.c        **** 			usart_read_bytes(64);
 222:main.c        **** 			
 223:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 224:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 225:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 226:main.c        **** 				address++;
 227:main.c        **** 			}
 228:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 229:main.c        **** 			
 230:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 231:main.c        **** 			gba_mode(); // Set back
 232:main.c        **** 		}
 233:main.c        **** 		
 234:main.c        **** 		// Write 1 byte to SRAM address
 235:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 236:main.c        **** 			gb_mode();
 237:main.c        **** 			
 238:main.c        **** 			uint8_t data = USART_Receive();
 239:main.c        **** 			gba_write_ram_8bit_data(address, data);
 240:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 241:main.c        **** 			
 242:main.c        **** 			gba_mode(); // Set back
 243:main.c        **** 		}
 244:main.c        **** 		
 245:main.c        **** 		
 246:main.c        **** 		// ---------- FLASH ----------
 247:main.c        **** 		// Read the Flash Manufacturer and Device ID
 248:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 249:main.c        **** 			gb_mode();
 250:main.c        **** 			
 251:main.c        **** 			flash_read_chip_id();
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 253:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 254:main.c        **** 			
 255:main.c        **** 			gba_mode(); // Set back
 256:main.c        **** 		}
 257:main.c        **** 		
 258:main.c        **** 		// Change bank
 259:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 260:main.c        **** 			usart_read_chars(); // Read data
 261:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 262:main.c        **** 			
 263:main.c        **** 			gb_mode();
 264:main.c        **** 			flash_switch_bank(bank);
 265:main.c        **** 			
 266:main.c        **** 			gba_mode(); // Set back
 267:main.c        **** 		}
 268:main.c        **** 		
 269:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 270:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 271:main.c        **** 			gb_mode();
 272:main.c        **** 			
 273:main.c        **** 			usart_read_chars(); // Read sector
 274:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 275:main.c        **** 			
 276:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 277:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 278:main.c        **** 			
 279:main.c        **** 			gba_mode(); // Set back
 280:main.c        **** 		}
 281:main.c        **** 		
 282:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 283:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 284:main.c        **** 			gb_mode();
 285:main.c        **** 			
 286:main.c        **** 			usart_read_bytes(64);
 287:main.c        **** 			
 288:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 289:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 290:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 291:main.c        **** 				address++;
 292:main.c        **** 			}
 293:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 294:main.c        **** 			
 295:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 296:main.c        **** 			gba_mode(); // Set back
 297:main.c        **** 		}
 298:main.c        **** 		
 299:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 300:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 301:main.c        **** 			gb_mode();
 302:main.c        **** 			
 303:main.c        **** 			usart_read_bytes(128);
 304:main.c        **** 			
 305:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 306:main.c        **** 			flash_write_sector(address); // Address used as sector number
 307:main.c        **** 			address++;
 308:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 309:main.c        **** 			
 310:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 311:main.c        **** 			gba_mode(); // Set back
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		
 315:main.c        **** 		// ---------- EEPROM ----------
 316:main.c        **** 		// Set EEPROM size
 317:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 318:main.c        **** 			usart_read_chars(); // Read size
 319:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 320:main.c        **** 		}
 321:main.c        **** 		
 322:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 323:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 324:main.c        **** 			gba_eeprom_mode();
 325:main.c        **** 			
 326:main.c        **** 			receivedChar = '1';
 327:main.c        **** 			while (receivedChar == '1') {
 328:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 329:main.c        **** 				gba_eeprom_read(address, eepromSize);
 330:main.c        **** 				
 331:main.c        **** 				// Send back the 8 bytes of data
 332:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 333:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 334:main.c        **** 				}
 335:main.c        **** 				address++; // Increment to next 8 bytes
 336:main.c        **** 				
 337:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 338:main.c        **** 				receivedChar = USART_Receive();
 339:main.c        **** 			}
 340:main.c        **** 			
 341:main.c        **** 			gba_mode(); // Set back
 342:main.c        **** 		}
 343:main.c        **** 		
 344:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 345:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 346:main.c        **** 			gba_eeprom_mode();
 347:main.c        **** 			
 348:main.c        **** 			// Read 8 bytes from USART and place in buffer
 349:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 350:main.c        **** 				eepromBuffer[x] = USART_Receive();
 351:main.c        **** 			}
 352:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 353:main.c        **** 			
 354:main.c        **** 			gba_eeprom_write(address, eepromSize);
 355:main.c        **** 			address++;
 356:main.c        **** 			
 357:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 358:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 359:main.c        **** 			
 360:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 361:main.c        **** 			gba_mode(); // Set back
 362:main.c        **** 		}
 363:main.c        **** 		
 364:main.c        **** 		
 365:main.c        **** 		// ---------- GB FLASH CARTS ----------
 366:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 367:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 368:main.c        **** 			flashWriteWePin = USART_Receive();
 369:main.c        **** 			
 370:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 371:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 372:main.c        **** 				audioPin_high;
 373:main.c        **** 			}
 374:main.c        **** 		}
 375:main.c        **** 		
 376:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 377:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 378:main.c        **** 			flashBank1CommandWrites = 1;
 379:main.c        **** 		}
 380:main.c        **** 		
 381:main.c        **** 		// Load the program method to use
 382:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 383:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 384:main.c        **** 				usart_read_chars(); // Address
 385:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 386:main.c        **** 				USART_Transmit(SEND_ACK);
 387:main.c        **** 				
 388:main.c        **** 				usart_read_chars(); // Data
 389:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 390:main.c        **** 				USART_Transmit(SEND_ACK);
 391:main.c        **** 			}
 392:main.c        **** 		}
 393:main.c        **** 		
 394:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 395:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 396:main.c        **** 			usart_read_chars(); // Read address
 397:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 398:main.c        **** 			
 399:main.c        **** 			usart_read_chars(); // Read data byte
 400:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 401:main.c        **** 			
 402:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 403:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 404:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 405:main.c        **** 			
 406:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 407:main.c        **** 		}
 408:main.c        **** 		
 409:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 410:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 411:main.c        **** 			usart_read_bytes(64);
 412:main.c        **** 			
 413:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 414:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 415:main.c        **** 				if (flashBank1CommandWrites == 0) {
 416:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 417:main.c        **** 				}
 418:main.c        **** 				else { // Some flash carts need to change to bank 1 to issue flash commands
 419:main.c        **** 					gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 420:main.c        **** 				}
 421:main.c        **** 				address++;
 422:main.c        **** 			}
 423:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 424:main.c        **** 			
 425:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 426:main.c        **** 		}
 427:main.c        **** 		
 428:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 429:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 430:main.c        **** 			usart_read_bytes(32);
 431:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 432:main.c        **** 			
 433:main.c        **** 			// Setup buffered write
 434:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 435:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 436:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 437:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 438:main.c        **** 			_delay_us(1);
 439:main.c        **** 			
 440:main.c        **** 			// Write data
 441:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 442:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 443:main.c        **** 				address++;
 444:main.c        **** 			}
 445:main.c        **** 			
 446:main.c        **** 			// Write buffer to flash
 447:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 448:main.c        **** 			_delay_us(200);
 449:main.c        **** 			
 450:main.c        **** 			// Verify last byte written
 451:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 452:main.c        **** 			uint8_t verifyCount = 0;
 453:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 454:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 455:main.c        **** 				_delay_us(5);
 456:main.c        **** 				verifyCount++;
 457:main.c        **** 				if (verifyCount >= 200) {
 458:main.c        **** 					_delay_ms(500);
 459:main.c        **** 					break;
 460:main.c        **** 				}
 461:main.c        **** 			}
 462:main.c        **** 			
 463:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 464:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 465:main.c        **** 		}
 466:main.c        **** 		
 467:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 468:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 469:main.c        **** 			usart_read_bytes(256);
 470:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 471:main.c        **** 			
 472:main.c        **** 			// Setup buffered write
 473:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 474:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 475:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 476:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 477:main.c        **** 			_delay_us(50);
 478:main.c        **** 			
 479:main.c        **** 			// Write data
 480:main.c        **** 			for (int x = 0; x < 256; x++) {
 481:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 482:main.c        **** 				address++;
 483:main.c        **** 			}
 484:main.c        **** 			
 485:main.c        **** 			// Write buffer to flash
 486:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 487:main.c        **** 			
 488:main.c        **** 			// Verify last byte written
 489:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 490:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 491:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 492:main.c        **** 				_delay_us(5);
 493:main.c        **** 			}
 494:main.c        **** 			
 495:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 496:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 497:main.c        **** 		}
 498:main.c        **** 		
 499:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 500:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 501:main.c        **** 			usart_read_bytes(128);
 502:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 503:main.c        **** 			
 504:main.c        **** 			// Enable flash chip access
 505:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 506:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 507:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 508:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 509:main.c        **** 			_delay_us(5);
 510:main.c        **** 			
 511:main.c        **** 			// Re-Enable writes to MBC registers
 512:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 513:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 514:main.c        **** 			_delay_us(5);
 515:main.c        **** 			
 516:main.c        **** 			// Bank 1 for commands
 517:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 518:main.c        **** 			_delay_us(5);
 519:main.c        **** 			
 520:main.c        **** 			
 521:main.c        **** 			// Write setup
 522:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 523:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 524:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 525:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 526:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 527:main.c        **** 			_delay_us(5);
 528:main.c        **** 			
 529:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 530:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 531:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 532:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 533:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 534:main.c        **** 			_delay_us(5);
 535:main.c        **** 			
 536:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 537:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 538:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 539:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 540:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 541:main.c        **** 			_delay_us(5);
 542:main.c        **** 			
 543:main.c        **** 			// Set bank back
 544:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 545:main.c        **** 			_delay_us(5);
 546:main.c        **** 			
 547:main.c        **** 			// Disable writes to MBC registers
 548:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 549:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 550:main.c        **** 			_delay_us(5);
 551:main.c        **** 			
 552:main.c        **** 			// Undo Wakeup
 553:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 554:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 555:main.c        **** 			_delay_us(5);
 556:main.c        **** 			
 557:main.c        **** 			
 558:main.c        **** 			// Write data
 559:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 560:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 561:main.c        **** 				_delay_us(5);
 562:main.c        **** 				address++;
 563:main.c        **** 			}
 564:main.c        **** 			
 565:main.c        **** 			// Write buffer to flash
 566:main.c        **** 			address--;
 567:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 568:main.c        **** 			address++;
 569:main.c        **** 			_delay_ms(10);
 570:main.c        **** 			
 571:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 572:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 573:main.c        **** 		}
 574:main.c        **** 		
 575:main.c        **** 		
 576:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 577:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 578:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 579:main.c        **** 			usart_read_chars(); // Read address
 580:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 581:main.c        **** 			
 582:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 583:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 584:main.c        **** 				usart_read_chars(); // Read data
 585:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 586:main.c        **** 				
 587:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 588:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 589:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 590:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 591:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 592:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 593:main.c        **** 				
 594:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 595:main.c        **** 			}
 596:main.c        **** 		}
 597:main.c        **** 		
 598:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 599:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 600:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 601:main.c        **** 			
 602:main.c        **** 			int readLength = 64;
 603:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 604:main.c        **** 				readLength = 256;
 605:main.c        **** 			}
 606:main.c        **** 			usart_read_bytes(readLength);
 607:main.c        **** 			
 608:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 609:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 610:main.c        **** 				gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 611:main.c        **** 				address++;
 612:main.c        **** 			}
 613:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 614:main.c        **** 			
 615:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 616:main.c        **** 		}
 617:main.c        **** 		
 618:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 619:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 620:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 621:main.c        **** 			
 622:main.c        **** 			int readLength = 256;
 623:main.c        **** 			usart_read_bytes(readLength);
 624:main.c        **** 			
 625:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 626:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 627:main.c        **** 				gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 628:main.c        **** 				address++;
 629:main.c        **** 			}
 630:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 631:main.c        **** 			
 632:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 633:main.c        **** 		}
 634:main.c        **** 		
 635:main.c        **** 		// Intel flash command based chips
 636:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 637:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 638:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 639:main.c        **** 			usart_read_bytes(64);
 640:main.c        **** 			
 641:main.c        **** 			// Set address lines as outputs
 642:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 643:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 644:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 645:main.c        **** 			
 646:main.c        **** 			// Unlock
 647:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 648:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 649:main.c        **** 			
 650:main.c        **** 			// Buffered write command
 651:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 652:main.c        **** 			_delay_us(50);
 653:main.c        **** 			
 654:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 655:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 656:main.c        **** 			while (dataVerify != 0x0080) {
 657:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 658:main.c        **** 				_delay_us(50);
 659:main.c        **** 			}
 660:main.c        **** 			
 661:main.c        **** 			
 662:main.c        **** 			// Set address lines as outputs
 663:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 664:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 665:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 666:main.c        **** 			
 667:main.c        **** 			// Set length
 668:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 669:main.c        **** 			
 670:main.c        **** 			// Write data
 671:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 672:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 673:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 674:main.c        **** 				address++;
 675:main.c        **** 			}
 676:main.c        **** 			
 677:main.c        **** 			// Write buffer to flash
 678:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 679:main.c        **** 			_delay_us(440);
 680:main.c        **** 			
 681:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 682:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 683:main.c        **** 			while (dataVerify != 0x0080) {
 684:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 685:main.c        **** 				_delay_us(50);
 686:main.c        **** 			}
 687:main.c        **** 			
 688:main.c        **** 			
 689:main.c        **** 			// Set address lines as outputs
 690:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 691:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 692:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 693:main.c        **** 			
 694:main.c        **** 			// Back to reading mode
 695:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 696:main.c        **** 			
 697:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 698:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 699:main.c        **** 		}
 700:main.c        **** 		
 701:main.c        **** 		// Intel word programming
 702:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE_WORD) {
 703:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 704:main.c        **** 			usart_read_bytes(64);
 705:main.c        **** 			
 706:main.c        **** 			// Write data
 707:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 708:main.c        **** 				// Set address lines as outputs
 709:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2353               		.loc 3 709 0
 2354 0012 CFEF      		ldi r28,lo8(-1)
 2355               	.LVL167:
 2356               	.L93:
 2357               	.LBE168:
 2358               	.LBE167:
  74:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2359               		.loc 3 74 0
 2360 0014 21E0      		ldi r18,lo8(1)
 2361 0016 2212      		cpse r2,r18
 2362 0018 00C0      		rjmp .L94
 2363               	.LVL168:
 2364               	.L235:
  75:main.c        **** 		}
 2365               		.loc 3 75 0
 2366 001a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2367               	.LVL169:
 2368               	.L94:
  77:main.c        **** 		
 2369               		.loc 3 77 0
 2370 001c 00D0      		rcall USART_Receive
 2371               	.LVL170:
 2372 001e 8093 0000 		sts receivedChar,r24
  80:main.c        **** 			USART_Transmit(cartMode);
 2373               		.loc 3 80 0
 2374 0022 8334      		cpi r24,lo8(67)
 2375 0024 01F4      		brne .L95
  81:main.c        **** 		}
 2376               		.loc 3 81 0
 2377 0026 8091 0000 		lds r24,cartMode
 2378 002a 00C0      		rjmp .L236
 2379               	.L95:
  85:main.c        **** 			gb_mode();
 2380               		.loc 3 85 0
 2381 002c 8734      		cpi r24,lo8(71)
 2382 002e 01F4      		brne .L97
  86:main.c        **** 		}
 2383               		.loc 3 86 0
 2384 0030 00D0      		rcall gb_mode
 2385               	.LVL171:
 2386 0032 00C0      		rjmp .L93
 2387               	.L97:
  88:main.c        **** 			gba_mode();
 2388               		.loc 3 88 0
 2389 0034 8736      		cpi r24,lo8(103)
 2390 0036 01F4      		brne .+2
 2391 0038 00C0      		rjmp .L238
  93:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
 2392               		.loc 3 93 0
 2393 003a 8333      		cpi r24,lo8(51)
 2394 003c 01F4      		brne .L99
  94:main.c        **** 			cartMode = GBA_MODE;
 2395               		.loc 3 94 0
 2396 003e 9298      		cbi 0x12,2
  95:main.c        **** 			PORTE |= (1<<LED_3V);
 2397               		.loc 3 95 0
 2398 0040 82E0      		ldi r24,lo8(2)
 2399 0042 8093 0000 		sts cartMode,r24
  96:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2400               		.loc 3 96 0
 2401 0046 389A      		sbi 0x7,0
  97:main.c        **** 		}
 2402               		.loc 3 97 0
 2403 0048 9798      		cbi 0x12,7
 2404 004a 00C0      		rjmp .L93
 2405               	.L99:
  99:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 2406               		.loc 3 99 0
 2407 004c 8533      		cpi r24,lo8(53)
 2408 004e 01F4      		brne .L100
 100:main.c        **** 			cartMode = GB_MODE;
 2409               		.loc 3 100 0
 2410 0050 929A      		sbi 0x12,2
 101:main.c        **** 			PORTD |= (1<<LED_5V);
 2411               		.loc 3 101 0
 2412 0052 81E0      		ldi r24,lo8(1)
 2413 0054 8093 0000 		sts cartMode,r24
 102:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2414               		.loc 3 102 0
 2415 0058 979A      		sbi 0x12,7
 103:main.c        **** 		}
 2416               		.loc 3 103 0
 2417 005a 3898      		cbi 0x7,0
 2418 005c 00C0      		rjmp .L93
 2419               	.L100:
 110:main.c        **** 			usart_read_chars(); // Read start address
 2420               		.loc 3 110 0
 2421 005e 8134      		cpi r24,lo8(65)
 2422 0060 01F4      		brne .L101
 111:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2423               		.loc 3 111 0
 2424 0062 00D0      		rcall usart_read_chars
 2425               	.LVL172:
 112:main.c        **** 		}
 2426               		.loc 3 112 0
 2427 0064 40E1      		ldi r20,lo8(16)
 2428 0066 50E0      		ldi r21,0
 2429 0068 60E0      		ldi r22,0
 2430 006a 70E0      		ldi r23,0
 2431 006c 80E0      		ldi r24,lo8(receivedBuffer)
 2432 006e 90E0      		ldi r25,hi8(receivedBuffer)
 2433 0070 00D0      		rcall strtol
 2434               	.LVL173:
 2435 0072 6B01      		movw r12,r22
 2436 0074 7C01      		movw r14,r24
 2437               	.LVL174:
 2438 0076 00C0      		rjmp .L93
 2439               	.L101:
 116:main.c        **** 			gb_mode();
 2440               		.loc 3 116 0
 2441 0078 8235      		cpi r24,lo8(82)
 2442 007a 01F4      		brne .L102
 117:main.c        **** 			receivedChar = '1';
 2443               		.loc 3 117 0
 2444 007c 00D0      		rcall gb_mode
 2445               	.LVL175:
 118:main.c        **** 			while (receivedChar == '1') {
 2446               		.loc 3 118 0
 2447 007e 3092 0000 		sts receivedChar,r3
 2448               	.LVL176:
 2449               	.L103:
 119:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2450               		.loc 3 119 0
 2451 0082 8091 0000 		lds r24,receivedChar
 2452 0086 8133      		cpi r24,lo8(49)
 2453 0088 01F4      		brne .L93
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2454               		.loc 3 120 0
 2455 008a 939A      		sbi 0x12,3
 2456               	.LVL177:
 2457 008c 00E0      		ldi r16,0
 2458 008e 10E0      		ldi r17,0
 2459               	.LVL178:
 2460               	.L104:
 2461               	.LBB172:
 122:main.c        **** 					address++;
 2462               		.loc 3 122 0 discriminator 3
 2463 0090 C801      		movw r24,r16
 2464 0092 8C0D      		add r24,r12
 2465 0094 9D1D      		adc r25,r13
 2466 0096 00D0      		rcall read_8bit_data
 2467               	.LVL179:
 2468 0098 00D0      		rcall USART_Transmit
 2469               	.LVL180:
 2470 009a 0F5F      		subi r16,-1
 2471 009c 1F4F      		sbci r17,-1
 2472               	.LVL181:
 121:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2473               		.loc 3 121 0 discriminator 3
 2474 009e 0034      		cpi r16,64
 2475 00a0 1105      		cpc r17,__zero_reg__
 2476 00a2 01F4      		brne .L104
 2477 00a4 90E4      		ldi r25,64
 2478 00a6 C90E      		add r12,r25
 2479 00a8 D11C      		adc r13,__zero_reg__
 2480 00aa E11C      		adc r14,__zero_reg__
 2481 00ac F11C      		adc r15,__zero_reg__
 2482               	.LBE172:
 126:main.c        **** 				receivedChar = USART_Receive();
 2483               		.loc 3 126 0
 2484 00ae 9398      		cbi 0x12,3
 127:main.c        **** 			}
 2485               		.loc 3 127 0
 2486 00b0 00D0      		rcall USART_Receive
 2487               	.LVL182:
 2488 00b2 8093 0000 		sts receivedChar,r24
 2489 00b6 00C0      		rjmp .L103
 2490               	.LVL183:
 2491               	.L102:
 132:main.c        **** 			gb_mode();
 2492               		.loc 3 132 0
 2493 00b8 8735      		cpi r24,lo8(87)
 2494 00ba 01F4      		brne .L106
 133:main.c        **** 			
 2495               		.loc 3 133 0
 2496 00bc 00D0      		rcall gb_mode
 2497               	.LVL184:
 136:main.c        **** 			
 2498               		.loc 3 136 0
 2499 00be 80E4      		ldi r24,lo8(64)
 2500 00c0 90E0      		ldi r25,0
 2501 00c2 00D0      		rcall usart_read_bytes
 2502               	.LVL185:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2503               		.loc 3 138 0
 2504 00c4 939A      		sbi 0x12,3
 2505               	.LVL186:
 2506 00c6 00E0      		ldi r16,lo8(receivedBuffer)
 2507 00c8 A02E      		mov r10,r16
 2508 00ca 00E0      		ldi r16,hi8(receivedBuffer)
 2509 00cc B02E      		mov r11,r16
 2510 00ce 00E0      		ldi r16,0
 2511 00d0 10E0      		ldi r17,0
 2512               	.LVL187:
 2513               	.L107:
 2514               	.LBB173:
 140:main.c        **** 				address++;
 2515               		.loc 3 140 0 discriminator 3
 2516 00d2 F501      		movw r30,r10
 2517 00d4 6191      		ld r22,Z+
 2518 00d6 5F01      		movw r10,r30
 2519 00d8 C801      		movw r24,r16
 2520 00da 8C0D      		add r24,r12
 2521 00dc 9D1D      		adc r25,r13
 2522 00de 41E0      		ldi r20,lo8(1)
 2523 00e0 00D0      		rcall write_8bit_data
 2524               	.LVL188:
 2525 00e2 0F5F      		subi r16,-1
 2526 00e4 1F4F      		sbci r17,-1
 2527               	.LVL189:
 139:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2528               		.loc 3 139 0 discriminator 3
 2529 00e6 0034      		cpi r16,64
 2530 00e8 1105      		cpc r17,__zero_reg__
 2531 00ea 01F4      		brne .L107
 2532 00ec F0E4      		ldi r31,64
 2533 00ee CF0E      		add r12,r31
 2534 00f0 D11C      		adc r13,__zero_reg__
 2535 00f2 E11C      		adc r14,__zero_reg__
 2536 00f4 F11C      		adc r15,__zero_reg__
 2537 00f6 00C0      		rjmp .L255
 2538               	.LVL190:
 2539               	.L106:
 2540               	.LBE173:
 149:main.c        **** 			gb_mode();
 2541               		.loc 3 149 0
 2542 00f8 8234      		cpi r24,lo8(66)
 2543 00fa 01F4      		brne .L108
 2544               	.LBB174:
 150:main.c        **** 			
 2545               		.loc 3 150 0
 2546 00fc 00D0      		rcall gb_mode
 2547               	.LVL191:
 152:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2548               		.loc 3 152 0
 2549 00fe 00D0      		rcall usart_read_chars
 2550               	.LVL192:
 153:main.c        **** 			
 2551               		.loc 3 153 0
 2552 0100 40E1      		ldi r20,lo8(16)
 2553 0102 50E0      		ldi r21,0
 2554 0104 60E0      		ldi r22,0
 2555 0106 70E0      		ldi r23,0
 2556 0108 80E0      		ldi r24,lo8(receivedBuffer)
 2557 010a 90E0      		ldi r25,hi8(receivedBuffer)
 2558 010c 00D0      		rcall strtol
 2559               	.LVL193:
 2560 010e 4B01      		movw r8,r22
 2561 0110 5C01      		movw r10,r24
 2562               	.LVL194:
 155:main.c        **** 			if (receivedChar == 'B') {
 2563               		.loc 3 155 0
 2564 0112 00D0      		rcall USART_Receive
 2565               	.LVL195:
 2566 0114 8093 0000 		sts receivedChar,r24
 156:main.c        **** 				usart_read_chars(); // Read data
 2567               		.loc 3 156 0
 2568 0118 8234      		cpi r24,lo8(66)
 2569 011a 01F0      		breq .+2
 2570 011c 00C0      		rjmp .L93
 2571               	.LBB175:
 157:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2572               		.loc 3 157 0
 2573 011e 00D0      		rcall usart_read_chars
 2574               	.LVL196:
 158:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2575               		.loc 3 158 0
 2576 0120 80E0      		ldi r24,lo8(receivedBuffer)
 2577 0122 90E0      		ldi r25,hi8(receivedBuffer)
 2578 0124 00D0      		rcall atoi
 2579               	.LVL197:
 159:main.c        **** 				
 2580               		.loc 3 159 0
 2581 0126 8093 0000 		sts lastBankAccessed,r24
 161:main.c        **** 			}
 2582               		.loc 3 161 0
 2583 012a 40E0      		ldi r20,0
 2584 012c 682F      		mov r22,r24
 2585 012e C401      		movw r24,r8
 2586               	.LVL198:
 2587 0130 00D0      		rcall write_8bit_data
 2588               	.LVL199:
 2589 0132 00C0      		rjmp .L93
 2590               	.LVL200:
 2591               	.L108:
 2592               	.LBE175:
 2593               	.LBE174:
 170:main.c        **** 			gba_mode();
 2594               		.loc 3 170 0
 2595 0134 8237      		cpi r24,lo8(114)
 2596 0136 01F0      		breq .L109
 170:main.c        **** 			gba_mode();
 2597               		.loc 3 170 0 is_stmt 0 discriminator 1
 2598 0138 8A36      		cpi r24,lo8(106)
 2599 013a 01F4      		brne .L110
 2600               	.L109:
 2601               	.LBB176:
 171:main.c        **** 			
 2602               		.loc 3 171 0 is_stmt 1
 2603 013c 00D0      		rcall gba_mode
 2604               	.LVL201:
 174:main.c        **** 				readEnd = 128;
 2605               		.loc 3 174 0
 2606 013e 8091 0000 		lds r24,receivedChar
 2607 0142 8A36      		cpi r24,lo8(106)
 2608 0144 01F4      		brne .L206
 175:main.c        **** 			}
 2609               		.loc 3 175 0
 2610 0146 10E8      		ldi r17,lo8(-128)
 2611 0148 00C0      		rjmp .L111
 2612               	.L206:
 173:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2613               		.loc 3 173 0
 2614 014a 10E2      		ldi r17,lo8(32)
 2615               	.L111:
 2616               	.LVL202:
 178:main.c        **** 			while (receivedChar == '1') {
 2617               		.loc 3 178 0
 2618 014c 3092 0000 		sts receivedChar,r3
 2619 0150 8824      		clr r8
 2620 0152 8A94      		dec r8
 2621 0154 810E      		add r8,r17
 2622 0156 912C      		mov r9,__zero_reg__
 2623 0158 A12C      		mov r10,__zero_reg__
 2624 015a B12C      		mov r11,__zero_reg__
 2625 015c 2FEF      		ldi r18,-1
 2626 015e 821A      		sub r8,r18
 2627 0160 920A      		sbc r9,r18
 2628 0162 A20A      		sbc r10,r18
 2629 0164 B20A      		sbc r11,r18
 2630               	.LVL203:
 2631               	.L112:
 179:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2632               		.loc 3 179 0
 2633 0166 8091 0000 		lds r24,receivedChar
 2634 016a 8133      		cpi r24,lo8(49)
 2635 016c 01F0      		breq .+2
 2636 016e 00C0      		rjmp .L93
 180:main.c        **** 				
 2637               		.loc 3 180 0
 2638 0170 939A      		sbi 0x12,3
 2639               	.LVL204:
 2640 0172 2601      		movw r4,r12
 2641 0174 3701      		movw r6,r14
 2642               	.LVL205:
 2643               	.L113:
 2644               	.LBB165:
 2645               	.LBB166:
 183:main.c        **** 					
 2646               		.loc 3 183 0 discriminator 3
 2647 0176 C301      		movw r24,r6
 2648 0178 B201      		movw r22,r4
 2649 017a 00D0      		rcall gba_read_16bit_data
 2650               	.LVL206:
 2651 017c 092F      		mov r16,r25
 2652               	.LVL207:
 186:main.c        **** 					USART_Transmit(dataRead >> 8);
 2653               		.loc 3 186 0 discriminator 3
 2654 017e 00D0      		rcall USART_Transmit
 2655               	.LVL208:
 187:main.c        **** 					
 2656               		.loc 3 187 0 discriminator 3
 2657 0180 802F      		mov r24,r16
 2658 0182 00D0      		rcall USART_Transmit
 2659               	.LVL209:
 189:main.c        **** 				}
 2660               		.loc 3 189 0 discriminator 3
 2661 0184 8FEF      		ldi r24,-1
 2662 0186 481A      		sub r4,r24
 2663 0188 580A      		sbc r5,r24
 2664 018a 680A      		sbc r6,r24
 2665 018c 780A      		sbc r7,r24
 2666               	.LVL210:
 2667               	.LBE166:
 182:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2668               		.loc 3 182 0 discriminator 3
 2669 018e 842D      		mov r24,r4
 2670 0190 8C19      		sub r24,r12
 2671 0192 8117      		cp r24,r17
 2672 0194 00F0      		brlo .L113
 2673 0196 C80C      		add r12,r8
 2674 0198 D91C      		adc r13,r9
 2675 019a EA1C      		adc r14,r10
 2676 019c FB1C      		adc r15,r11
 2677               	.LVL211:
 2678               	.LBE165:
 192:main.c        **** 				receivedChar = USART_Receive();
 2679               		.loc 3 192 0
 2680 019e 9398      		cbi 0x12,3
 193:main.c        **** 			}
 2681               		.loc 3 193 0
 2682 01a0 00D0      		rcall USART_Receive
 2683               	.LVL212:
 2684 01a2 8093 0000 		sts receivedChar,r24
 2685 01a6 00C0      		rjmp .L112
 2686               	.LVL213:
 2687               	.L110:
 2688               	.LBE176:
 199:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2689               		.loc 3 199 0
 2690 01a8 8D36      		cpi r24,lo8(109)
 2691 01aa 01F4      		brne .L115
 200:main.c        **** 			
 2692               		.loc 3 200 0
 2693 01ac 00D0      		rcall gb_mode
 2694               	.LVL214:
 202:main.c        **** 			while (receivedChar == '1') {
 2695               		.loc 3 202 0
 2696 01ae 3092 0000 		sts receivedChar,r3
 2697               	.LVL215:
 2698               	.L116:
 203:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2699               		.loc 3 203 0
 2700 01b2 8091 0000 		lds r24,receivedChar
 2701 01b6 8133      		cpi r24,lo8(49)
 2702 01b8 01F4      		brne .L238
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2703               		.loc 3 204 0
 2704 01ba 939A      		sbi 0x12,3
 2705               	.LVL216:
 2706 01bc 00E0      		ldi r16,0
 2707 01be 10E0      		ldi r17,0
 2708               	.LVL217:
 2709               	.L117:
 2710               	.LBB177:
 206:main.c        **** 					address++;
 2711               		.loc 3 206 0 discriminator 3
 2712 01c0 C801      		movw r24,r16
 2713 01c2 8C0D      		add r24,r12
 2714 01c4 9D1D      		adc r25,r13
 2715 01c6 00D0      		rcall gba_read_ram_8bit_data
 2716               	.LVL218:
 2717 01c8 00D0      		rcall USART_Transmit
 2718               	.LVL219:
 2719 01ca 0F5F      		subi r16,-1
 2720 01cc 1F4F      		sbci r17,-1
 2721               	.LVL220:
 205:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2722               		.loc 3 205 0 discriminator 3
 2723 01ce 0034      		cpi r16,64
 2724 01d0 1105      		cpc r17,__zero_reg__
 2725 01d2 01F4      		brne .L117
 2726 01d4 90E4      		ldi r25,64
 2727 01d6 C90E      		add r12,r25
 2728 01d8 D11C      		adc r13,__zero_reg__
 2729 01da E11C      		adc r14,__zero_reg__
 2730 01dc F11C      		adc r15,__zero_reg__
 2731               	.LBE177:
 210:main.c        **** 				receivedChar = USART_Receive();
 2732               		.loc 3 210 0
 2733 01de 9398      		cbi 0x12,3
 211:main.c        **** 			}
 2734               		.loc 3 211 0
 2735 01e0 00D0      		rcall USART_Receive
 2736               	.LVL221:
 2737 01e2 8093 0000 		sts receivedChar,r24
 2738 01e6 00C0      		rjmp .L116
 2739               	.LVL222:
 2740               	.L115:
 218:main.c        **** 			gb_mode();
 2741               		.loc 3 218 0
 2742 01e8 8737      		cpi r24,lo8(119)
 2743 01ea 01F4      		brne .L119
 219:main.c        **** 			
 2744               		.loc 3 219 0
 2745 01ec 00D0      		rcall gb_mode
 2746               	.LVL223:
 221:main.c        **** 			
 2747               		.loc 3 221 0
 2748 01ee 80E4      		ldi r24,lo8(64)
 2749 01f0 90E0      		ldi r25,0
 2750 01f2 00D0      		rcall usart_read_bytes
 2751               	.LVL224:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2752               		.loc 3 223 0
 2753 01f4 939A      		sbi 0x12,3
 2754               	.LVL225:
 2755 01f6 10E0      		ldi r17,lo8(receivedBuffer)
 2756 01f8 A12E      		mov r10,r17
 2757 01fa 10E0      		ldi r17,hi8(receivedBuffer)
 2758 01fc B12E      		mov r11,r17
 2759 01fe 00E0      		ldi r16,0
 2760 0200 10E0      		ldi r17,0
 2761               	.LVL226:
 2762               	.L120:
 2763               	.LBB178:
 225:main.c        **** 				address++;
 2764               		.loc 3 225 0 discriminator 3
 2765 0202 F501      		movw r30,r10
 2766 0204 6191      		ld r22,Z+
 2767 0206 5F01      		movw r10,r30
 2768 0208 C801      		movw r24,r16
 2769 020a 8C0D      		add r24,r12
 2770 020c 9D1D      		adc r25,r13
 2771 020e 00D0      		rcall gba_write_ram_8bit_data
 2772               	.LVL227:
 2773 0210 0F5F      		subi r16,-1
 2774 0212 1F4F      		sbci r17,-1
 2775               	.LVL228:
 224:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2776               		.loc 3 224 0 discriminator 3
 2777 0214 0034      		cpi r16,64
 2778 0216 1105      		cpc r17,__zero_reg__
 2779 0218 01F4      		brne .L120
 2780               	.LVL229:
 2781               	.L241:
 2782 021a F0E4      		ldi r31,64
 2783 021c CF0E      		add r12,r31
 2784 021e D11C      		adc r13,__zero_reg__
 2785 0220 E11C      		adc r14,__zero_reg__
 2786 0222 F11C      		adc r15,__zero_reg__
 2787               	.L240:
 2788               	.LBE178:
 228:main.c        **** 			
 2789               		.loc 3 228 0
 2790 0224 81E3      		ldi r24,lo8(49)
 2791 0226 00D0      		rcall USART_Transmit
 2792               	.LVL230:
 230:main.c        **** 			gba_mode(); // Set back
 2793               		.loc 3 230 0
 2794 0228 9398      		cbi 0x12,3
 2795               	.L238:
 231:main.c        **** 		}
 2796               		.loc 3 231 0
 2797 022a 00D0      		rcall gba_mode
 2798               	.LVL231:
 2799 022c 00C0      		rjmp .L93
 2800               	.LVL232:
 2801               	.L119:
 235:main.c        **** 			gb_mode();
 2802               		.loc 3 235 0
 2803 022e 8F36      		cpi r24,lo8(111)
 2804 0230 01F4      		brne .L121
 2805               	.LBB179:
 236:main.c        **** 			
 2806               		.loc 3 236 0
 2807 0232 00D0      		rcall gb_mode
 2808               	.LVL233:
 238:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2809               		.loc 3 238 0
 2810 0234 00D0      		rcall USART_Receive
 2811               	.LVL234:
 239:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2812               		.loc 3 239 0
 2813 0236 682F      		mov r22,r24
 2814 0238 C601      		movw r24,r12
 2815               	.LVL235:
 2816 023a 00D0      		rcall gba_write_ram_8bit_data
 2817               	.LVL236:
 2818 023c 00C0      		rjmp .L243
 2819               	.L121:
 2820               	.LBE179:
 248:main.c        **** 			gb_mode();
 2821               		.loc 3 248 0
 2822 023e 8936      		cpi r24,lo8(105)
 2823 0240 01F4      		brne .L122
 249:main.c        **** 			
 2824               		.loc 3 249 0
 2825 0242 00D0      		rcall gb_mode
 2826               	.LVL237:
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2827               		.loc 3 251 0
 2828 0244 00D0      		rcall flash_read_chip_id
 2829               	.LVL238:
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2830               		.loc 3 252 0
 2831 0246 8091 0000 		lds r24,flashChipIdBuffer
 2832 024a 00D0      		rcall USART_Transmit
 2833               	.LVL239:
 253:main.c        **** 			
 2834               		.loc 3 253 0
 2835 024c 8091 0000 		lds r24,flashChipIdBuffer+1
 2836               	.L242:
 2837 0250 00D0      		rcall USART_Transmit
 2838               	.LVL240:
 2839 0252 00C0      		rjmp .L238
 2840               	.L122:
 259:main.c        **** 			usart_read_chars(); // Read data
 2841               		.loc 3 259 0
 2842 0254 8B36      		cpi r24,lo8(107)
 2843 0256 01F4      		brne .L123
 2844               	.LBB180:
 260:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2845               		.loc 3 260 0
 2846 0258 00D0      		rcall usart_read_chars
 2847               	.LVL241:
 261:main.c        **** 			
 2848               		.loc 3 261 0
 2849 025a 80E0      		ldi r24,lo8(receivedBuffer)
 2850 025c 90E0      		ldi r25,hi8(receivedBuffer)
 2851 025e 00D0      		rcall atoi
 2852               	.LVL242:
 2853 0260 182F      		mov r17,r24
 2854               	.LVL243:
 263:main.c        **** 			flash_switch_bank(bank);
 2855               		.loc 3 263 0
 2856 0262 00D0      		rcall gb_mode
 2857               	.LVL244:
 264:main.c        **** 			
 2858               		.loc 3 264 0
 2859 0264 812F      		mov r24,r17
 2860 0266 00D0      		rcall flash_switch_bank
 2861               	.LVL245:
 2862 0268 00C0      		rjmp .L238
 2863               	.LVL246:
 2864               	.L123:
 2865               	.LBE180:
 270:main.c        **** 			gb_mode();
 2866               		.loc 3 270 0
 2867 026a 8337      		cpi r24,lo8(115)
 2868 026c 01F4      		brne .L124
 2869               	.LBB181:
 271:main.c        **** 			
 2870               		.loc 3 271 0
 2871 026e 00D0      		rcall gb_mode
 2872               	.LVL247:
 273:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2873               		.loc 3 273 0
 2874 0270 00D0      		rcall usart_read_chars
 2875               	.LVL248:
 274:main.c        **** 			
 2876               		.loc 3 274 0
 2877 0272 40E1      		ldi r20,lo8(16)
 2878 0274 50E0      		ldi r21,0
 2879 0276 60E0      		ldi r22,0
 2880 0278 70E0      		ldi r23,0
 2881 027a 80E0      		ldi r24,lo8(receivedBuffer)
 2882 027c 90E0      		ldi r25,hi8(receivedBuffer)
 2883 027e 00D0      		rcall strtol
 2884               	.LVL249:
 2885 0280 862F      		mov r24,r22
 2886               	.LVL250:
 276:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2887               		.loc 3 276 0
 2888 0282 00D0      		rcall flash_erase_4k_sector
 2889               	.LVL251:
 2890               	.L243:
 277:main.c        **** 			
 2891               		.loc 3 277 0
 2892 0284 81E3      		ldi r24,lo8(49)
 2893 0286 00C0      		rjmp .L242
 2894               	.L124:
 2895               	.LBE181:
 283:main.c        **** 			gb_mode();
 2896               		.loc 3 283 0
 2897 0288 8236      		cpi r24,lo8(98)
 2898 028a 01F4      		brne .L125
 284:main.c        **** 			
 2899               		.loc 3 284 0
 2900 028c 00D0      		rcall gb_mode
 2901               	.LVL252:
 286:main.c        **** 			
 2902               		.loc 3 286 0
 2903 028e 80E4      		ldi r24,lo8(64)
 2904 0290 90E0      		ldi r25,0
 2905 0292 00D0      		rcall usart_read_bytes
 2906               	.LVL253:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2907               		.loc 3 288 0
 2908 0294 939A      		sbi 0x12,3
 2909               	.LVL254:
 2910 0296 B0E0      		ldi r27,lo8(receivedBuffer)
 2911 0298 AB2E      		mov r10,r27
 2912 029a B0E0      		ldi r27,hi8(receivedBuffer)
 2913 029c BB2E      		mov r11,r27
 2914 029e 00E0      		ldi r16,0
 2915 02a0 10E0      		ldi r17,0
 2916               	.LVL255:
 2917               	.L126:
 2918               	.LBB182:
 290:main.c        **** 				address++;
 2919               		.loc 3 290 0 discriminator 3
 2920 02a2 F501      		movw r30,r10
 2921 02a4 6191      		ld r22,Z+
 2922 02a6 5F01      		movw r10,r30
 2923 02a8 C801      		movw r24,r16
 2924 02aa 8C0D      		add r24,r12
 2925 02ac 9D1D      		adc r25,r13
 2926 02ae 00D0      		rcall flash_write_byte
 2927               	.LVL256:
 2928 02b0 0F5F      		subi r16,-1
 2929 02b2 1F4F      		sbci r17,-1
 2930               	.LVL257:
 289:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2931               		.loc 3 289 0 discriminator 3
 2932 02b4 0034      		cpi r16,64
 2933 02b6 1105      		cpc r17,__zero_reg__
 2934 02b8 01F4      		brne .L126
 2935 02ba 00C0      		rjmp .L241
 2936               	.LVL258:
 2937               	.L125:
 2938               	.LBE182:
 300:main.c        **** 			gb_mode();
 2939               		.loc 3 300 0
 2940 02bc 8136      		cpi r24,lo8(97)
 2941 02be 01F4      		brne .L127
 301:main.c        **** 			
 2942               		.loc 3 301 0
 2943 02c0 00D0      		rcall gb_mode
 2944               	.LVL259:
 303:main.c        **** 			
 2945               		.loc 3 303 0
 2946 02c2 80E8      		ldi r24,lo8(-128)
 2947 02c4 90E0      		ldi r25,0
 2948 02c6 00D0      		rcall usart_read_bytes
 2949               	.LVL260:
 305:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2950               		.loc 3 305 0
 2951 02c8 939A      		sbi 0x12,3
 306:main.c        **** 			address++;
 2952               		.loc 3 306 0
 2953 02ca C601      		movw r24,r12
 2954 02cc 00D0      		rcall flash_write_sector
 2955               	.LVL261:
 307:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2956               		.loc 3 307 0
 2957 02ce 2FEF      		ldi r18,-1
 2958 02d0 C21A      		sub r12,r18
 2959 02d2 D20A      		sbc r13,r18
 2960 02d4 E20A      		sbc r14,r18
 2961 02d6 F20A      		sbc r15,r18
 2962               	.LVL262:
 2963 02d8 00C0      		rjmp .L240
 2964               	.L127:
 317:main.c        **** 			usart_read_chars(); // Read size
 2965               		.loc 3 317 0
 2966 02da 8335      		cpi r24,lo8(83)
 2967 02dc 01F4      		brne .L128
 318:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2968               		.loc 3 318 0
 2969 02de 00D0      		rcall usart_read_chars
 2970               	.LVL263:
 319:main.c        **** 		}
 2971               		.loc 3 319 0
 2972 02e0 40E1      		ldi r20,lo8(16)
 2973 02e2 50E0      		ldi r21,0
 2974 02e4 60E0      		ldi r22,0
 2975 02e6 70E0      		ldi r23,0
 2976 02e8 80E0      		ldi r24,lo8(receivedBuffer)
 2977 02ea 90E0      		ldi r25,hi8(receivedBuffer)
 2978 02ec 00D0      		rcall strtol
 2979               	.LVL264:
 2980 02ee D62F      		mov r29,r22
 2981               	.LVL265:
 2982 02f0 00C0      		rjmp .L93
 2983               	.LVL266:
 2984               	.L128:
 323:main.c        **** 			gba_eeprom_mode();
 2985               		.loc 3 323 0
 2986 02f2 8536      		cpi r24,lo8(101)
 2987 02f4 01F4      		brne .L129
 324:main.c        **** 			
 2988               		.loc 3 324 0
 2989 02f6 00D0      		rcall gba_eeprom_mode
 2990               	.LVL267:
 326:main.c        **** 			while (receivedChar == '1') {
 2991               		.loc 3 326 0
 2992 02f8 3092 0000 		sts receivedChar,r3
 2993               	.L130:
 327:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2994               		.loc 3 327 0
 2995 02fc 8091 0000 		lds r24,receivedChar
 2996 0300 8133      		cpi r24,lo8(49)
 2997 0302 01F0      		breq .+2
 2998 0304 00C0      		rjmp .L238
 328:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2999               		.loc 3 328 0
 3000 0306 939A      		sbi 0x12,3
 329:main.c        **** 				
 3001               		.loc 3 329 0
 3002 0308 6D2F      		mov r22,r29
 3003 030a C601      		movw r24,r12
 3004 030c 00D0      		rcall gba_eeprom_read
 3005               	.LVL268:
 3006 030e 00E0      		ldi r16,lo8(eepromBuffer)
 3007 0310 10E0      		ldi r17,hi8(eepromBuffer)
 3008               	.LVL269:
 3009               	.L131:
 3010               	.LBB183:
 333:main.c        **** 				}
 3011               		.loc 3 333 0 discriminator 3
 3012 0312 F801      		movw r30,r16
 3013 0314 8191      		ld r24,Z+
 3014 0316 8F01      		movw r16,r30
 3015               	.LVL270:
 3016 0318 00D0      		rcall USART_Transmit
 3017               	.LVL271:
 332:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3018               		.loc 3 332 0 discriminator 3
 3019 031a 80E0      		ldi r24,lo8(eepromBuffer+8)
 3020 031c 90E0      		ldi r25,hi8(eepromBuffer+8)
 3021 031e 8017      		cp r24,r16
 3022 0320 9107      		cpc r25,r17
 3023 0322 01F4      		brne .L131
 3024               	.LBE183:
 335:main.c        **** 				
 3025               		.loc 3 335 0
 3026 0324 9FEF      		ldi r25,-1
 3027 0326 C91A      		sub r12,r25
 3028 0328 D90A      		sbc r13,r25
 3029 032a E90A      		sbc r14,r25
 3030 032c F90A      		sbc r15,r25
 3031               	.LVL272:
 337:main.c        **** 				receivedChar = USART_Receive();
 3032               		.loc 3 337 0
 3033 032e 9398      		cbi 0x12,3
 338:main.c        **** 			}
 3034               		.loc 3 338 0
 3035 0330 00D0      		rcall USART_Receive
 3036               	.LVL273:
 3037 0332 8093 0000 		sts receivedChar,r24
 3038 0336 00C0      		rjmp .L130
 3039               	.LVL274:
 3040               	.L129:
 345:main.c        **** 			gba_eeprom_mode();
 3041               		.loc 3 345 0
 3042 0338 8037      		cpi r24,lo8(112)
 3043 033a 01F4      		brne .L133
 346:main.c        **** 			
 3044               		.loc 3 346 0
 3045 033c 00D0      		rcall gba_eeprom_mode
 3046               	.LVL275:
 3047 033e 00E0      		ldi r16,lo8(eepromBuffer)
 3048 0340 10E0      		ldi r17,hi8(eepromBuffer)
 3049               	.LVL276:
 3050               	.L134:
 3051               	.LBB184:
 350:main.c        **** 			}
 3052               		.loc 3 350 0 discriminator 3
 3053 0342 00D0      		rcall USART_Receive
 3054               	.LVL277:
 3055 0344 F801      		movw r30,r16
 3056 0346 8193      		st Z+,r24
 3057 0348 8F01      		movw r16,r30
 3058               	.LVL278:
 349:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3059               		.loc 3 349 0 discriminator 3
 3060 034a 80E0      		ldi r24,lo8(eepromBuffer+8)
 3061 034c 90E0      		ldi r25,hi8(eepromBuffer+8)
 3062 034e 8E17      		cp r24,r30
 3063 0350 9F07      		cpc r25,r31
 3064 0352 01F4      		brne .L134
 3065               	.LBE184:
 352:main.c        **** 			
 3066               		.loc 3 352 0
 3067 0354 939A      		sbi 0x12,3
 354:main.c        **** 			address++;
 3068               		.loc 3 354 0
 3069 0356 6D2F      		mov r22,r29
 3070 0358 C601      		movw r24,r12
 3071 035a 00D0      		rcall gba_eeprom_write
 3072               	.LVL279:
 355:main.c        **** 			
 3073               		.loc 3 355 0
 3074 035c 9FEF      		ldi r25,-1
 3075 035e C91A      		sub r12,r25
 3076 0360 D90A      		sbc r13,r25
 3077 0362 E90A      		sbc r14,r25
 3078 0364 F90A      		sbc r15,r25
 3079               	.LVL280:
 3080               	.LBB185:
 3081               	.LBB186:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3082               		.loc 2 187 0
 3083 0366 EFE7      		ldi r30,lo8(15999)
 3084 0368 FEE3      		ldi r31,hi8(15999)
 3085 036a 3197      	1:	sbiw r30,1
 3086 036c 01F4      		brne 1b
 3087 036e 00C0      		rjmp .
 3088 0370 0000      		nop
 3089               	.LVL281:
 3090 0372 00C0      		rjmp .L240
 3091               	.LVL282:
 3092               	.L133:
 3093               	.LBE186:
 3094               	.LBE185:
 367:main.c        **** 			flashWriteWePin = USART_Receive();
 3095               		.loc 3 367 0
 3096 0374 8035      		cpi r24,lo8(80)
 3097 0376 01F4      		brne .L135
 368:main.c        **** 			
 3098               		.loc 3 368 0
 3099 0378 00D0      		rcall USART_Receive
 3100               	.LVL283:
 3101 037a 8093 0000 		sts flashWriteWePin,r24
 370:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3102               		.loc 3 370 0
 3103 037e 8134      		cpi r24,lo8(65)
 3104 0380 01F0      		breq .+2
 3105 0382 00C0      		rjmp .L93
 371:main.c        **** 				audioPin_high;
 3106               		.loc 3 371 0
 3107 0384 319A      		sbi 0x6,1
 372:main.c        **** 			}
 3108               		.loc 3 372 0
 3109 0386 399A      		sbi 0x7,1
 3110 0388 00C0      		rjmp .L93
 3111               	.L135:
 377:main.c        **** 			flashBank1CommandWrites = 1;
 3112               		.loc 3 377 0
 3113 038a 8E34      		cpi r24,lo8(78)
 3114 038c 01F4      		brne .L136
 378:main.c        **** 		}
 3115               		.loc 3 378 0
 3116 038e 81E0      		ldi r24,lo8(1)
 3117 0390 8093 0000 		sts flashBank1CommandWrites,r24
 3118 0394 00C0      		rjmp .L93
 3119               	.L136:
 382:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 3120               		.loc 3 382 0
 3121 0396 8534      		cpi r24,lo8(69)
 3122 0398 01F4      		brne .L137
 3123 039a 00E0      		ldi r16,lo8(flashWriteCycle)
 3124 039c 10E0      		ldi r17,hi8(flashWriteCycle)
 3125               	.L138:
 3126               	.LBB187:
 384:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3127               		.loc 3 384 0 discriminator 3
 3128 039e 00D0      		rcall usart_read_chars
 3129               	.LVL284:
 385:main.c        **** 				USART_Transmit(SEND_ACK);
 3130               		.loc 3 385 0 discriminator 3
 3131 03a0 40E1      		ldi r20,lo8(16)
 3132 03a2 50E0      		ldi r21,0
 3133 03a4 60E0      		ldi r22,0
 3134 03a6 70E0      		ldi r23,0
 3135 03a8 80E0      		ldi r24,lo8(receivedBuffer)
 3136 03aa 90E0      		ldi r25,hi8(receivedBuffer)
 3137 03ac 00D0      		rcall strtol
 3138               	.LVL285:
 3139 03ae F801      		movw r30,r16
 3140 03b0 7183      		std Z+1,r23
 3141 03b2 6083      		st Z,r22
 386:main.c        **** 				
 3142               		.loc 3 386 0 discriminator 3
 3143 03b4 81E3      		ldi r24,lo8(49)
 3144 03b6 00D0      		rcall USART_Transmit
 3145               	.LVL286:
 388:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3146               		.loc 3 388 0 discriminator 3
 3147 03b8 00D0      		rcall usart_read_chars
 3148               	.LVL287:
 389:main.c        **** 				USART_Transmit(SEND_ACK);
 3149               		.loc 3 389 0 discriminator 3
 3150 03ba 40E1      		ldi r20,lo8(16)
 3151 03bc 50E0      		ldi r21,0
 3152 03be 60E0      		ldi r22,0
 3153 03c0 70E0      		ldi r23,0
 3154 03c2 80E0      		ldi r24,lo8(receivedBuffer)
 3155 03c4 90E0      		ldi r25,hi8(receivedBuffer)
 3156 03c6 00D0      		rcall strtol
 3157               	.LVL288:
 3158 03c8 F801      		movw r30,r16
 3159 03ca 7383      		std Z+3,r23
 3160 03cc 6283      		std Z+2,r22
 390:main.c        **** 			}
 3161               		.loc 3 390 0 discriminator 3
 3162 03ce 81E3      		ldi r24,lo8(49)
 3163 03d0 00D0      		rcall USART_Transmit
 3164               	.LVL289:
 3165 03d2 0C5F      		subi r16,-4
 3166 03d4 1F4F      		sbci r17,-1
 383:main.c        **** 				usart_read_chars(); // Address
 3167               		.loc 3 383 0 discriminator 3
 3168 03d6 F0E0      		ldi r31,hi8(flashWriteCycle+12)
 3169 03d8 0030      		cpi r16,lo8(flashWriteCycle+12)
 3170 03da 1F07      		cpc r17,r31
 3171 03dc 01F4      		brne .L138
 3172 03de 00C0      		rjmp .L93
 3173               	.L137:
 3174               	.LBE187:
 395:main.c        **** 			usart_read_chars(); // Read address
 3175               		.loc 3 395 0
 3176 03e0 8634      		cpi r24,lo8(70)
 3177 03e2 01F4      		brne .L139
 3178               	.LBB188:
 396:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3179               		.loc 3 396 0
 3180 03e4 00D0      		rcall usart_read_chars
 3181               	.LVL290:
 397:main.c        **** 			
 3182               		.loc 3 397 0
 3183 03e6 40E1      		ldi r20,lo8(16)
 3184 03e8 50E0      		ldi r21,0
 3185 03ea 60E0      		ldi r22,0
 3186 03ec 70E0      		ldi r23,0
 3187 03ee 80E0      		ldi r24,lo8(receivedBuffer)
 3188 03f0 90E0      		ldi r25,hi8(receivedBuffer)
 3189 03f2 00D0      		rcall strtol
 3190               	.LVL291:
 3191 03f4 4B01      		movw r8,r22
 3192 03f6 5C01      		movw r10,r24
 3193               	.LVL292:
 399:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3194               		.loc 3 399 0
 3195 03f8 00D0      		rcall usart_read_chars
 3196               	.LVL293:
 400:main.c        **** 			
 3197               		.loc 3 400 0
 3198 03fa 40E1      		ldi r20,lo8(16)
 3199 03fc 50E0      		ldi r21,0
 3200 03fe 60E0      		ldi r22,0
 3201 0400 70E0      		ldi r23,0
 3202 0402 80E0      		ldi r24,lo8(receivedBuffer)
 3203 0404 90E0      		ldi r25,hi8(receivedBuffer)
 3204 0406 00D0      		rcall strtol
 3205               	.LVL294:
 402:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3206               		.loc 3 402 0
 3207 0408 939A      		sbi 0x12,3
 403:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3208               		.loc 3 403 0
 3209 040a C401      		movw r24,r8
 3210 040c 00D0      		rcall gb_flash_write_bus_cycle
 3211               	.LVL295:
 3212 040e 00C0      		rjmp .L255
 3213               	.LVL296:
 3214               	.L139:
 3215               	.LBE188:
 410:main.c        **** 			usart_read_bytes(64);
 3216               		.loc 3 410 0
 3217 0410 8435      		cpi r24,lo8(84)
 3218 0412 01F4      		brne .L140
 411:main.c        **** 			
 3219               		.loc 3 411 0
 3220 0414 80E4      		ldi r24,lo8(64)
 3221 0416 90E0      		ldi r25,0
 3222 0418 00D0      		rcall usart_read_bytes
 3223               	.LVL297:
 413:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3224               		.loc 3 413 0
 3225 041a 939A      		sbi 0x12,3
 3226               	.LVL298:
 3227 041c F0E0      		ldi r31,lo8(receivedBuffer)
 3228 041e AF2E      		mov r10,r31
 3229 0420 F0E0      		ldi r31,hi8(receivedBuffer)
 3230 0422 BF2E      		mov r11,r31
 3231 0424 A0E4      		ldi r26,lo8(64)
 3232 0426 9A2E      		mov r9,r26
 3233 0428 8601      		movw r16,r12
 3234 042a 0050      		subi r16,lo8(receivedBuffer)
 3235 042c 1040      		sbci r17,hi8(receivedBuffer)
 3236               	.LVL299:
 3237               	.L143:
 3238               	.LBB189:
 415:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3239               		.loc 3 415 0
 3240 042e 8091 0000 		lds r24,flashBank1CommandWrites
 416:main.c        **** 				}
 3241               		.loc 3 416 0
 3242 0432 F501      		movw r30,r10
 3243 0434 6081      		ld r22,Z
 415:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3244               		.loc 3 415 0
 3245 0436 8111      		cpse r24,__zero_reg__
 3246 0438 00C0      		rjmp .L141
 416:main.c        **** 				}
 3247               		.loc 3 416 0
 3248 043a C801      		movw r24,r16
 3249 043c 8A0D      		add r24,r10
 3250 043e 9B1D      		adc r25,r11
 3251 0440 00D0      		rcall gb_flash_write_byte
 3252               	.LVL300:
 3253 0442 00C0      		rjmp .L142
 3254               	.L141:
 419:main.c        **** 				}
 3255               		.loc 3 419 0
 3256 0444 C801      		movw r24,r16
 3257 0446 8A0D      		add r24,r10
 3258 0448 9B1D      		adc r25,r11
 3259 044a 00D0      		rcall gb_flash_write_byte_bank1_commands
 3260               	.LVL301:
 3261               	.L142:
 3262 044c 9A94      		dec r9
 3263 044e FFEF      		ldi r31,-1
 3264 0450 AF1A      		sub r10,r31
 3265 0452 BF0A      		sbc r11,r31
 3266               	.LVL302:
 414:main.c        **** 				if (flashBank1CommandWrites == 0) {
 3267               		.loc 3 414 0 discriminator 2
 3268 0454 9110      		cpse r9,__zero_reg__
 3269 0456 00C0      		rjmp .L143
 3270 0458 20E4      		ldi r18,64
 3271 045a C20E      		add r12,r18
 3272 045c D11C      		adc r13,__zero_reg__
 3273 045e E11C      		adc r14,__zero_reg__
 3274 0460 F11C      		adc r15,__zero_reg__
 3275 0462 00C0      		rjmp .L244
 3276               	.LVL303:
 3277               	.L140:
 3278               	.LBE189:
 429:main.c        **** 			usart_read_bytes(32);
 3279               		.loc 3 429 0
 3280 0464 8935      		cpi r24,lo8(89)
 3281 0466 01F0      		breq .+2
 3282 0468 00C0      		rjmp .L144
 3283               	.LBB190:
 430:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3284               		.loc 3 430 0
 3285 046a 80E2      		ldi r24,lo8(32)
 3286 046c 90E0      		ldi r25,0
 3287 046e 00D0      		rcall usart_read_bytes
 3288               	.LVL304:
 431:main.c        **** 			
 3289               		.loc 3 431 0
 3290 0470 939A      		sbi 0x12,3
 434:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3291               		.loc 3 434 0
 3292 0472 6AEA      		ldi r22,lo8(-86)
 3293 0474 8AEA      		ldi r24,lo8(-86)
 3294 0476 9AE0      		ldi r25,lo8(10)
 3295 0478 00D0      		rcall gb_flash_write_bus_cycle
 3296               	.LVL305:
 435:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3297               		.loc 3 435 0
 3298 047a 65E5      		ldi r22,lo8(85)
 3299 047c 85E5      		ldi r24,lo8(85)
 3300 047e 95E0      		ldi r25,lo8(5)
 3301 0480 00D0      		rcall gb_flash_write_bus_cycle
 3302               	.LVL306:
 436:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3303               		.loc 3 436 0
 3304 0482 5601      		movw r10,r12
 3305 0484 65E2      		ldi r22,lo8(37)
 3306 0486 C601      		movw r24,r12
 3307 0488 00D0      		rcall gb_flash_write_bus_cycle
 3308               	.LVL307:
 437:main.c        **** 			_delay_us(1);
 3309               		.loc 3 437 0
 3310 048a 6FE1      		ldi r22,lo8(31)
 3311 048c C601      		movw r24,r12
 3312 048e 00D0      		rcall gb_flash_write_bus_cycle
 3313               	.LVL308:
 3314               	.LBB191:
 3315               	.LBB192:
 3316               		.loc 2 276 0
 3317 0490 82E0      		ldi r24,lo8(2)
 3318 0492 8A95      	1:	dec r24
 3319 0494 01F4      		brne 1b
 3320 0496 00C0      		rjmp .
 3321               	.LVL309:
 3322 0498 00E0      		ldi r16,lo8(receivedBuffer)
 3323 049a 10E0      		ldi r17,hi8(receivedBuffer)
 3324 049c 812C      		mov r8,__zero_reg__
 3325 049e 912C      		mov r9,__zero_reg__
 3326               	.LVL310:
 3327               	.L145:
 3328               	.LBE192:
 3329               	.LBE191:
 3330               	.LBB193:
 442:main.c        **** 				address++;
 3331               		.loc 3 442 0 discriminator 3
 3332 04a0 F801      		movw r30,r16
 3333 04a2 6191      		ld r22,Z+
 3334 04a4 8F01      		movw r16,r30
 3335 04a6 C401      		movw r24,r8
 3336 04a8 8A0D      		add r24,r10
 3337 04aa 9B1D      		adc r25,r11
 3338 04ac 00D0      		rcall gb_flash_write_bus_cycle
 3339               	.LVL311:
 3340 04ae FFEF      		ldi r31,-1
 3341 04b0 8F1A      		sub r8,r31
 3342 04b2 9F0A      		sbc r9,r31
 3343               	.LVL312:
 441:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3344               		.loc 3 441 0 discriminator 3
 3345 04b4 20E2      		ldi r18,32
 3346 04b6 8216      		cp r8,r18
 3347 04b8 9104      		cpc r9,__zero_reg__
 3348 04ba 01F4      		brne .L145
 3349 04bc 80E2      		ldi r24,32
 3350 04be C80E      		add r12,r24
 3351 04c0 D11C      		adc r13,__zero_reg__
 3352 04c2 E11C      		adc r14,__zero_reg__
 3353 04c4 F11C      		adc r15,__zero_reg__
 3354               	.LBE193:
 447:main.c        **** 			_delay_us(200);
 3355               		.loc 3 447 0
 3356 04c6 C601      		movw r24,r12
 3357 04c8 8097      		sbiw r24,32
 3358 04ca 69E2      		ldi r22,lo8(41)
 3359 04cc 00D0      		rcall gb_flash_write_bus_cycle
 3360               	.LVL313:
 3361               	.LBB194:
 3362               	.LBB195:
 3363               		.loc 2 276 0
 3364 04ce EFE8      		ldi r30,lo8(399)
 3365 04d0 F1E0      		ldi r31,hi8(399)
 3366 04d2 3197      	1:	sbiw r30,1
 3367 04d4 01F4      		brne 1b
 3368 04d6 00C0      		rjmp .
 3369 04d8 0000      		nop
 3370               	.LVL314:
 3371               	.LBE195:
 3372               	.LBE194:
 451:main.c        **** 			uint8_t verifyCount = 0;
 3373               		.loc 3 451 0
 3374 04da 8601      		movw r16,r12
 3375 04dc 0150      		subi r16,1
 3376 04de 1109      		sbc r17,__zero_reg__
 3377 04e0 C801      		movw r24,r16
 3378 04e2 00D0      		rcall gb_flash_read_byte
 3379               	.LVL315:
 453:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3380               		.loc 3 453 0
 3381 04e4 E8EC      		ldi r30,lo8(-56)
 3382 04e6 BE2E      		mov r11,r30
 3383               	.LVL316:
 3384               	.L146:
 3385 04e8 9091 0000 		lds r25,receivedBuffer+31
 3386 04ec 8917      		cp r24,r25
 3387 04ee 01F4      		brne .+2
 3388 04f0 00C0      		rjmp .L244
 454:main.c        **** 				_delay_us(5);
 3389               		.loc 3 454 0
 3390 04f2 C801      		movw r24,r16
 3391               	.LVL317:
 3392 04f4 00D0      		rcall gb_flash_read_byte
 3393               	.LVL318:
 3394               	.LBB196:
 3395               	.LBB197:
 3396               		.loc 2 276 0
 3397 04f6 FDE0      		ldi r31,lo8(13)
 3398 04f8 FA95      	1:	dec r31
 3399 04fa 01F4      		brne 1b
 3400 04fc 0000      		nop
 3401               	.LVL319:
 3402 04fe BA94      		dec r11
 3403               	.LVL320:
 3404               	.LBE197:
 3405               	.LBE196:
 457:main.c        **** 					_delay_ms(500);
 3406               		.loc 3 457 0
 3407 0500 B110      		cpse r11,__zero_reg__
 3408 0502 00C0      		rjmp .L146
 3409               	.LVL321:
 3410               	.LBB198:
 3411               	.LBB199:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3412               		.loc 2 187 0
 3413 0504 2FEF      		ldi r18,lo8(799999)
 3414 0506 84E3      		ldi r24,hi8(799999)
 3415 0508 9CE0      		ldi r25,hlo8(799999)
 3416 050a 2150      	1:	subi r18,1
 3417 050c 8040      		sbci r24,0
 3418 050e 9040      		sbci r25,0
 3419 0510 01F4      		brne 1b
 3420               	.LVL322:
 3421 0512 00C0      		rjmp .L256
 3422               	.LVL323:
 3423               	.L144:
 3424               	.LBE199:
 3425               	.LBE198:
 3426               	.LBE190:
 468:main.c        **** 			usart_read_bytes(256);
 3427               		.loc 3 468 0
 3428 0514 8835      		cpi r24,lo8(88)
 3429 0516 01F0      		breq .+2
 3430 0518 00C0      		rjmp .L149
 3431               	.LBB200:
 469:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3432               		.loc 3 469 0
 3433 051a 80E0      		ldi r24,0
 3434 051c 91E0      		ldi r25,lo8(1)
 3435 051e 00D0      		rcall usart_read_bytes
 3436               	.LVL324:
 470:main.c        **** 			
 3437               		.loc 3 470 0
 3438 0520 939A      		sbi 0x12,3
 473:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3439               		.loc 3 473 0
 3440 0522 69EA      		ldi r22,lo8(-87)
 3441 0524 8AEA      		ldi r24,lo8(-86)
 3442 0526 9AE0      		ldi r25,lo8(10)
 3443 0528 00D0      		rcall gb_flash_write_bus_cycle
 3444               	.LVL325:
 474:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3445               		.loc 3 474 0
 3446 052a 66E5      		ldi r22,lo8(86)
 3447 052c 85E5      		ldi r24,lo8(85)
 3448 052e 95E0      		ldi r25,lo8(5)
 3449 0530 00D0      		rcall gb_flash_write_bus_cycle
 3450               	.LVL326:
 475:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3451               		.loc 3 475 0
 3452 0532 5601      		movw r10,r12
 3453 0534 66E2      		ldi r22,lo8(38)
 3454 0536 C601      		movw r24,r12
 3455 0538 00D0      		rcall gb_flash_write_bus_cycle
 3456               	.LVL327:
 476:main.c        **** 			_delay_us(50);
 3457               		.loc 3 476 0
 3458 053a 6FEF      		ldi r22,lo8(-1)
 3459 053c C601      		movw r24,r12
 3460 053e 00D0      		rcall gb_flash_write_bus_cycle
 3461               	.LVL328:
 3462               	.LBB201:
 3463               	.LBB202:
 3464               		.loc 2 276 0
 3465 0540 E5E8      		ldi r30,lo8(-123)
 3466 0542 EA95      	1:	dec r30
 3467 0544 01F4      		brne 1b
 3468 0546 0000      		nop
 3469               	.LVL329:
 3470 0548 00E0      		ldi r16,lo8(receivedBuffer)
 3471 054a 10E0      		ldi r17,hi8(receivedBuffer)
 3472               	.LBE202:
 3473               	.LBE201:
 3474               	.LBB203:
 480:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3475               		.loc 3 480 0
 3476 054c 812C      		mov r8,__zero_reg__
 3477 054e 912C      		mov r9,__zero_reg__
 3478               	.LVL330:
 3479               	.L150:
 481:main.c        **** 				address++;
 3480               		.loc 3 481 0 discriminator 3
 3481 0550 F801      		movw r30,r16
 3482 0552 6191      		ld r22,Z+
 3483 0554 8F01      		movw r16,r30
 3484 0556 C401      		movw r24,r8
 3485 0558 8A0D      		add r24,r10
 3486 055a 9B1D      		adc r25,r11
 3487 055c 00D0      		rcall gb_flash_write_bus_cycle
 3488               	.LVL331:
 480:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3489               		.loc 3 480 0 discriminator 3
 3490 055e FFEF      		ldi r31,-1
 3491 0560 8F1A      		sub r8,r31
 3492 0562 9F0A      		sbc r9,r31
 3493               	.LVL332:
 3494 0564 8114      		cp r8,__zero_reg__
 3495 0566 21E0      		ldi r18,1
 3496 0568 9206      		cpc r9,r18
 3497 056a 01F4      		brne .L150
 3498 056c 8FEF      		ldi r24,-1
 3499 056e D81A      		sub r13,r24
 3500 0570 E80A      		sbc r14,r24
 3501 0572 F80A      		sbc r15,r24
 3502               	.LBE203:
 486:main.c        **** 			
 3503               		.loc 3 486 0
 3504 0574 C601      		movw r24,r12
 3505 0576 9A95      		dec r25
 3506 0578 6AE2      		ldi r22,lo8(42)
 3507 057a 00D0      		rcall gb_flash_write_bus_cycle
 3508               	.LVL333:
 489:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 3509               		.loc 3 489 0
 3510 057c 8601      		movw r16,r12
 3511 057e 0150      		subi r16,1
 3512 0580 1109      		sbc r17,__zero_reg__
 3513 0582 C801      		movw r24,r16
 3514 0584 00D0      		rcall gb_flash_read_byte
 3515               	.LVL334:
 3516               	.L151:
 490:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3517               		.loc 3 490 0
 3518 0586 9091 0000 		lds r25,receivedBuffer+255
 3519 058a 8917      		cp r24,r25
 3520 058c 01F4      		brne .+2
 3521 058e 00C0      		rjmp .L244
 491:main.c        **** 				_delay_us(5);
 3522               		.loc 3 491 0
 3523 0590 C801      		movw r24,r16
 3524               	.LVL335:
 3525 0592 00D0      		rcall gb_flash_read_byte
 3526               	.LVL336:
 3527               	.LBB204:
 3528               	.LBB205:
 3529               		.loc 2 276 0
 3530 0594 9DE0      		ldi r25,lo8(13)
 3531 0596 9A95      	1:	dec r25
 3532 0598 01F4      		brne 1b
 3533 059a 0000      		nop
 3534 059c 00C0      		rjmp .L151
 3535               	.LVL337:
 3536               	.L149:
 3537               	.LBE205:
 3538               	.LBE204:
 3539               	.LBE200:
 500:main.c        **** 			usart_read_bytes(128);
 3540               		.loc 3 500 0
 3541 059e 8A35      		cpi r24,lo8(90)
 3542 05a0 01F0      		breq .+2
 3543 05a2 00C0      		rjmp .L153
 501:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3544               		.loc 3 501 0
 3545 05a4 80E8      		ldi r24,lo8(-128)
 3546 05a6 90E0      		ldi r25,0
 3547 05a8 00D0      		rcall usart_read_bytes
 3548               	.LVL338:
 502:main.c        **** 			
 3549               		.loc 3 502 0
 3550 05aa 939A      		sbi 0x12,3
 505:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 3551               		.loc 3 505 0
 3552 05ac 69E0      		ldi r22,lo8(9)
 3553 05ae 80E2      		ldi r24,lo8(32)
 3554 05b0 91E0      		ldi r25,lo8(1)
 3555 05b2 00D0      		rcall gb_flash_write_bus_cycle
 3556               	.LVL339:
 506:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 3557               		.loc 3 506 0
 3558 05b4 6AEA      		ldi r22,lo8(-86)
 3559 05b6 81E2      		ldi r24,lo8(33)
 3560 05b8 91E0      		ldi r25,lo8(1)
 3561 05ba 00D0      		rcall gb_flash_write_bus_cycle
 3562               	.LVL340:
 507:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3563               		.loc 3 507 0
 3564 05bc 65E5      		ldi r22,lo8(85)
 3565 05be 82E2      		ldi r24,lo8(34)
 3566 05c0 91E0      		ldi r25,lo8(1)
 3567 05c2 00D0      		rcall gb_flash_write_bus_cycle
 3568               	.LVL341:
 508:main.c        **** 			_delay_us(5);
 3569               		.loc 3 508 0
 3570 05c4 65EA      		ldi r22,lo8(-91)
 3571 05c6 8FE3      		ldi r24,lo8(63)
 3572 05c8 91E0      		ldi r25,lo8(1)
 3573 05ca 00D0      		rcall gb_flash_write_bus_cycle
 3574               	.LVL342:
 3575               	.LBB206:
 3576               	.LBB207:
 3577               		.loc 2 276 0
 3578 05cc EDE0      		ldi r30,lo8(13)
 3579 05ce EA95      	1:	dec r30
 3580 05d0 01F4      		brne 1b
 3581 05d2 0000      		nop
 3582               	.LVL343:
 3583               	.LBE207:
 3584               	.LBE206:
 512:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3585               		.loc 3 512 0
 3586 05d4 61E1      		ldi r22,lo8(17)
 3587 05d6 80E2      		ldi r24,lo8(32)
 3588 05d8 91E0      		ldi r25,lo8(1)
 3589 05da 00D0      		rcall gb_flash_write_bus_cycle
 3590               	.LVL344:
 513:main.c        **** 			_delay_us(5);
 3591               		.loc 3 513 0
 3592 05dc 65EA      		ldi r22,lo8(-91)
 3593 05de 8FE3      		ldi r24,lo8(63)
 3594 05e0 91E0      		ldi r25,lo8(1)
 3595 05e2 00D0      		rcall gb_flash_write_bus_cycle
 3596               	.LVL345:
 3597               	.LBB208:
 3598               	.LBB209:
 3599               		.loc 2 276 0
 3600 05e4 FDE0      		ldi r31,lo8(13)
 3601 05e6 FA95      	1:	dec r31
 3602 05e8 01F4      		brne 1b
 3603 05ea 0000      		nop
 3604               	.LVL346:
 3605               	.LBE209:
 3606               	.LBE208:
 517:main.c        **** 			_delay_us(5);
 3607               		.loc 3 517 0
 3608 05ec 61E0      		ldi r22,lo8(1)
 3609 05ee 80E0      		ldi r24,0
 3610 05f0 91E2      		ldi r25,lo8(33)
 3611 05f2 00D0      		rcall gb_flash_write_bus_cycle
 3612               	.LVL347:
 3613               	.LBB210:
 3614               	.LBB211:
 3615               		.loc 2 276 0
 3616 05f4 2DE0      		ldi r18,lo8(13)
 3617 05f6 2A95      	1:	dec r18
 3618 05f8 01F4      		brne 1b
 3619 05fa 0000      		nop
 3620               	.LVL348:
 3621               	.LBE211:
 3622               	.LBE210:
 522:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3623               		.loc 3 522 0
 3624 05fc 6FE0      		ldi r22,lo8(15)
 3625 05fe 80E2      		ldi r24,lo8(32)
 3626 0600 91E0      		ldi r25,lo8(1)
 3627 0602 00D0      		rcall gb_flash_write_bus_cycle
 3628               	.LVL349:
 523:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3629               		.loc 3 523 0
 3630 0604 65E5      		ldi r22,lo8(85)
 3631 0606 85E2      		ldi r24,lo8(37)
 3632 0608 91E0      		ldi r25,lo8(1)
 3633 060a 00D0      		rcall gb_flash_write_bus_cycle
 3634               	.LVL350:
 524:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 3635               		.loc 3 524 0
 3636 060c 65E5      		ldi r22,lo8(85)
 3637 060e 86E2      		ldi r24,lo8(38)
 3638 0610 91E0      		ldi r25,lo8(1)
 3639 0612 00D0      		rcall gb_flash_write_bus_cycle
 3640               	.LVL351:
 525:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3641               		.loc 3 525 0
 3642 0614 6AEA      		ldi r22,lo8(-86)
 3643 0616 87E2      		ldi r24,lo8(39)
 3644 0618 91E0      		ldi r25,lo8(1)
 3645 061a 00D0      		rcall gb_flash_write_bus_cycle
 3646               	.LVL352:
 526:main.c        **** 			_delay_us(5);
 3647               		.loc 3 526 0
 3648 061c 65EA      		ldi r22,lo8(-91)
 3649 061e 8FE3      		ldi r24,lo8(63)
 3650 0620 91E0      		ldi r25,lo8(1)
 3651 0622 00D0      		rcall gb_flash_write_bus_cycle
 3652               	.LVL353:
 3653               	.LBB212:
 3654               	.LBB213:
 3655               		.loc 2 276 0
 3656 0624 8DE0      		ldi r24,lo8(13)
 3657 0626 8A95      	1:	dec r24
 3658 0628 01F4      		brne 1b
 3659 062a 0000      		nop
 3660               	.LVL354:
 3661               	.LBE213:
 3662               	.LBE212:
 529:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 3663               		.loc 3 529 0
 3664 062c 6FE0      		ldi r22,lo8(15)
 3665 062e 80E2      		ldi r24,lo8(32)
 3666 0630 91E0      		ldi r25,lo8(1)
 3667 0632 00D0      		rcall gb_flash_write_bus_cycle
 3668               	.LVL355:
 530:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 3669               		.loc 3 530 0
 3670 0634 6AE2      		ldi r22,lo8(42)
 3671 0636 85E2      		ldi r24,lo8(37)
 3672 0638 91E0      		ldi r25,lo8(1)
 3673 063a 00D0      		rcall gb_flash_write_bus_cycle
 3674               	.LVL356:
 531:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 3675               		.loc 3 531 0
 3676 063c 6AEA      		ldi r22,lo8(-86)
 3677 063e 86E2      		ldi r24,lo8(38)
 3678 0640 91E0      		ldi r25,lo8(1)
 3679 0642 00D0      		rcall gb_flash_write_bus_cycle
 3680               	.LVL357:
 532:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3681               		.loc 3 532 0
 3682 0644 65E5      		ldi r22,lo8(85)
 3683 0646 87E2      		ldi r24,lo8(39)
 3684 0648 91E0      		ldi r25,lo8(1)
 3685 064a 00D0      		rcall gb_flash_write_bus_cycle
 3686               	.LVL358:
 533:main.c        **** 			_delay_us(5);
 3687               		.loc 3 533 0
 3688 064c 65EA      		ldi r22,lo8(-91)
 3689 064e 8FE3      		ldi r24,lo8(63)
 3690 0650 91E0      		ldi r25,lo8(1)
 3691 0652 00D0      		rcall gb_flash_write_bus_cycle
 3692               	.LVL359:
 3693               	.LBB214:
 3694               	.LBB215:
 3695               		.loc 2 276 0
 3696 0654 9DE0      		ldi r25,lo8(13)
 3697 0656 9A95      	1:	dec r25
 3698 0658 01F4      		brne 1b
 3699 065a 0000      		nop
 3700               	.LVL360:
 3701               	.LBE215:
 3702               	.LBE214:
 536:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3703               		.loc 3 536 0
 3704 065c 6FE0      		ldi r22,lo8(15)
 3705 065e 80E2      		ldi r24,lo8(32)
 3706 0660 91E0      		ldi r25,lo8(1)
 3707 0662 00D0      		rcall gb_flash_write_bus_cycle
 3708               	.LVL361:
 537:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3709               		.loc 3 537 0
 3710 0664 65E5      		ldi r22,lo8(85)
 3711 0666 85E2      		ldi r24,lo8(37)
 3712 0668 91E0      		ldi r25,lo8(1)
 3713 066a 00D0      		rcall gb_flash_write_bus_cycle
 3714               	.LVL362:
 538:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 3715               		.loc 3 538 0
 3716 066c 65E5      		ldi r22,lo8(85)
 3717 066e 86E2      		ldi r24,lo8(38)
 3718 0670 91E0      		ldi r25,lo8(1)
 3719 0672 00D0      		rcall gb_flash_write_bus_cycle
 3720               	.LVL363:
 539:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3721               		.loc 3 539 0
 3722 0674 60EA      		ldi r22,lo8(-96)
 3723 0676 87E2      		ldi r24,lo8(39)
 3724 0678 91E0      		ldi r25,lo8(1)
 3725 067a 00D0      		rcall gb_flash_write_bus_cycle
 3726               	.LVL364:
 540:main.c        **** 			_delay_us(5);
 3727               		.loc 3 540 0
 3728 067c 65EA      		ldi r22,lo8(-91)
 3729 067e 8FE3      		ldi r24,lo8(63)
 3730 0680 91E0      		ldi r25,lo8(1)
 3731 0682 00D0      		rcall gb_flash_write_bus_cycle
 3732               	.LVL365:
 3733               	.LBB216:
 3734               	.LBB217:
 3735               		.loc 2 276 0
 3736 0684 EDE0      		ldi r30,lo8(13)
 3737 0686 EA95      	1:	dec r30
 3738 0688 01F4      		brne 1b
 3739 068a 0000      		nop
 3740               	.LVL366:
 3741               	.LBE217:
 3742               	.LBE216:
 544:main.c        **** 			_delay_us(5);
 3743               		.loc 3 544 0
 3744 068c 40E0      		ldi r20,0
 3745 068e 6091 0000 		lds r22,lastBankAccessed
 3746 0692 80E0      		ldi r24,0
 3747 0694 91E2      		ldi r25,lo8(33)
 3748 0696 00D0      		rcall write_8bit_data
 3749               	.LVL367:
 3750               	.LBB218:
 3751               	.LBB219:
 3752               		.loc 2 276 0
 3753 0698 FDE0      		ldi r31,lo8(13)
 3754 069a FA95      	1:	dec r31
 3755 069c 01F4      		brne 1b
 3756 069e 0000      		nop
 3757               	.LVL368:
 3758               	.LBE219:
 3759               	.LBE218:
 548:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3760               		.loc 3 548 0
 3761 06a0 60E1      		ldi r22,lo8(16)
 3762 06a2 80E2      		ldi r24,lo8(32)
 3763 06a4 91E0      		ldi r25,lo8(1)
 3764 06a6 00D0      		rcall gb_flash_write_bus_cycle
 3765               	.LVL369:
 549:main.c        **** 			_delay_us(5);
 3766               		.loc 3 549 0
 3767 06a8 65EA      		ldi r22,lo8(-91)
 3768 06aa 8FE3      		ldi r24,lo8(63)
 3769 06ac 91E0      		ldi r25,lo8(1)
 3770 06ae 00D0      		rcall gb_flash_write_bus_cycle
 3771               	.LVL370:
 3772               	.LBB220:
 3773               	.LBB221:
 3774               		.loc 2 276 0
 3775 06b0 2DE0      		ldi r18,lo8(13)
 3776 06b2 2A95      	1:	dec r18
 3777 06b4 01F4      		brne 1b
 3778 06b6 0000      		nop
 3779               	.LVL371:
 3780               	.LBE221:
 3781               	.LBE220:
 553:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3782               		.loc 3 553 0
 3783 06b8 68E0      		ldi r22,lo8(8)
 3784 06ba 80E2      		ldi r24,lo8(32)
 3785 06bc 91E0      		ldi r25,lo8(1)
 3786 06be 00D0      		rcall gb_flash_write_bus_cycle
 3787               	.LVL372:
 554:main.c        **** 			_delay_us(5);
 3788               		.loc 3 554 0
 3789 06c0 65EA      		ldi r22,lo8(-91)
 3790 06c2 8FE3      		ldi r24,lo8(63)
 3791 06c4 91E0      		ldi r25,lo8(1)
 3792 06c6 00D0      		rcall gb_flash_write_bus_cycle
 3793               	.LVL373:
 3794               	.LBB222:
 3795               	.LBB223:
 3796               		.loc 2 276 0
 3797 06c8 8DE0      		ldi r24,lo8(13)
 3798 06ca 8A95      	1:	dec r24
 3799 06cc 01F4      		brne 1b
 3800 06ce 0000      		nop
 3801               	.LVL374:
 3802 06d0 00E0      		ldi r16,lo8(receivedBuffer)
 3803 06d2 10E0      		ldi r17,hi8(receivedBuffer)
 3804               	.L154:
 3805               	.LBE223:
 3806               	.LBE222:
 3807               	.LBB224:
 559:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3808               		.loc 3 559 0 discriminator 1
 3809 06d4 80E0      		ldi r24,hi8(receivedBuffer+128)
 3810 06d6 0030      		cpi r16,lo8(receivedBuffer+128)
 3811 06d8 1807      		cpc r17,r24
 3812 06da 01F0      		breq .L257
 560:main.c        **** 				_delay_us(5);
 3813               		.loc 3 560 0 discriminator 3
 3814 06dc F801      		movw r30,r16
 3815 06de 6191      		ld r22,Z+
 3816 06e0 8F01      		movw r16,r30
 3817 06e2 C601      		movw r24,r12
 3818 06e4 00D0      		rcall gb_flash_write_bus_cycle
 3819               	.LVL375:
 3820               	.LBB225:
 3821               	.LBB226:
 3822               		.loc 2 276 0 discriminator 3
 3823 06e6 FDE0      		ldi r31,lo8(13)
 3824 06e8 FA95      	1:	dec r31
 3825 06ea 01F4      		brne 1b
 3826 06ec 0000      		nop
 3827               	.LVL376:
 3828               	.LBE226:
 3829               	.LBE225:
 562:main.c        **** 			}
 3830               		.loc 3 562 0 discriminator 3
 3831 06ee 2FEF      		ldi r18,-1
 3832 06f0 C21A      		sub r12,r18
 3833 06f2 D20A      		sbc r13,r18
 3834 06f4 E20A      		sbc r14,r18
 3835 06f6 F20A      		sbc r15,r18
 3836               	.LVL377:
 3837 06f8 00C0      		rjmp .L154
 3838               	.L257:
 3839               	.LVL378:
 3840               	.LBE224:
 567:main.c        **** 			address++;
 3841               		.loc 3 567 0
 3842 06fa 6FEF      		ldi r22,lo8(-1)
 3843 06fc D701      		movw r26,r14
 3844 06fe C601      		movw r24,r12
 3845 0700 0197      		sbiw r24,1
 3846 0702 A109      		sbc r26,__zero_reg__
 3847 0704 B109      		sbc r27,__zero_reg__
 3848               	.LVL379:
 3849 0706 00D0      		rcall gb_flash_write_bus_cycle
 3850               	.LVL380:
 3851               	.LBB227:
 3852               	.LBB228:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3853               		.loc 2 187 0
 3854 0708 EFE1      		ldi r30,lo8(19999)
 3855 070a FEE4      		ldi r31,hi8(19999)
 3856 070c 3197      	1:	sbiw r30,1
 3857 070e 01F4      		brne 1b
 3858               	.LVL381:
 3859               	.L256:
 3860 0710 00C0      		rjmp .
 3861 0712 0000      		nop
 3862 0714 00C0      		rjmp .L244
 3863               	.LVL382:
 3864               	.L153:
 3865               	.LBE228:
 3866               	.LBE227:
 578:main.c        **** 			usart_read_chars(); // Read address
 3867               		.loc 3 578 0
 3868 0716 8E36      		cpi r24,lo8(110)
 3869 0718 01F4      		brne .L156
 3870               	.LBB229:
 579:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3871               		.loc 3 579 0
 3872 071a 00D0      		rcall usart_read_chars
 3873               	.LVL383:
 580:main.c        **** 			
 3874               		.loc 3 580 0
 3875 071c 40E1      		ldi r20,lo8(16)
 3876 071e 50E0      		ldi r21,0
 3877 0720 60E0      		ldi r22,0
 3878 0722 70E0      		ldi r23,0
 3879 0724 80E0      		ldi r24,lo8(receivedBuffer)
 3880 0726 90E0      		ldi r25,hi8(receivedBuffer)
 3881 0728 00D0      		rcall strtol
 3882               	.LVL384:
 3883 072a 4B01      		movw r8,r22
 3884 072c 5C01      		movw r10,r24
 3885               	.LVL385:
 582:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3886               		.loc 3 582 0
 3887 072e 00D0      		rcall USART_Receive
 3888               	.LVL386:
 3889 0730 8093 0000 		sts receivedChar,r24
 583:main.c        **** 				usart_read_chars(); // Read data
 3890               		.loc 3 583 0
 3891 0734 8E36      		cpi r24,lo8(110)
 3892 0736 01F0      		breq .+2
 3893 0738 00C0      		rjmp .L93
 3894               	.LBB230:
 584:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 3895               		.loc 3 584 0
 3896 073a 00D0      		rcall usart_read_chars
 3897               	.LVL387:
 585:main.c        **** 				
 3898               		.loc 3 585 0
 3899 073c 40E1      		ldi r20,lo8(16)
 3900 073e 50E0      		ldi r21,0
 3901 0740 60E0      		ldi r22,0
 3902 0742 70E0      		ldi r23,0
 3903 0744 80E0      		ldi r24,lo8(receivedBuffer)
 3904 0746 90E0      		ldi r25,hi8(receivedBuffer)
 3905 0748 00D0      		rcall strtol
 3906               	.LVL388:
 587:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3907               		.loc 3 587 0
 3908 074a 939A      		sbi 0x12,3
 588:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3909               		.loc 3 588 0
 3910 074c C4BB      		out 0x14,r28
 589:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3911               		.loc 3 589 0
 3912 074e CABB      		out 0x1a,r28
 590:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 3913               		.loc 3 590 0
 3914 0750 C7BB      		out 0x17,r28
 591:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3915               		.loc 3 591 0
 3916 0752 AB01      		movw r20,r22
 3917 0754 C501      		movw r24,r10
 3918 0756 B401      		movw r22,r8
 3919               	.LVL389:
 3920 0758 00D0      		rcall gba_flash_write_bus_cycle
 3921               	.LVL390:
 3922               	.L255:
 592:main.c        **** 				
 3923               		.loc 3 592 0
 3924 075a 9398      		cbi 0x12,3
 594:main.c        **** 			}
 3925               		.loc 3 594 0
 3926 075c 81E3      		ldi r24,lo8(49)
 3927 075e 00C0      		rjmp .L236
 3928               	.LVL391:
 3929               	.L156:
 3930               	.LBE230:
 3931               	.LBE229:
 599:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3932               		.loc 3 599 0
 3933 0760 8137      		cpi r24,lo8(113)
 3934 0762 01F0      		breq .L157
 599:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3935               		.loc 3 599 0 is_stmt 0 discriminator 1
 3936 0764 8437      		cpi r24,lo8(116)
 3937 0766 01F4      		brne .L158
 3938               	.L157:
 3939               	.LBB231:
 600:main.c        **** 			
 3940               		.loc 3 600 0 is_stmt 1
 3941 0768 939A      		sbi 0x12,3
 3942               	.LVL392:
 603:main.c        **** 				readLength = 256;
 3943               		.loc 3 603 0
 3944 076a 8091 0000 		lds r24,receivedChar
 3945 076e 8437      		cpi r24,lo8(116)
 3946 0770 01F4      		brne .L207
 604:main.c        **** 			}
 3947               		.loc 3 604 0
 3948 0772 00E0      		ldi r16,0
 3949 0774 11E0      		ldi r17,lo8(1)
 3950 0776 00C0      		rjmp .L159
 3951               	.L207:
 602:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 3952               		.loc 3 602 0
 3953 0778 00E4      		ldi r16,lo8(64)
 3954 077a 10E0      		ldi r17,0
 3955               	.L159:
 3956               	.LVL393:
 606:main.c        **** 			
 3957               		.loc 3 606 0
 3958 077c C801      		movw r24,r16
 3959 077e 00D0      		rcall usart_read_bytes
 3960               	.LVL394:
 3961 0780 70E0      		ldi r23,lo8(receivedBuffer)
 3962 0782 A72E      		mov r10,r23
 3963 0784 70E0      		ldi r23,hi8(receivedBuffer)
 3964 0786 B72E      		mov r11,r23
 3965 0788 2601      		movw r4,r12
 3966 078a 3701      		movw r6,r14
 3967               	.LVL395:
 3968               	.L160:
 3969               	.LBB232:
 3970               	.LBB233:
 610:main.c        **** 				address++;
 3971               		.loc 3 610 0 discriminator 3
 3972 078c F501      		movw r30,r10
 3973 078e 4181      		ldd r20,Z+1
 3974 0790 50E0      		ldi r21,0
 3975 0792 542F      		mov r21,r20
 3976 0794 4427      		clr r20
 3977 0796 8081      		ld r24,Z
 3978 0798 482B      		or r20,r24
 3979 079a 21E0      		ldi r18,lo8(1)
 3980 079c C301      		movw r24,r6
 3981 079e B201      		movw r22,r4
 3982 07a0 00D0      		rcall gba_flash_write_byte
 3983               	.LVL396:
 611:main.c        **** 			}
 3984               		.loc 3 611 0 discriminator 3
 3985 07a2 FFEF      		ldi r31,-1
 3986 07a4 4F1A      		sub r4,r31
 3987 07a6 5F0A      		sbc r5,r31
 3988 07a8 6F0A      		sbc r6,r31
 3989 07aa 7F0A      		sbc r7,r31
 3990               	.LVL397:
 3991 07ac 22E0      		ldi r18,2
 3992 07ae A20E      		add r10,r18
 3993 07b0 B11C      		adc r11,__zero_reg__
 3994               	.LVL398:
 3995               	.LBE233:
 608:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 3996               		.loc 3 608 0 discriminator 3
 3997 07b2 C501      		movw r24,r10
 3998 07b4 8050      		subi r24,lo8(receivedBuffer)
 3999 07b6 9040      		sbci r25,hi8(receivedBuffer)
 4000 07b8 8017      		cp r24,r16
 4001 07ba 9107      		cpc r25,r17
 4002 07bc 04F0      		brlt .L160
 4003 07be 8FEF      		ldi r24,-1
 4004 07c0 C81A      		sub r12,r24
 4005 07c2 D80A      		sbc r13,r24
 4006 07c4 E80A      		sbc r14,r24
 4007 07c6 F80A      		sbc r15,r24
 4008 07c8 0150      		subi r16,1
 4009 07ca 1109      		sbc r17,__zero_reg__
 4010               	.LVL399:
 4011 07cc 1695      		lsr r17
 4012 07ce 0795      		ror r16
 4013               	.LVL400:
 4014 07d0 C00E      		add r12,r16
 4015 07d2 D11E      		adc r13,r17
 4016 07d4 E11C      		adc r14,__zero_reg__
 4017 07d6 F11C      		adc r15,__zero_reg__
 4018 07d8 00C0      		rjmp .L244
 4019               	.LVL401:
 4020               	.L158:
 4021               	.LBE232:
 4022               	.LBE231:
 619:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4023               		.loc 3 619 0
 4024 07da 8636      		cpi r24,lo8(102)
 4025 07dc 01F4      		brne .L161
 4026               	.LBB234:
 620:main.c        **** 			
 4027               		.loc 3 620 0
 4028 07de 939A      		sbi 0x12,3
 4029               	.LVL402:
 623:main.c        **** 			
 4030               		.loc 3 623 0
 4031 07e0 80E0      		ldi r24,0
 4032 07e2 91E0      		ldi r25,lo8(1)
 4033 07e4 00D0      		rcall usart_read_bytes
 4034               	.LVL403:
 4035 07e6 00E0      		ldi r16,lo8(receivedBuffer)
 4036 07e8 10E0      		ldi r17,hi8(receivedBuffer)
 4037 07ea 4601      		movw r8,r12
 4038 07ec 5701      		movw r10,r14
 4039               	.LVL404:
 4040               	.L162:
 4041               	.LBB235:
 4042               	.LBB236:
 627:main.c        **** 				address++;
 4043               		.loc 3 627 0 discriminator 3
 4044 07ee F801      		movw r30,r16
 4045 07f0 4181      		ldd r20,Z+1
 4046 07f2 50E0      		ldi r21,0
 4047 07f4 542F      		mov r21,r20
 4048 07f6 4427      		clr r20
 4049 07f8 8081      		ld r24,Z
 4050 07fa 482B      		or r20,r24
 4051 07fc 20E0      		ldi r18,0
 4052 07fe C501      		movw r24,r10
 4053 0800 B401      		movw r22,r8
 4054 0802 00D0      		rcall gba_flash_write_byte
 4055               	.LVL405:
 628:main.c        **** 			}
 4056               		.loc 3 628 0 discriminator 3
 4057 0804 FFEF      		ldi r31,-1
 4058 0806 8F1A      		sub r8,r31
 4059 0808 9F0A      		sbc r9,r31
 4060 080a AF0A      		sbc r10,r31
 4061 080c BF0A      		sbc r11,r31
 4062               	.LVL406:
 4063 080e 0E5F      		subi r16,-2
 4064 0810 1F4F      		sbci r17,-1
 4065               	.LVL407:
 4066               	.LBE236:
 625:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4067               		.loc 3 625 0 discriminator 3
 4068 0812 20E0      		ldi r18,hi8(receivedBuffer+256)
 4069 0814 0030      		cpi r16,lo8(receivedBuffer+256)
 4070 0816 1207      		cpc r17,r18
 4071 0818 01F4      		brne .L162
 4072 081a 80E8      		ldi r24,-128
 4073 081c C80E      		add r12,r24
 4074 081e D11C      		adc r13,__zero_reg__
 4075 0820 E11C      		adc r14,__zero_reg__
 4076 0822 F11C      		adc r15,__zero_reg__
 4077 0824 00C0      		rjmp .L244
 4078               	.LVL408:
 4079               	.L161:
 4080               	.LBE235:
 4081               	.LBE234:
 637:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4082               		.loc 3 637 0
 4083 0826 8C36      		cpi r24,lo8(108)
 4084 0828 01F0      		breq .+2
 4085 082a 00C0      		rjmp .L163
 4086               	.LBB237:
 638:main.c        **** 			usart_read_bytes(64);
 4087               		.loc 3 638 0
 4088 082c 939A      		sbi 0x12,3
 639:main.c        **** 			
 4089               		.loc 3 639 0
 4090 082e 80E4      		ldi r24,lo8(64)
 4091 0830 90E0      		ldi r25,0
 4092 0832 00D0      		rcall usart_read_bytes
 4093               	.LVL409:
 642:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4094               		.loc 3 642 0
 4095 0834 C4BB      		out 0x14,r28
 643:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4096               		.loc 3 643 0
 4097 0836 CABB      		out 0x1a,r28
 644:main.c        **** 			
 4098               		.loc 3 644 0
 4099 0838 C7BB      		out 0x17,r28
 647:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4100               		.loc 3 647 0
 4101 083a 40E6      		ldi r20,lo8(96)
 4102 083c 50E0      		ldi r21,0
 4103 083e C701      		movw r24,r14
 4104 0840 B601      		movw r22,r12
 4105 0842 00D0      		rcall gba_flash_write_bus_cycle
 4106               	.LVL410:
 648:main.c        **** 			
 4107               		.loc 3 648 0
 4108 0844 40ED      		ldi r20,lo8(-48)
 4109 0846 50E0      		ldi r21,0
 4110 0848 C701      		movw r24,r14
 4111 084a B601      		movw r22,r12
 4112 084c 00D0      		rcall gba_flash_write_bus_cycle
 4113               	.LVL411:
 651:main.c        **** 			_delay_us(50);
 4114               		.loc 3 651 0
 4115 084e 48EE      		ldi r20,lo8(-24)
 4116 0850 50E0      		ldi r21,0
 4117 0852 C701      		movw r24,r14
 4118 0854 B601      		movw r22,r12
 4119 0856 00D0      		rcall gba_flash_write_bus_cycle
 4120               	.LVL412:
 4121               	.LBB238:
 4122               	.LBB239:
 4123               		.loc 2 276 0
 4124 0858 95E8      		ldi r25,lo8(-123)
 4125 085a 9A95      	1:	dec r25
 4126 085c 01F4      		brne 1b
 4127 085e 0000      		nop
 4128               	.LVL413:
 4129               	.LBE239:
 4130               	.LBE238:
 655:main.c        **** 			while (dataVerify != 0x0080) {
 4131               		.loc 3 655 0
 4132 0860 C701      		movw r24,r14
 4133 0862 B601      		movw r22,r12
 4134 0864 00D0      		rcall gba_read_16bit_data
 4135               	.LVL414:
 4136               	.L164:
 656:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4137               		.loc 3 656 0
 4138 0866 8038      		cpi r24,-128
 4139 0868 9105      		cpc r25,__zero_reg__
 4140 086a 01F0      		breq .L258
 657:main.c        **** 				_delay_us(50);
 4141               		.loc 3 657 0
 4142 086c C701      		movw r24,r14
 4143 086e B601      		movw r22,r12
 4144 0870 00D0      		rcall gba_read_16bit_data
 4145               	.LVL415:
 4146               	.LBB240:
 4147               	.LBB241:
 4148               		.loc 2 276 0
 4149 0872 E5E8      		ldi r30,lo8(-123)
 4150 0874 EA95      	1:	dec r30
 4151 0876 01F4      		brne 1b
 4152 0878 0000      		nop
 4153 087a 00C0      		rjmp .L164
 4154               	.LVL416:
 4155               	.L258:
 4156               	.LBE241:
 4157               	.LBE240:
 663:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4158               		.loc 3 663 0
 4159 087c C4BB      		out 0x14,r28
 664:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4160               		.loc 3 664 0
 4161 087e CABB      		out 0x1a,r28
 665:main.c        **** 			
 4162               		.loc 3 665 0
 4163 0880 C7BB      		out 0x17,r28
 668:main.c        **** 			
 4164               		.loc 3 668 0
 4165 0882 4FE1      		ldi r20,lo8(31)
 4166 0884 50E0      		ldi r21,0
 4167 0886 C701      		movw r24,r14
 4168 0888 B601      		movw r22,r12
 4169 088a 00D0      		rcall gba_flash_write_bus_cycle
 4170               	.LVL417:
 4171 088c 00E0      		ldi r16,lo8(receivedBuffer)
 4172 088e 10E0      		ldi r17,hi8(receivedBuffer)
 4173 0890 4601      		movw r8,r12
 4174 0892 5701      		movw r10,r14
 4175               	.LVL418:
 4176               	.L166:
 4177               	.LBB242:
 4178               	.LBB243:
 673:main.c        **** 				address++;
 4179               		.loc 3 673 0 discriminator 3
 4180 0894 F801      		movw r30,r16
 4181 0896 4181      		ldd r20,Z+1
 4182 0898 50E0      		ldi r21,0
 4183 089a 542F      		mov r21,r20
 4184 089c 4427      		clr r20
 4185 089e 8081      		ld r24,Z
 4186 08a0 482B      		or r20,r24
 4187 08a2 C501      		movw r24,r10
 4188 08a4 B401      		movw r22,r8
 4189 08a6 00D0      		rcall gba_flash_write_bus_cycle
 4190               	.LVL419:
 674:main.c        **** 			}
 4191               		.loc 3 674 0 discriminator 3
 4192 08a8 FFEF      		ldi r31,-1
 4193 08aa 8F1A      		sub r8,r31
 4194 08ac 9F0A      		sbc r9,r31
 4195 08ae AF0A      		sbc r10,r31
 4196 08b0 BF0A      		sbc r11,r31
 4197               	.LVL420:
 4198 08b2 0E5F      		subi r16,-2
 4199 08b4 1F4F      		sbci r17,-1
 4200               	.LVL421:
 4201               	.LBE243:
 671:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4202               		.loc 3 671 0 discriminator 3
 4203 08b6 80E0      		ldi r24,lo8(receivedBuffer+64)
 4204 08b8 90E0      		ldi r25,hi8(receivedBuffer+64)
 4205 08ba 8017      		cp r24,r16
 4206 08bc 9107      		cpc r25,r17
 4207 08be 01F4      		brne .L166
 4208 08c0 90E2      		ldi r25,32
 4209 08c2 C90E      		add r12,r25
 4210 08c4 D11C      		adc r13,__zero_reg__
 4211 08c6 E11C      		adc r14,__zero_reg__
 4212 08c8 F11C      		adc r15,__zero_reg__
 4213               	.LBE242:
 678:main.c        **** 			_delay_us(440);
 4214               		.loc 3 678 0
 4215 08ca 40ED      		ldi r20,lo8(-48)
 4216 08cc 50E0      		ldi r21,0
 4217 08ce C701      		movw r24,r14
 4218 08d0 B601      		movw r22,r12
 4219 08d2 00D0      		rcall gba_flash_write_bus_cycle
 4220               	.LVL422:
 4221               	.LBB244:
 4222               	.LBB245:
 4223               		.loc 2 276 0
 4224 08d4 EFE6      		ldi r30,lo8(879)
 4225 08d6 F3E0      		ldi r31,hi8(879)
 4226 08d8 3197      	1:	sbiw r30,1
 4227 08da 01F4      		brne 1b
 4228 08dc 00C0      		rjmp .
 4229 08de 0000      		nop
 4230               	.LVL423:
 4231               	.LBE245:
 4232               	.LBE244:
 682:main.c        **** 			while (dataVerify != 0x0080) {
 4233               		.loc 3 682 0
 4234 08e0 C701      		movw r24,r14
 4235 08e2 B601      		movw r22,r12
 4236 08e4 00D0      		rcall gba_read_16bit_data
 4237               	.LVL424:
 4238               	.L167:
 683:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4239               		.loc 3 683 0
 4240 08e6 8038      		cpi r24,-128
 4241 08e8 9105      		cpc r25,__zero_reg__
 4242 08ea 01F0      		breq .L259
 684:main.c        **** 				_delay_us(50);
 4243               		.loc 3 684 0
 4244 08ec C701      		movw r24,r14
 4245 08ee B601      		movw r22,r12
 4246 08f0 00D0      		rcall gba_read_16bit_data
 4247               	.LVL425:
 4248               	.LBB246:
 4249               	.LBB247:
 4250               		.loc 2 276 0
 4251 08f2 F5E8      		ldi r31,lo8(-123)
 4252 08f4 FA95      	1:	dec r31
 4253 08f6 01F4      		brne 1b
 4254 08f8 0000      		nop
 4255 08fa 00C0      		rjmp .L167
 4256               	.LVL426:
 4257               	.L259:
 4258               	.LBE247:
 4259               	.LBE246:
 690:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4260               		.loc 3 690 0
 4261 08fc C4BB      		out 0x14,r28
 691:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4262               		.loc 3 691 0
 4263 08fe CABB      		out 0x1a,r28
 692:main.c        **** 			
 4264               		.loc 3 692 0
 4265 0900 C7BB      		out 0x17,r28
 695:main.c        **** 			
 4266               		.loc 3 695 0
 4267 0902 4FEF      		ldi r20,lo8(-1)
 4268 0904 50E0      		ldi r21,0
 4269 0906 C701      		movw r24,r14
 4270 0908 B601      		movw r22,r12
 4271 090a 00D0      		rcall gba_flash_write_bus_cycle
 4272               	.LVL427:
 4273 090c 00C0      		rjmp .L244
 4274               	.LVL428:
 4275               	.L163:
 4276               	.LBE237:
 702:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4277               		.loc 3 702 0
 4278 090e 8537      		cpi r24,lo8(117)
 4279 0910 01F4      		brne .L169
 703:main.c        **** 			usart_read_bytes(64);
 4280               		.loc 3 703 0
 4281 0912 939A      		sbi 0x12,3
 704:main.c        **** 			
 4282               		.loc 3 704 0
 4283 0914 80E4      		ldi r24,lo8(64)
 4284 0916 90E0      		ldi r25,0
 4285 0918 00D0      		rcall usart_read_bytes
 4286               	.LVL429:
 4287 091a 90E0      		ldi r25,lo8(receivedBuffer)
 4288 091c A92E      		mov r10,r25
 4289 091e 90E0      		ldi r25,hi8(receivedBuffer)
 4290 0920 B92E      		mov r11,r25
 4291 0922 2601      		movw r4,r12
 4292 0924 3701      		movw r6,r14
 4293               	.LVL430:
 4294               	.L172:
 4295               	.LBB248:
 4296               	.LBB171:
 4297               		.loc 3 709 0
 4298 0926 C4BB      		out 0x14,r28
 710:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4299               		.loc 3 710 0
 4300 0928 CABB      		out 0x1a,r28
 711:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4301               		.loc 3 711 0
 4302 092a C7BB      		out 0x17,r28
 712:main.c        **** 				
 713:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4303               		.loc 3 713 0
 4304 092c F501      		movw r30,r10
 4305 092e 0181      		ldd r16,Z+1
 4306 0930 10E0      		ldi r17,0
 4307 0932 102F      		mov r17,r16
 4308 0934 0027      		clr r16
 4309 0936 8081      		ld r24,Z
 4310 0938 082B      		or r16,r24
 4311               	.LVL431:
 714:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 4312               		.loc 3 714 0
 4313 093a 40E4      		ldi r20,lo8(64)
 4314 093c 50E0      		ldi r21,0
 4315 093e C301      		movw r24,r6
 4316 0940 B201      		movw r22,r4
 4317 0942 00D0      		rcall gba_flash_write_bus_cycle
 4318               	.LVL432:
 715:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4319               		.loc 3 715 0
 4320 0944 A801      		movw r20,r16
 4321 0946 C301      		movw r24,r6
 4322 0948 B201      		movw r22,r4
 4323 094a 00D0      		rcall gba_flash_write_bus_cycle
 4324               	.LVL433:
 716:main.c        **** 				
 717:main.c        **** 				// Verify status ok
 718:main.c        **** 				uint16_t status = gba_read_16bit_data(address);
 4325               		.loc 3 718 0
 4326 094c C301      		movw r24,r6
 4327 094e B201      		movw r22,r4
 4328 0950 00D0      		rcall gba_read_16bit_data
 4329               	.LVL434:
 4330               	.L170:
 719:main.c        **** 				while ((status & 0x80) == 0) {
 4331               		.loc 3 719 0
 4332 0952 87FD      		sbrc r24,7
 4333 0954 00C0      		rjmp .L260
 720:main.c        **** 					status = gba_read_16bit_data(address);
 4334               		.loc 3 720 0
 4335 0956 C301      		movw r24,r6
 4336 0958 B201      		movw r22,r4
 4337 095a 00D0      		rcall gba_read_16bit_data
 4338               	.LVL435:
 4339               	.LBB169:
 4340               	.LBB170:
 4341               		.loc 2 276 0
 4342 095c F5E0      		ldi r31,lo8(5)
 4343 095e FA95      	1:	dec r31
 4344 0960 01F4      		brne 1b
 4345 0962 0000      		nop
 4346 0964 00C0      		rjmp .L170
 4347               	.LVL436:
 4348               	.L260:
 4349               	.LBE170:
 4350               	.LBE169:
 721:main.c        **** 					_delay_us(2);
 722:main.c        **** 				}
 723:main.c        **** 				address++;
 4351               		.loc 3 723 0 discriminator 2
 4352 0966 2FEF      		ldi r18,-1
 4353 0968 421A      		sub r4,r18
 4354 096a 520A      		sbc r5,r18
 4355 096c 620A      		sbc r6,r18
 4356 096e 720A      		sbc r7,r18
 4357               	.LVL437:
 4358 0970 82E0      		ldi r24,2
 4359 0972 A80E      		add r10,r24
 4360 0974 B11C      		adc r11,__zero_reg__
 4361               	.LVL438:
 4362               	.LBE171:
 707:main.c        **** 				// Set address lines as outputs
 4363               		.loc 3 707 0 discriminator 2
 4364 0976 90E0      		ldi r25,lo8(receivedBuffer+64)
 4365 0978 A916      		cp r10,r25
 4366 097a 90E0      		ldi r25,hi8(receivedBuffer+64)
 4367 097c B906      		cpc r11,r25
 4368 097e 01F4      		brne .L172
 4369 0980 E0E2      		ldi r30,32
 4370 0982 CE0E      		add r12,r30
 4371 0984 D11C      		adc r13,__zero_reg__
 4372 0986 E11C      		adc r14,__zero_reg__
 4373 0988 F11C      		adc r15,__zero_reg__
 4374               	.LVL439:
 4375               	.L244:
 4376               	.LBE248:
 724:main.c        **** 			}
 725:main.c        **** 			
 726:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 4377               		.loc 3 726 0
 4378 098a 81E3      		ldi r24,lo8(49)
 4379 098c 00C0      		rjmp .L239
 4380               	.LVL440:
 4381               	.L169:
 727:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 728:main.c        **** 		}
 729:main.c        **** 		
 730:main.c        **** 		
 731:main.c        **** 		// ---------- General commands ----------
 732:main.c        **** 		// Set any pin as input/output
 733:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 734:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 4382               		.loc 3 734 0
 4383 098e 8934      		cpi r24,lo8(73)
 4384 0990 01F0      		breq .L173
 4385               		.loc 3 734 0 is_stmt 0 discriminator 1
 4386 0992 8F34      		cpi r24,lo8(79)
 4387 0994 01F0      		breq .+2
 4388 0996 00C0      		rjmp .L174
 4389               	.L173:
 4390               	.LBB249:
 735:main.c        **** 			char portChar = USART_Receive();
 4391               		.loc 3 735 0 is_stmt 1
 4392 0998 00D0      		rcall USART_Receive
 4393               	.LVL441:
 4394 099a 182F      		mov r17,r24
 4395               	.LVL442:
 736:main.c        **** 			usart_read_chars();
 4396               		.loc 3 736 0
 4397 099c 00D0      		rcall usart_read_chars
 4398               	.LVL443:
 737:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4399               		.loc 3 737 0
 4400 099e 40E1      		ldi r20,lo8(16)
 4401 09a0 50E0      		ldi r21,0
 4402 09a2 60E0      		ldi r22,0
 4403 09a4 70E0      		ldi r23,0
 4404 09a6 80E0      		ldi r24,lo8(receivedBuffer)
 4405 09a8 90E0      		ldi r25,hi8(receivedBuffer)
 4406 09aa 00D0      		rcall strtol
 4407               	.LVL444:
 738:main.c        **** 			
 739:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4408               		.loc 3 739 0
 4409 09ac 939A      		sbi 0x12,3
 740:main.c        **** 			if (receivedChar == SET_INPUT) {
 4410               		.loc 3 740 0
 4411 09ae 8091 0000 		lds r24,receivedChar
 4412 09b2 8934      		cpi r24,lo8(73)
 4413 09b4 01F4      		brne .L175
 741:main.c        **** 				if (portChar == 'A') {
 4414               		.loc 3 741 0
 4415 09b6 1134      		cpi r17,lo8(65)
 4416 09b8 01F4      		brne .L176
 742:main.c        **** 					DDRA &= ~(setValue);
 4417               		.loc 3 742 0
 4418 09ba 8AB3      		in r24,0x1a
 4419 09bc 6095      		com r22
 4420               	.LVL445:
 4421 09be 6823      		and r22,r24
 4422               	.LVL446:
 4423 09c0 00C0      		rjmp .L246
 4424               	.LVL447:
 4425               	.L176:
 743:main.c        **** 				}
 744:main.c        **** 				else if (portChar == 'B') {
 4426               		.loc 3 744 0
 4427 09c2 1234      		cpi r17,lo8(66)
 4428 09c4 01F4      		brne .L178
 745:main.c        **** 					DDRB &= ~(setValue);
 4429               		.loc 3 745 0
 4430 09c6 87B3      		in r24,0x17
 4431 09c8 6095      		com r22
 4432               	.LVL448:
 4433 09ca 6823      		and r22,r24
 4434               	.LVL449:
 4435 09cc 00C0      		rjmp .L247
 4436               	.LVL450:
 4437               	.L178:
 746:main.c        **** 				}
 747:main.c        **** 				else if (portChar == 'C') {
 4438               		.loc 3 747 0
 4439 09ce 1334      		cpi r17,lo8(67)
 4440 09d0 01F4      		brne .L179
 748:main.c        **** 					DDRC &= ~(setValue);
 4441               		.loc 3 748 0
 4442 09d2 84B3      		in r24,0x14
 4443 09d4 6095      		com r22
 4444               	.LVL451:
 4445 09d6 6823      		and r22,r24
 4446               	.LVL452:
 4447 09d8 00C0      		rjmp .L252
 4448               	.LVL453:
 4449               	.L179:
 749:main.c        **** 				}
 750:main.c        **** 				else if (portChar == 'D') {
 4450               		.loc 3 750 0
 4451 09da 1434      		cpi r17,lo8(68)
 4452 09dc 01F4      		brne .L180
 751:main.c        **** 					DDRD &= ~(setValue);
 4453               		.loc 3 751 0
 4454 09de 81B3      		in r24,0x11
 4455 09e0 6095      		com r22
 4456               	.LVL454:
 4457 09e2 6823      		and r22,r24
 4458               	.LVL455:
 4459 09e4 00C0      		rjmp .L253
 4460               	.LVL456:
 4461               	.L180:
 752:main.c        **** 				}
 753:main.c        **** 				else if (portChar == 'E') {
 4462               		.loc 3 753 0
 4463 09e6 1534      		cpi r17,lo8(69)
 4464 09e8 01F0      		breq .+2
 4465 09ea 00C0      		rjmp .L199
 754:main.c        **** 					DDRE &= ~(setValue);
 4466               		.loc 3 754 0
 4467 09ec 86B1      		in r24,0x6
 4468 09ee 6095      		com r22
 4469               	.LVL457:
 4470 09f0 6823      		and r22,r24
 4471               	.LVL458:
 4472 09f2 00C0      		rjmp .L254
 4473               	.LVL459:
 4474               	.L175:
 755:main.c        **** 				}
 756:main.c        **** 			}
 757:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 4475               		.loc 3 757 0
 4476 09f4 8F34      		cpi r24,lo8(79)
 4477 09f6 01F0      		breq .+2
 4478 09f8 00C0      		rjmp .L199
 758:main.c        **** 				if (portChar == 'A') {
 4479               		.loc 3 758 0
 4480 09fa 1134      		cpi r17,lo8(65)
 4481 09fc 01F4      		brne .L181
 759:main.c        **** 					DDRA |= (setValue);
 4482               		.loc 3 759 0
 4483 09fe 8AB3      		in r24,0x1a
 4484 0a00 682B      		or r22,r24
 4485               	.LVL460:
 4486               	.L246:
 4487 0a02 6ABB      		out 0x1a,r22
 4488 0a04 00C0      		rjmp .L199
 4489               	.LVL461:
 4490               	.L181:
 760:main.c        **** 				}
 761:main.c        **** 				else if (portChar == 'B') {
 4491               		.loc 3 761 0
 4492 0a06 1234      		cpi r17,lo8(66)
 4493 0a08 01F4      		brne .L182
 762:main.c        **** 					DDRB |= (setValue);
 4494               		.loc 3 762 0
 4495 0a0a 87B3      		in r24,0x17
 4496 0a0c 682B      		or r22,r24
 4497               	.LVL462:
 4498               	.L247:
 4499 0a0e 67BB      		out 0x17,r22
 4500 0a10 00C0      		rjmp .L199
 4501               	.LVL463:
 4502               	.L182:
 763:main.c        **** 				}
 764:main.c        **** 				else if (portChar == 'C') {
 4503               		.loc 3 764 0
 4504 0a12 1334      		cpi r17,lo8(67)
 4505 0a14 01F4      		brne .L183
 765:main.c        **** 					DDRC |= (setValue);
 4506               		.loc 3 765 0
 4507 0a16 84B3      		in r24,0x14
 4508 0a18 682B      		or r22,r24
 4509               	.LVL464:
 4510               	.L252:
 4511 0a1a 64BB      		out 0x14,r22
 4512 0a1c 00C0      		rjmp .L199
 4513               	.LVL465:
 4514               	.L183:
 766:main.c        **** 				}
 767:main.c        **** 				else if (portChar == 'D') {
 4515               		.loc 3 767 0
 4516 0a1e 1434      		cpi r17,lo8(68)
 4517 0a20 01F4      		brne .L184
 768:main.c        **** 					DDRD |= (setValue);
 4518               		.loc 3 768 0
 4519 0a22 81B3      		in r24,0x11
 4520 0a24 682B      		or r22,r24
 4521               	.LVL466:
 4522               	.L253:
 4523 0a26 61BB      		out 0x11,r22
 4524 0a28 00C0      		rjmp .L199
 4525               	.LVL467:
 4526               	.L184:
 769:main.c        **** 				}
 770:main.c        **** 				else if (portChar == 'E') {
 4527               		.loc 3 770 0
 4528 0a2a 1534      		cpi r17,lo8(69)
 4529 0a2c 01F0      		breq .+2
 4530 0a2e 00C0      		rjmp .L199
 771:main.c        **** 					DDRE |= (setValue);
 4531               		.loc 3 771 0
 4532 0a30 86B1      		in r24,0x6
 4533 0a32 682B      		or r22,r24
 4534               	.LVL468:
 4535               	.L254:
 4536 0a34 66B9      		out 0x6,r22
 4537 0a36 00C0      		rjmp .L199
 4538               	.LVL469:
 4539               	.L174:
 4540               	.LBE249:
 772:main.c        **** 				}
 773:main.c        **** 			}
 774:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 775:main.c        **** 		}
 776:main.c        **** 		
 777:main.c        **** 		// Set pin output as low
 778:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 4541               		.loc 3 778 0
 4542 0a38 8C34      		cpi r24,lo8(76)
 4543 0a3a 01F4      		brne .L185
 4544               	.LBB250:
 779:main.c        **** 			char portChar = USART_Receive();			
 4545               		.loc 3 779 0
 4546 0a3c 00D0      		rcall USART_Receive
 4547               	.LVL470:
 4548 0a3e 182F      		mov r17,r24
 4549               	.LVL471:
 780:main.c        **** 			usart_read_chars();
 4550               		.loc 3 780 0
 4551 0a40 00D0      		rcall usart_read_chars
 4552               	.LVL472:
 781:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4553               		.loc 3 781 0
 4554 0a42 40E1      		ldi r20,lo8(16)
 4555 0a44 50E0      		ldi r21,0
 4556 0a46 60E0      		ldi r22,0
 4557 0a48 70E0      		ldi r23,0
 4558 0a4a 80E0      		ldi r24,lo8(receivedBuffer)
 4559 0a4c 90E0      		ldi r25,hi8(receivedBuffer)
 4560 0a4e 00D0      		rcall strtol
 4561               	.LVL473:
 782:main.c        **** 			
 783:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4562               		.loc 3 783 0
 4563 0a50 939A      		sbi 0x12,3
 784:main.c        **** 			if (portChar == 'A') {
 4564               		.loc 3 784 0
 4565 0a52 1134      		cpi r17,lo8(65)
 4566 0a54 01F4      		brne .L186
 785:main.c        **** 				PORTA &= ~(setValue);
 4567               		.loc 3 785 0
 4568 0a56 8BB3      		in r24,0x1b
 4569 0a58 6095      		com r22
 4570               	.LVL474:
 4571 0a5a 6823      		and r22,r24
 4572               	.LVL475:
 4573 0a5c 00C0      		rjmp .L251
 4574               	.LVL476:
 4575               	.L186:
 786:main.c        **** 			}
 787:main.c        **** 			else if (portChar == 'B') {
 4576               		.loc 3 787 0
 4577 0a5e 1234      		cpi r17,lo8(66)
 4578 0a60 01F4      		brne .L188
 788:main.c        **** 				PORTB &= ~(setValue);
 4579               		.loc 3 788 0
 4580 0a62 88B3      		in r24,0x18
 4581 0a64 6095      		com r22
 4582               	.LVL477:
 4583 0a66 6823      		and r22,r24
 4584               	.LVL478:
 4585 0a68 00C0      		rjmp .L250
 4586               	.LVL479:
 4587               	.L188:
 789:main.c        **** 			}
 790:main.c        **** 			else if (portChar == 'C') {
 4588               		.loc 3 790 0
 4589 0a6a 1334      		cpi r17,lo8(67)
 4590 0a6c 01F4      		brne .L189
 791:main.c        **** 				PORTC &= ~(setValue);
 4591               		.loc 3 791 0
 4592 0a6e 85B3      		in r24,0x15
 4593 0a70 6095      		com r22
 4594               	.LVL480:
 4595 0a72 6823      		and r22,r24
 4596               	.LVL481:
 4597 0a74 00C0      		rjmp .L249
 4598               	.LVL482:
 4599               	.L189:
 792:main.c        **** 			}
 793:main.c        **** 			else if (portChar == 'D') {
 4600               		.loc 3 793 0
 4601 0a76 1434      		cpi r17,lo8(68)
 4602 0a78 01F4      		brne .L190
 794:main.c        **** 				PORTD &= ~(setValue);
 4603               		.loc 3 794 0
 4604 0a7a 82B3      		in r24,0x12
 4605 0a7c 6095      		com r22
 4606               	.LVL483:
 4607 0a7e 6823      		and r22,r24
 4608               	.LVL484:
 4609 0a80 00C0      		rjmp .L248
 4610               	.LVL485:
 4611               	.L190:
 795:main.c        **** 			}
 796:main.c        **** 			else if (portChar == 'E') {
 4612               		.loc 3 796 0
 4613 0a82 1534      		cpi r17,lo8(69)
 4614 0a84 01F0      		breq .+2
 4615 0a86 00C0      		rjmp .L199
 797:main.c        **** 				PORTE &= ~(setValue);
 4616               		.loc 3 797 0
 4617 0a88 87B1      		in r24,0x7
 4618 0a8a 6095      		com r22
 4619               	.LVL486:
 4620 0a8c 6823      		and r22,r24
 4621               	.LVL487:
 4622 0a8e 00C0      		rjmp .L245
 4623               	.LVL488:
 4624               	.L185:
 4625               	.LBE250:
 798:main.c        **** 			}
 799:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 800:main.c        **** 		}
 801:main.c        **** 		
 802:main.c        **** 		// Set pin output as high
 803:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 4626               		.loc 3 803 0
 4627 0a90 8834      		cpi r24,lo8(72)
 4628 0a92 01F4      		brne .L191
 4629               	.LBB251:
 804:main.c        **** 			char portChar = USART_Receive();			
 4630               		.loc 3 804 0
 4631 0a94 00D0      		rcall USART_Receive
 4632               	.LVL489:
 4633 0a96 182F      		mov r17,r24
 4634               	.LVL490:
 805:main.c        **** 			usart_read_chars();
 4635               		.loc 3 805 0
 4636 0a98 00D0      		rcall usart_read_chars
 4637               	.LVL491:
 806:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4638               		.loc 3 806 0
 4639 0a9a 40E1      		ldi r20,lo8(16)
 4640 0a9c 50E0      		ldi r21,0
 4641 0a9e 60E0      		ldi r22,0
 4642 0aa0 70E0      		ldi r23,0
 4643 0aa2 80E0      		ldi r24,lo8(receivedBuffer)
 4644 0aa4 90E0      		ldi r25,hi8(receivedBuffer)
 4645 0aa6 00D0      		rcall strtol
 4646               	.LVL492:
 807:main.c        **** 			
 808:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4647               		.loc 3 808 0
 4648 0aa8 939A      		sbi 0x12,3
 809:main.c        **** 			if (portChar == 'A') {
 4649               		.loc 3 809 0
 4650 0aaa 1134      		cpi r17,lo8(65)
 4651 0aac 01F4      		brne .L192
 810:main.c        **** 				PORTA |= (setValue);
 4652               		.loc 3 810 0
 4653 0aae 8BB3      		in r24,0x1b
 4654 0ab0 682B      		or r22,r24
 4655               	.LVL493:
 4656               	.L251:
 4657 0ab2 6BBB      		out 0x1b,r22
 4658 0ab4 00C0      		rjmp .L199
 4659               	.LVL494:
 4660               	.L192:
 811:main.c        **** 			}
 812:main.c        **** 			else if (portChar == 'B') {
 4661               		.loc 3 812 0
 4662 0ab6 1234      		cpi r17,lo8(66)
 4663 0ab8 01F4      		brne .L194
 813:main.c        **** 				PORTB |= (setValue);
 4664               		.loc 3 813 0
 4665 0aba 88B3      		in r24,0x18
 4666 0abc 682B      		or r22,r24
 4667               	.LVL495:
 4668               	.L250:
 4669 0abe 68BB      		out 0x18,r22
 4670 0ac0 00C0      		rjmp .L199
 4671               	.LVL496:
 4672               	.L194:
 814:main.c        **** 			}
 815:main.c        **** 			else if (portChar == 'C') {
 4673               		.loc 3 815 0
 4674 0ac2 1334      		cpi r17,lo8(67)
 4675 0ac4 01F4      		brne .L195
 816:main.c        **** 				PORTC |= (setValue);
 4676               		.loc 3 816 0
 4677 0ac6 85B3      		in r24,0x15
 4678 0ac8 682B      		or r22,r24
 4679               	.LVL497:
 4680               	.L249:
 4681 0aca 65BB      		out 0x15,r22
 4682 0acc 00C0      		rjmp .L199
 4683               	.LVL498:
 4684               	.L195:
 817:main.c        **** 			}
 818:main.c        **** 			else if (portChar == 'D') {
 4685               		.loc 3 818 0
 4686 0ace 1434      		cpi r17,lo8(68)
 4687 0ad0 01F4      		brne .L196
 819:main.c        **** 				PORTD |= (setValue);
 4688               		.loc 3 819 0
 4689 0ad2 82B3      		in r24,0x12
 4690 0ad4 682B      		or r22,r24
 4691               	.LVL499:
 4692               	.L248:
 4693 0ad6 62BB      		out 0x12,r22
 4694 0ad8 00C0      		rjmp .L199
 4695               	.LVL500:
 4696               	.L196:
 820:main.c        **** 			}
 821:main.c        **** 			else if (portChar == 'E') {
 4697               		.loc 3 821 0
 4698 0ada 1534      		cpi r17,lo8(69)
 4699 0adc 01F4      		brne .L199
 822:main.c        **** 				PORTE |= (setValue);
 4700               		.loc 3 822 0
 4701 0ade 87B1      		in r24,0x7
 4702 0ae0 682B      		or r22,r24
 4703               	.LVL501:
 4704               	.L245:
 4705 0ae2 67B9      		out 0x7,r22
 4706 0ae4 00C0      		rjmp .L199
 4707               	.L191:
 4708               	.LBE251:
 823:main.c        **** 			}
 824:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 825:main.c        **** 		}
 826:main.c        **** 		
 827:main.c        **** 		// Read all pins of a PORT and return the value
 828:main.c        **** 		else if (receivedChar == READ_INPUT) {
 4709               		.loc 3 828 0
 4710 0ae6 8434      		cpi r24,lo8(68)
 4711 0ae8 01F4      		brne .L197
 4712               	.LBB252:
 829:main.c        **** 			char portChar = USART_Receive();			
 4713               		.loc 3 829 0
 4714 0aea 00D0      		rcall USART_Receive
 4715               	.LVL502:
 830:main.c        **** 			
 831:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4716               		.loc 3 831 0
 4717 0aec 939A      		sbi 0x12,3
 832:main.c        **** 			if (portChar == 'A') {
 4718               		.loc 3 832 0
 4719 0aee 8134      		cpi r24,lo8(65)
 4720 0af0 01F4      		brne .L198
 833:main.c        **** 				USART_Transmit(PINA);
 4721               		.loc 3 833 0
 4722 0af2 89B3      		in r24,0x19
 4723               	.LVL503:
 4724 0af4 00C0      		rjmp .L239
 4725               	.LVL504:
 4726               	.L198:
 834:main.c        **** 			}
 835:main.c        **** 			else if (portChar == 'B') {
 4727               		.loc 3 835 0
 4728 0af6 8234      		cpi r24,lo8(66)
 4729 0af8 01F4      		brne .L200
 836:main.c        **** 				USART_Transmit(PINB);
 4730               		.loc 3 836 0
 4731 0afa 86B3      		in r24,0x16
 4732               	.LVL505:
 4733 0afc 00C0      		rjmp .L239
 4734               	.LVL506:
 4735               	.L200:
 837:main.c        **** 			}
 838:main.c        **** 			else if (portChar == 'C') {
 4736               		.loc 3 838 0
 4737 0afe 8334      		cpi r24,lo8(67)
 4738 0b00 01F4      		brne .L201
 839:main.c        **** 				USART_Transmit(PINC);
 4739               		.loc 3 839 0
 4740 0b02 83B3      		in r24,0x13
 4741               	.LVL507:
 4742 0b04 00C0      		rjmp .L239
 4743               	.LVL508:
 4744               	.L201:
 840:main.c        **** 			}
 841:main.c        **** 			else if (portChar == 'D') {
 4745               		.loc 3 841 0
 4746 0b06 8434      		cpi r24,lo8(68)
 4747 0b08 01F4      		brne .L202
 842:main.c        **** 				USART_Transmit(PIND);
 4748               		.loc 3 842 0
 4749 0b0a 80B3      		in r24,0x10
 4750               	.LVL509:
 4751 0b0c 00C0      		rjmp .L239
 4752               	.LVL510:
 4753               	.L202:
 843:main.c        **** 			}
 844:main.c        **** 			else if (portChar == 'E') {
 4754               		.loc 3 844 0
 4755 0b0e 8534      		cpi r24,lo8(69)
 4756 0b10 01F4      		brne .L199
 845:main.c        **** 				USART_Transmit(PINE);
 4757               		.loc 3 845 0
 4758 0b12 85B1      		in r24,0x5
 4759               	.LVL511:
 4760               	.L239:
 4761 0b14 00D0      		rcall USART_Transmit
 4762               	.LVL512:
 4763               	.L199:
 846:main.c        **** 			}
 847:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 4764               		.loc 3 847 0
 4765 0b16 9398      		cbi 0x12,3
 4766               	.LBE252:
 4767 0b18 00C0      		rjmp .L93
 4768               	.LVL513:
 4769               	.L197:
 848:main.c        **** 		}
 849:main.c        **** 		
 850:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 851:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 4770               		.loc 3 851 0
 4771 0b1a 8D34      		cpi r24,lo8(77)
 4772 0b1c 01F4      		brne .L203
 4773               	.LBB253:
 852:main.c        **** 			char commonChar = USART_Receive();
 4774               		.loc 3 852 0
 4775 0b1e 00D0      		rcall USART_Receive
 4776               	.LVL514:
 853:main.c        **** 			if (commonChar == '1') {
 4777               		.loc 3 853 0
 4778 0b20 8133      		cpi r24,lo8(49)
 4779 0b22 01F4      		brne .L261
 854:main.c        **** 				resetCommonLines = 1;
 4780               		.loc 3 854 0
 4781 0b24 2224      		clr r2
 4782 0b26 2394      		inc r2
 4783 0b28 00C0      		rjmp .L235
 4784               	.L261:
 855:main.c        **** 			}
 856:main.c        **** 			else if (commonChar == '0') {
 4785               		.loc 3 856 0
 4786 0b2a 8033      		cpi r24,lo8(48)
 4787 0b2c 01F0      		breq .+2
 4788 0b2e 00C0      		rjmp .L93
 857:main.c        **** 				resetCommonLines = 0;
 4789               		.loc 3 857 0
 4790 0b30 212C      		mov r2,__zero_reg__
 4791 0b32 00C0      		rjmp .L94
 4792               	.LVL515:
 4793               	.L203:
 4794               	.LBE253:
 858:main.c        **** 			}
 859:main.c        **** 		}
 860:main.c        **** 		
 861:main.c        **** 		// Send back the PCB version number
 862:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 4795               		.loc 3 862 0
 4796 0b34 8836      		cpi r24,lo8(104)
 4797 0b36 01F4      		brne .L204
 863:main.c        **** 			USART_Transmit(PCB_VERSION);
 4798               		.loc 3 863 0
 4799 0b38 84E0      		ldi r24,lo8(4)
 4800 0b3a 00C0      		rjmp .L236
 4801               	.L204:
 864:main.c        **** 		}
 865:main.c        **** 		
 866:main.c        **** 		// Send back the firmware version number
 867:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 4802               		.loc 3 867 0
 4803 0b3c 8635      		cpi r24,lo8(86)
 4804 0b3e 01F4      		brne .L205
 868:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 4805               		.loc 3 868 0
 4806 0b40 8FE0      		ldi r24,lo8(15)
 4807               	.LVL516:
 4808               	.L236:
 4809 0b42 00D0      		rcall USART_Transmit
 4810               	.LVL517:
 4811 0b44 00C0      		rjmp .L93
 4812               	.LVL518:
 4813               	.L205:
 869:main.c        **** 		}
 870:main.c        **** 		
 871:main.c        **** 		// Reset the AVR if it matches the number
 872:main.c        **** 		else if (receivedChar == RESET_AVR) {
 4814               		.loc 3 872 0
 4815 0b46 8A32      		cpi r24,lo8(42)
 4816 0b48 01F0      		breq .+2
 4817 0b4a 00C0      		rjmp .L93
 4818               	.LBB254:
 873:main.c        **** 			usart_read_chars();
 4819               		.loc 3 873 0
 4820 0b4c 00D0      		rcall usart_read_chars
 4821               	.LVL519:
 874:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 4822               		.loc 3 874 0
 4823 0b4e 40E1      		ldi r20,lo8(16)
 4824 0b50 50E0      		ldi r21,0
 4825 0b52 60E0      		ldi r22,0
 4826 0b54 70E0      		ldi r23,0
 4827 0b56 80E0      		ldi r24,lo8(receivedBuffer)
 4828 0b58 90E0      		ldi r25,hi8(receivedBuffer)
 4829 0b5a 00D0      		rcall strtol
 4830               	.LVL520:
 875:main.c        **** 			if (resetValue == RESET_VALUE) {
 4831               		.loc 3 875 0
 4832 0b5c 613E      		cpi r22,-31
 4833 0b5e 754E      		sbci r23,-27
 4834 0b60 8740      		sbci r24,7
 4835 0b62 9105      		cpc r25,__zero_reg__
 4836 0b64 01F0      		breq .+2
 4837 0b66 00C0      		rjmp .L93
 876:main.c        **** 				// Clear watchdog flag
 877:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 4838               		.loc 3 877 0
 4839 0b68 84B7      		in r24,0x34
 4840 0b6a 877F      		andi r24,lo8(-9)
 4841 0b6c 84BF      		out 0x34,r24
 878:main.c        **** 				
 879:main.c        **** 				// Start timed sequence
 880:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 4842               		.loc 3 880 0
 4843 0b6e 28E1      		ldi r18,lo8(24)
 4844 0b70 21BD      		out 0x21,r18
 881:main.c        **** 				
 882:main.c        **** 				// Reset in 250 ms
 883:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 4845               		.loc 3 883 0
 4846 0b72 8CE0      		ldi r24,lo8(12)
 4847 0b74 81BD      		out 0x21,r24
 4848               	.LVL521:
 4849               	.LBB255:
 4850               	.LBB256:
 4851               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 4852               		.loc 4 105 0
 4853 0b76 8FEF      		ldi r24,lo8(-1)
 4854 0b78 9FEF      		ldi r25,lo8(-1)
 4855               	/* #APP */
 4856               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 4857 0b7a 0197      		1: sbiw r24,1
 4858 0b7c 01F4      		brne 1b
 4859               	 ;  0 "" 2
 4860               	.LVL522:
 4861               	/* #NOAPP */
 4862 0b7e 00C0      		rjmp .L93
 4863               	.LBE256:
 4864               	.LBE255:
 4865               	.LBE254:
 4866               		.cfi_endproc
 4867               	.LFE45:
 4869               	.global	cartMode
 4870               		.data
 4873               	cartMode:
 4874 0000 02        		.byte	2
 4875               	.global	lastBankAccessed
 4876               		.section .bss
 4879               	lastBankAccessed:
 4880 0000 00        		.zero	1
 4881               	.global	flashBank1CommandWrites
 4884               	flashBank1CommandWrites:
 4885 0001 00        		.zero	1
 4886               		.comm	flashWriteCycle,12,1
 4887               		.comm	flashWriteWePin,1,1
 4888               		.comm	flashChipIdBuffer,2,1
 4889               		.comm	eepromBuffer,8,1
 4890               		.comm	receivedChar,1,1
 4891               		.comm	receivedBuffer,256,1
 4892               		.text
 4893               	.Letext0:
 4894               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 4895               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1467   .text:0000040a gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1546   .text:0000043c gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1646   .text:000004a0 gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:4879   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1809   .text:00000534 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1875   .text:00000564 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:1999   .text:000005c4 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:2121   .text:00000620 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:2229   .text:00000676 setup
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:4873   .data:00000000 cartMode
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:2325   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccdxXbku.s:4884   .bss:00000001 flashBank1CommandWrites

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
