   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW Mini
   3:setup.c       ****  PCB version: 1.0
   4:setup.c       ****  Firmware version: R14
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 15/05/2019
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define ACTIVITY_LED PD3
  28:setup.c       **** 
  29:setup.c       **** #define WR_PIN PD6
  30:setup.c       **** #define RD_PIN PD5
  31:setup.c       **** #define CS_MREQ_PIN PD4
  32:setup.c       **** #define CS2_PIN PE2
  33:setup.c       **** #define AUDIO_PIN PE1
  34:setup.c       **** 
  35:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  36:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  37:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  38:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  39:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  40:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  41:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  42:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  43:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  44:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  45:setup.c       **** 
  46:setup.c       **** #define GB_MODE 1
  47:setup.c       **** 
  48:setup.c       **** // GB/GBC
  49:setup.c       **** #define PORT_ADDR7_0 PORTB
  50:setup.c       **** #define PORT_ADDR15_8 PORTA
  51:setup.c       **** #define PORT_DATA7_0 PORTC
  52:setup.c       **** 
  53:setup.c       **** #define DDR_ADDR7_0 DDRB
  54:setup.c       **** #define DDR_ADDR15_8 DDRA
  55:setup.c       **** #define DDR_DATA7_0 DDRC
  56:setup.c       **** 
  57:setup.c       **** #define PIN_ADDR7_0 PINB
  58:setup.c       **** #define PIN_ADDR15_8 PINA
  59:setup.c       **** #define PIN_DATA7_0 PINC
  60:setup.c       **** 
  61:setup.c       **** #define BANK_WRITE 0
  62:setup.c       **** #define MEMORY_WRITE 1
  63:setup.c       **** 
  64:setup.c       **** 
  65:setup.c       **** // GB/GBC commands
  66:setup.c       **** #define SET_START_ADDRESS 'A'
  67:setup.c       **** #define READ_ROM_RAM 'R'
  68:setup.c       **** #define WRITE_RAM 'W'
  69:setup.c       **** #define SET_BANK 'B'
  70:setup.c       **** #define GB_CART_MODE 'G'
  71:setup.c       **** 
  72:setup.c       **** // Flash Cart commands
  73:setup.c       **** #define GB_FLASH_WE_PIN 'P'
  74:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
  75:setup.c       **** 	#define WE_AS_WR_PIN 'W'
  76:setup.c       **** 
  77:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
  78:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
  79:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
  80:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
  81:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
  82:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
  83:setup.c       **** 
  84:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
  85:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
  86:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
  87:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
  88:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
  89:setup.c       **** 
  90:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
  91:setup.c       **** 
  92:setup.c       **** #define D0D1_NOT_SWAPPED 0
  93:setup.c       **** #define D0D1_SWAPPED 1
  94:setup.c       **** 
  95:setup.c       **** // General commands
  96:setup.c       **** #define SEND_ACK '1'
  97:setup.c       **** #define CART_MODE 'C'
  98:setup.c       **** #define SET_INPUT 'I'
  99:setup.c       **** #define SET_OUTPUT 'O'
 100:setup.c       **** #define SET_OUTPUT_LOW 'L'
 101:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 102:setup.c       **** #define READ_INPUT 'D'
 103:setup.c       **** #define RESET_COMMON_LINES 'M'
 104:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 105:setup.c       **** #define READ_PCB_VERSION 'h'
 106:setup.c       **** 
 107:setup.c       **** #define RESET_AVR '*'
 108:setup.c       **** #define RESET_VALUE 0x7E5E1
 109:setup.c       **** 
 110:setup.c       **** 
 111:setup.c       **** char receivedBuffer[256];
 112:setup.c       **** char receivedChar;
 113:setup.c       **** 
 114:setup.c       **** char flashWriteWePin;
 115:setup.c       **** uint16_t flashWriteCycle[3][2];
 116:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 117:setup.c       **** uint8_t lastBankAccessed = 0;
 118:setup.c       **** 
 119:setup.c       **** uint8_t cartMode = GB_MODE;
 120:setup.c       **** 
 121:setup.c       **** // Receive USART data
 122:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 122 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 123:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 123 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 124:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 124 0
  26 0004 8CB1      		in r24,0xc
 125:setup.c       **** }
  27               		.loc 1 125 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 126:setup.c       **** 
 127:setup.c       **** // Transmit USART data
 128:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 128 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 129:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 129 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 130:setup.c       **** 	UDR = data;
  47               		.loc 1 130 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 131:setup.c       **** }
 132:setup.c       **** 
 133:setup.c       **** // Read 1-256 bytes from the USART 
 134:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 134 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB76:
 135:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 135 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 135 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 136:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 136 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE76:
 137:setup.c       **** 	}
 138:setup.c       **** }
 106               		.loc 1 138 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 139:setup.c       **** 
 140:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 141:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 141 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 142:setup.c       **** 	int x = 0;
 143:setup.c       **** 	while (1) {
 144:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 144 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 145:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 145 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 146:setup.c       **** 			break;
 147:setup.c       **** 		}
 148:setup.c       **** 		x++;
 149:setup.c       **** 	}
 150:setup.c       **** }
 148               		.loc 1 150 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 151:setup.c       **** 
 152:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 153:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 153 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 154:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 154 0
 167 0050 3A9A      		sbi 0x7,2
 155:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 155 0
 169 0052 949A      		sbi 0x12,4
 156:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 156 0
 171 0054 959A      		sbi 0x12,5
 157:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 157 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 158:setup.c       **** }
 159:setup.c       **** 
 160:setup.c       **** 
 161:setup.c       **** 
 162:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 163:setup.c       **** 
 164:setup.c       **** // Set Gameboy mode
 165:setup.c       **** void gb_mode(void) {
 182               		.loc 1 165 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 166:setup.c       **** 	// Set inputs
 167:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 167 0
 189 005a 15BA      		out 0x15,__zero_reg__
 168:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 168 0
 191 005c 14BA      		out 0x14,__zero_reg__
 169:setup.c       **** 	
 170:setup.c       **** 	// Set outputs
 171:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 171 0
 193 005e 18BA      		out 0x18,__zero_reg__
 172:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 172 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 173:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 173 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 174:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 174 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 175:setup.c       **** }
 176:setup.c       **** 
 177:setup.c       **** // Set the 16 bit address on A15-0
 178:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 178 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 179:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 179 0
 217 006a 9BBB      		out 0x1b,r25
 180:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 180 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 181:setup.c       **** }
 182:setup.c       **** 
 183:setup.c       **** // Set the address and read a byte from the 8 bit data line
 184:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 184 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 185:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 185 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 186:setup.c       **** 	
 187:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 187 0
 239 0072 9498      		cbi 0x12,4
 188:setup.c       **** 	rdPin_low;
 240               		.loc 1 188 0
 241 0074 9598      		cbi 0x12,5
 189:setup.c       **** 	
 190:setup.c       **** 	asm volatile("nop"); // Delay a little (At 8MHz - minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 190 0
 243               	/* #APP */
 244               	 ;  190 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 191:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 191 0
 248               	 ;  191 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 192:setup.c       **** 	asm volatile("nop");
 251               		.loc 1 192 0
 252               	 ;  192 "setup.c" 1
 253 007a 0000      		nop
 254               	 ;  0 "" 2
 193:setup.c       **** 	asm volatile("nop");
 255               		.loc 1 193 0
 256               	 ;  193 "setup.c" 1
 257 007c 0000      		nop
 258               	 ;  0 "" 2
 194:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 259               		.loc 1 194 0
 260               	/* #NOAPP */
 261 007e 83B3      		in r24,0x13
 262               	.LVL17:
 195:setup.c       **** 	
 196:setup.c       **** 	rdPin_high;
 263               		.loc 1 196 0
 264 0080 959A      		sbi 0x12,5
 197:setup.c       **** 	cs_mreqPin_high;
 265               		.loc 1 197 0
 266 0082 949A      		sbi 0x12,4
 198:setup.c       **** 	
 199:setup.c       **** 	return data;
 200:setup.c       **** }
 267               		.loc 1 200 0
 268 0084 0895      		ret
 269               		.cfi_endproc
 270               	.LFE19:
 272               	.global	write_8bit_data
 274               	write_8bit_data:
 275               	.LFB20:
 201:setup.c       **** 
 202:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 203:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 276               		.loc 1 203 0
 277               		.cfi_startproc
 278               	.LVL18:
 279 0086 CF93      		push r28
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 3
 282               		.cfi_offset 28, -2
 283 0088 DF93      		push r29
 284               	.LCFI7:
 285               		.cfi_def_cfa_offset 4
 286               		.cfi_offset 29, -3
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 2 */
 290               	.L__stack_usage = 2
 291 008a D62F      		mov r29,r22
 292 008c C42F      		mov r28,r20
 204:setup.c       **** 	set_16bit_address(address);
 293               		.loc 1 204 0
 294 008e 00D0      		rcall set_16bit_address
 295               	.LVL19:
 205:setup.c       **** 	
 206:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 296               		.loc 1 206 0
 297 0090 8FEF      		ldi r24,lo8(-1)
 298 0092 84BB      		out 0x14,r24
 207:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 299               		.loc 1 207 0
 300 0094 D5BB      		out 0x15,r29
 208:setup.c       **** 	
 209:setup.c       **** 	// Pulse WR and mREQ if the type matches
 210:setup.c       **** 	wrPin_low;
 301               		.loc 1 210 0
 302 0096 9698      		cbi 0x12,6
 211:setup.c       **** 	if (type == MEMORY_WRITE) {
 303               		.loc 1 211 0
 304 0098 C130      		cpi r28,lo8(1)
 305 009a 01F4      		brne .L21
 212:setup.c       **** 		cs_mreqPin_low;
 306               		.loc 1 212 0
 307 009c 9498      		cbi 0x12,4
 308               	.L21:
 213:setup.c       **** 	}
 214:setup.c       **** 	
 215:setup.c       **** 	asm volatile("nop");
 309               		.loc 1 215 0
 310               	/* #APP */
 311               	 ;  215 "setup.c" 1
 312 009e 0000      		nop
 313               	 ;  0 "" 2
 216:setup.c       **** 	asm volatile("nop");
 314               		.loc 1 216 0
 315               	 ;  216 "setup.c" 1
 316 00a0 0000      		nop
 317               	 ;  0 "" 2
 217:setup.c       **** 	
 218:setup.c       **** 	if (type == MEMORY_WRITE) {
 318               		.loc 1 218 0
 319               	/* #NOAPP */
 320 00a2 C130      		cpi r28,lo8(1)
 321 00a4 01F4      		brne .L22
 219:setup.c       **** 		cs_mreqPin_high;
 322               		.loc 1 219 0
 323 00a6 949A      		sbi 0x12,4
 324               	.L22:
 220:setup.c       **** 	}
 221:setup.c       **** 	wrPin_high;
 325               		.loc 1 221 0
 326 00a8 969A      		sbi 0x12,6
 222:setup.c       **** 	
 223:setup.c       **** 	// Clear data outputs and set data pins as inputs
 224:setup.c       **** 	PORT_DATA7_0 = 0;
 327               		.loc 1 224 0
 328 00aa 15BA      		out 0x15,__zero_reg__
 225:setup.c       **** 	DDR_DATA7_0 = 0;
 329               		.loc 1 225 0
 330 00ac 14BA      		out 0x14,__zero_reg__
 331               	/* epilogue start */
 226:setup.c       **** }
 332               		.loc 1 226 0
 333 00ae DF91      		pop r29
 334               	.LVL20:
 335 00b0 CF91      		pop r28
 336               	.LVL21:
 337 00b2 0895      		ret
 338               		.cfi_endproc
 339               	.LFE20:
 341               	.global	gb_flash_read_byte
 343               	gb_flash_read_byte:
 344               	.LFB21:
 227:setup.c       **** 
 228:setup.c       **** 
 229:setup.c       **** 
 230:setup.c       **** // ---------- GB FLASH CARTS ----------
 231:setup.c       **** 
 232:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 233:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 345               		.loc 1 233 0
 346               		.cfi_startproc
 347               	.LVL22:
 348               	/* prologue: function */
 349               	/* frame size = 0 */
 350               	/* stack size = 0 */
 351               	.L__stack_usage = 0
 234:setup.c       **** 	PORT_DATA7_0 = 0;
 352               		.loc 1 234 0
 353 00b4 15BA      		out 0x15,__zero_reg__
 235:setup.c       **** 	DDR_DATA7_0 = 0;
 354               		.loc 1 235 0
 355 00b6 14BA      		out 0x14,__zero_reg__
 236:setup.c       **** 	
 237:setup.c       **** 	set_16bit_address(address);
 356               		.loc 1 237 0
 357 00b8 00D0      		rcall set_16bit_address
 358               	.LVL23:
 238:setup.c       **** 	
 239:setup.c       **** 	rdPin_low;
 359               		.loc 1 239 0
 360 00ba 9598      		cbi 0x12,5
 240:setup.c       **** 	asm volatile("nop"); // Delay a little
 361               		.loc 1 240 0
 362               	/* #APP */
 363               	 ;  240 "setup.c" 1
 364 00bc 0000      		nop
 365               	 ;  0 "" 2
 241:setup.c       **** 	asm volatile("nop");
 366               		.loc 1 241 0
 367               	 ;  241 "setup.c" 1
 368 00be 0000      		nop
 369               	 ;  0 "" 2
 242:setup.c       **** 	asm volatile("nop");
 370               		.loc 1 242 0
 371               	 ;  242 "setup.c" 1
 372 00c0 0000      		nop
 373               	 ;  0 "" 2
 243:setup.c       **** 	asm volatile("nop");
 374               		.loc 1 243 0
 375               	 ;  243 "setup.c" 1
 376 00c2 0000      		nop
 377               	 ;  0 "" 2
 244:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 378               		.loc 1 244 0
 379               	/* #NOAPP */
 380 00c4 83B3      		in r24,0x13
 381               	.LVL24:
 245:setup.c       **** 	rdPin_high;
 382               		.loc 1 245 0
 383 00c6 959A      		sbi 0x12,5
 246:setup.c       **** 	
 247:setup.c       **** 	return data;
 248:setup.c       **** }
 384               		.loc 1 248 0
 385 00c8 0895      		ret
 386               		.cfi_endproc
 387               	.LFE21:
 389               	.global	gb_flash_write_bus_cycle
 391               	gb_flash_write_bus_cycle:
 392               	.LFB22:
 249:setup.c       **** 
 250:setup.c       **** // Set the address and data for the write byte cycle to the flash
 251:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 393               		.loc 1 251 0
 394               		.cfi_startproc
 395               	.LVL25:
 396 00ca CF93      		push r28
 397               	.LCFI8:
 398               		.cfi_def_cfa_offset 3
 399               		.cfi_offset 28, -2
 400               	/* prologue: function */
 401               	/* frame size = 0 */
 402               	/* stack size = 1 */
 403               	.L__stack_usage = 1
 404 00cc C62F      		mov r28,r22
 252:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 405               		.loc 1 252 0
 406 00ce 2FEF      		ldi r18,lo8(-1)
 407 00d0 24BB      		out 0x14,r18
 253:setup.c       **** 	set_16bit_address(address);
 408               		.loc 1 253 0
 409 00d2 00D0      		rcall set_16bit_address
 410               	.LVL26:
 254:setup.c       **** 	PORT_DATA7_0 = data;
 411               		.loc 1 254 0
 412 00d4 C5BB      		out 0x15,r28
 255:setup.c       **** 	
 256:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 413               		.loc 1 256 0
 414 00d6 8091 0000 		lds r24,flashWriteWePin
 415 00da 8134      		cpi r24,lo8(65)
 416 00dc 01F4      		brne .L25
 257:setup.c       **** 		audioPin_low; // WE low
 417               		.loc 1 257 0
 418 00de 3998      		cbi 0x7,1
 258:setup.c       **** 		asm volatile("nop");
 419               		.loc 1 258 0
 420               	/* #APP */
 421               	 ;  258 "setup.c" 1
 422 00e0 0000      		nop
 423               	 ;  0 "" 2
 259:setup.c       **** 		asm volatile("nop");
 424               		.loc 1 259 0
 425               	 ;  259 "setup.c" 1
 426 00e2 0000      		nop
 427               	 ;  0 "" 2
 260:setup.c       **** 		asm volatile("nop");
 428               		.loc 1 260 0
 429               	 ;  260 "setup.c" 1
 430 00e4 0000      		nop
 431               	 ;  0 "" 2
 261:setup.c       **** 		asm volatile("nop");
 432               		.loc 1 261 0
 433               	 ;  261 "setup.c" 1
 434 00e6 0000      		nop
 435               	 ;  0 "" 2
 262:setup.c       **** 		asm volatile("nop");
 436               		.loc 1 262 0
 437               	 ;  262 "setup.c" 1
 438 00e8 0000      		nop
 439               	 ;  0 "" 2
 263:setup.c       **** 		asm volatile("nop");
 440               		.loc 1 263 0
 441               	 ;  263 "setup.c" 1
 442 00ea 0000      		nop
 443               	 ;  0 "" 2
 264:setup.c       **** 		audioPin_high; // WE high
 444               		.loc 1 264 0
 445               	/* #NOAPP */
 446 00ec 399A      		sbi 0x7,1
 447 00ee 00C0      		rjmp .L26
 448               	.L25:
 265:setup.c       **** 	}
 266:setup.c       **** 	else { // WR pin
 267:setup.c       **** 		wrPin_low; // WE low
 449               		.loc 1 267 0
 450 00f0 9698      		cbi 0x12,6
 268:setup.c       **** 		asm volatile("nop");
 451               		.loc 1 268 0
 452               	/* #APP */
 453               	 ;  268 "setup.c" 1
 454 00f2 0000      		nop
 455               	 ;  0 "" 2
 269:setup.c       **** 		asm volatile("nop");
 456               		.loc 1 269 0
 457               	 ;  269 "setup.c" 1
 458 00f4 0000      		nop
 459               	 ;  0 "" 2
 270:setup.c       **** 		asm volatile("nop");
 460               		.loc 1 270 0
 461               	 ;  270 "setup.c" 1
 462 00f6 0000      		nop
 463               	 ;  0 "" 2
 271:setup.c       **** 		asm volatile("nop");
 464               		.loc 1 271 0
 465               	 ;  271 "setup.c" 1
 466 00f8 0000      		nop
 467               	 ;  0 "" 2
 272:setup.c       **** 		asm volatile("nop");
 468               		.loc 1 272 0
 469               	 ;  272 "setup.c" 1
 470 00fa 0000      		nop
 471               	 ;  0 "" 2
 273:setup.c       **** 		asm volatile("nop");
 472               		.loc 1 273 0
 473               	 ;  273 "setup.c" 1
 474 00fc 0000      		nop
 475               	 ;  0 "" 2
 274:setup.c       **** 		wrPin_high; // WE high
 476               		.loc 1 274 0
 477               	/* #NOAPP */
 478 00fe 969A      		sbi 0x12,6
 479               	.L26:
 275:setup.c       **** 	}
 276:setup.c       **** 	
 277:setup.c       **** 	// Clear data outputs and set data pins as inputs
 278:setup.c       **** 	PORT_DATA7_0 = 0;
 480               		.loc 1 278 0
 481 0100 15BA      		out 0x15,__zero_reg__
 279:setup.c       **** 	DDR_DATA7_0 = 0;
 482               		.loc 1 279 0
 483 0102 14BA      		out 0x14,__zero_reg__
 484               	/* epilogue start */
 280:setup.c       **** }
 485               		.loc 1 280 0
 486 0104 CF91      		pop r28
 487               	.LVL27:
 488 0106 0895      		ret
 489               		.cfi_endproc
 490               	.LFE22:
 492               	.global	gb_flash_write_byte
 494               	gb_flash_write_byte:
 495               	.LFB23:
 281:setup.c       **** 
 282:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 283:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 496               		.loc 1 283 0
 497               		.cfi_startproc
 498               	.LVL28:
 499 0108 1F93      		push r17
 500               	.LCFI9:
 501               		.cfi_def_cfa_offset 3
 502               		.cfi_offset 17, -2
 503 010a CF93      		push r28
 504               	.LCFI10:
 505               		.cfi_def_cfa_offset 4
 506               		.cfi_offset 28, -3
 507 010c DF93      		push r29
 508               	.LCFI11:
 509               		.cfi_def_cfa_offset 5
 510               		.cfi_offset 29, -4
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 3 */
 514               	.L__stack_usage = 3
 515 010e EC01      		movw r28,r24
 516 0110 162F      		mov r17,r22
 284:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 517               		.loc 1 284 0
 518 0112 6091 0000 		lds r22,flashWriteCycle+2
 519               	.LVL29:
 520 0116 8091 0000 		lds r24,flashWriteCycle
 521 011a 9091 0000 		lds r25,flashWriteCycle+1
 522               	.LVL30:
 523 011e 00D0      		rcall gb_flash_write_bus_cycle
 524               	.LVL31:
 285:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 525               		.loc 1 285 0
 526 0120 6091 0000 		lds r22,flashWriteCycle+6
 527 0124 8091 0000 		lds r24,flashWriteCycle+4
 528 0128 9091 0000 		lds r25,flashWriteCycle+4+1
 529 012c 00D0      		rcall gb_flash_write_bus_cycle
 530               	.LVL32:
 286:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 531               		.loc 1 286 0
 532 012e 6091 0000 		lds r22,flashWriteCycle+10
 533 0132 8091 0000 		lds r24,flashWriteCycle+8
 534 0136 9091 0000 		lds r25,flashWriteCycle+8+1
 535 013a 00D0      		rcall gb_flash_write_bus_cycle
 536               	.LVL33:
 287:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 537               		.loc 1 287 0
 538 013c 612F      		mov r22,r17
 539 013e CE01      		movw r24,r28
 540 0140 00D0      		rcall gb_flash_write_bus_cycle
 541               	.LVL34:
 542               	.LBB77:
 543               	.LBB78:
 544               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 545               		.loc 2 276 0
 546 0142 85E3      		ldi r24,lo8(53)
 547 0144 8A95      	1:	dec r24
 548 0146 01F4      		brne 1b
 549 0148 0000      		nop
 550               	.LVL35:
 551               	.LBE78:
 552               	.LBE77:
 288:setup.c       **** 	_delay_us(10); // Wait byte program time
 289:setup.c       **** 	
 290:setup.c       **** 	// Set data pins inputs
 291:setup.c       **** 	PORT_DATA7_0 = 0;
 553               		.loc 1 291 0
 554 014a 15BA      		out 0x15,__zero_reg__
 292:setup.c       **** 	DDR_DATA7_0 = 0;
 555               		.loc 1 292 0
 556 014c 14BA      		out 0x14,__zero_reg__
 293:setup.c       **** 	
 294:setup.c       **** 	// Verify data
 295:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 557               		.loc 1 295 0
 558 014e CE01      		movw r24,r28
 559 0150 00D0      		rcall gb_flash_read_byte
 560               	.LVL36:
 561               	.L28:
 296:setup.c       **** 	while (data != dataVerify) {
 562               		.loc 1 296 0
 563 0152 8117      		cp r24,r17
 564 0154 01F0      		breq .L30
 297:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 565               		.loc 1 297 0
 566 0156 CE01      		movw r24,r28
 567               	.LVL37:
 568 0158 00D0      		rcall gb_flash_read_byte
 569               	.LVL38:
 570               	.LBB79:
 571               	.LBB80:
 572               		.loc 2 276 0
 573 015a 9AE1      		ldi r25,lo8(26)
 574 015c 9A95      	1:	dec r25
 575 015e 01F4      		brne 1b
 576 0160 00C0      		rjmp .
 577 0162 00C0      		rjmp .L28
 578               	.LVL39:
 579               	.L30:
 580               	/* epilogue start */
 581               	.LBE80:
 582               	.LBE79:
 298:setup.c       **** 		_delay_us(5);
 299:setup.c       **** 	}
 300:setup.c       **** }
 583               		.loc 1 300 0
 584 0164 DF91      		pop r29
 585 0166 CF91      		pop r28
 586               	.LVL40:
 587 0168 1F91      		pop r17
 588               	.LVL41:
 589 016a 0895      		ret
 590               		.cfi_endproc
 591               	.LFE23:
 593               	.global	gb_flash_write_byte_bank1_commands
 595               	gb_flash_write_byte_bank1_commands:
 596               	.LFB24:
 301:setup.c       **** 
 302:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 303:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 304:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 597               		.loc 1 304 0
 598               		.cfi_startproc
 599               	.LVL42:
 600 016c FF92      		push r15
 601               	.LCFI12:
 602               		.cfi_def_cfa_offset 3
 603               		.cfi_offset 15, -2
 604 016e 0F93      		push r16
 605               	.LCFI13:
 606               		.cfi_def_cfa_offset 4
 607               		.cfi_offset 16, -3
 608 0170 1F93      		push r17
 609               	.LCFI14:
 610               		.cfi_def_cfa_offset 5
 611               		.cfi_offset 17, -4
 612 0172 CF93      		push r28
 613               	.LCFI15:
 614               		.cfi_def_cfa_offset 6
 615               		.cfi_offset 28, -5
 616 0174 DF93      		push r29
 617               	.LCFI16:
 618               		.cfi_def_cfa_offset 7
 619               		.cfi_offset 29, -6
 620               	/* prologue: function */
 621               	/* frame size = 0 */
 622               	/* stack size = 5 */
 623               	.L__stack_usage = 5
 624 0176 EC01      		movw r28,r24
 625 0178 162F      		mov r17,r22
 305:setup.c       **** 	// Set bank 1
 306:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 626               		.loc 1 306 0
 627 017a FF24      		clr r15
 628 017c FA94      		dec r15
 629 017e F4BA      		out 0x14,r15
 630               	.LVL43:
 631               	.LBB81:
 632               	.LBB82:
 179:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 633               		.loc 1 179 0
 634 0180 01E2      		ldi r16,lo8(33)
 635 0182 0BBB      		out 0x1b,r16
 180:setup.c       **** }
 636               		.loc 1 180 0
 637 0184 18BA      		out 0x18,__zero_reg__
 638               	.LVL44:
 639               	.LBE82:
 640               	.LBE81:
 307:setup.c       **** 	set_16bit_address(0x2100);
 308:setup.c       **** 	PORT_DATA7_0 = 1;
 641               		.loc 1 308 0
 642 0186 81E0      		ldi r24,lo8(1)
 643               	.LVL45:
 644 0188 85BB      		out 0x15,r24
 309:setup.c       **** 	wrPin_low; // Pulse WR
 645               		.loc 1 309 0
 646 018a 9698      		cbi 0x12,6
 310:setup.c       **** 	asm volatile("nop");
 647               		.loc 1 310 0
 648               	/* #APP */
 649               	 ;  310 "setup.c" 1
 650 018c 0000      		nop
 651               	 ;  0 "" 2
 311:setup.c       **** 	asm volatile("nop");
 652               		.loc 1 311 0
 653               	 ;  311 "setup.c" 1
 654 018e 0000      		nop
 655               	 ;  0 "" 2
 312:setup.c       **** 	wrPin_high;
 656               		.loc 1 312 0
 657               	/* #NOAPP */
 658 0190 969A      		sbi 0x12,6
 313:setup.c       **** 	
 314:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 659               		.loc 1 314 0
 660 0192 6091 0000 		lds r22,flashWriteCycle+2
 661               	.LVL46:
 662 0196 8091 0000 		lds r24,flashWriteCycle
 663 019a 9091 0000 		lds r25,flashWriteCycle+1
 664 019e 00D0      		rcall gb_flash_write_bus_cycle
 665               	.LVL47:
 315:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 666               		.loc 1 315 0
 667 01a0 6091 0000 		lds r22,flashWriteCycle+6
 668 01a4 8091 0000 		lds r24,flashWriteCycle+4
 669 01a8 9091 0000 		lds r25,flashWriteCycle+4+1
 670 01ac 00D0      		rcall gb_flash_write_bus_cycle
 671               	.LVL48:
 316:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 672               		.loc 1 316 0
 673 01ae 6091 0000 		lds r22,flashWriteCycle+10
 674 01b2 8091 0000 		lds r24,flashWriteCycle+8
 675 01b6 9091 0000 		lds r25,flashWriteCycle+8+1
 676 01ba 00D0      		rcall gb_flash_write_bus_cycle
 677               	.LVL49:
 317:setup.c       **** 	
 318:setup.c       **** 	
 319:setup.c       **** 	// Set bank back
 320:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 678               		.loc 1 320 0
 679 01bc F4BA      		out 0x14,r15
 680               	.LVL50:
 681               	.LBB83:
 682               	.LBB84:
 179:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 683               		.loc 1 179 0
 684 01be 0BBB      		out 0x1b,r16
 180:setup.c       **** }
 685               		.loc 1 180 0
 686 01c0 18BA      		out 0x18,__zero_reg__
 687               	.LVL51:
 688               	.LBE84:
 689               	.LBE83:
 321:setup.c       **** 	set_16bit_address(0x2100);
 322:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 690               		.loc 1 322 0
 691 01c2 8091 0000 		lds r24,lastBankAccessed
 692 01c6 85BB      		out 0x15,r24
 323:setup.c       **** 	wrPin_low; // Pulse WR
 693               		.loc 1 323 0
 694 01c8 9698      		cbi 0x12,6
 324:setup.c       **** 	asm volatile("nop");
 695               		.loc 1 324 0
 696               	/* #APP */
 697               	 ;  324 "setup.c" 1
 698 01ca 0000      		nop
 699               	 ;  0 "" 2
 325:setup.c       **** 	asm volatile("nop");
 700               		.loc 1 325 0
 701               	 ;  325 "setup.c" 1
 702 01cc 0000      		nop
 703               	 ;  0 "" 2
 326:setup.c       **** 	wrPin_high;
 704               		.loc 1 326 0
 705               	/* #NOAPP */
 706 01ce 969A      		sbi 0x12,6
 327:setup.c       **** 	
 328:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 707               		.loc 1 328 0
 708 01d0 612F      		mov r22,r17
 709 01d2 CE01      		movw r24,r28
 710 01d4 00D0      		rcall gb_flash_write_bus_cycle
 711               	.LVL52:
 712               	.LBB85:
 713               	.LBB86:
 714               		.loc 2 276 0
 715 01d6 85E3      		ldi r24,lo8(53)
 716 01d8 8A95      	1:	dec r24
 717 01da 01F4      		brne 1b
 718 01dc 0000      		nop
 719               	.LVL53:
 720               	.LBE86:
 721               	.LBE85:
 329:setup.c       **** 	_delay_us(10); // Wait byte program time
 330:setup.c       **** 	
 331:setup.c       **** 	// Set data pins inputs
 332:setup.c       **** 	PORT_DATA7_0 = 0;
 722               		.loc 1 332 0
 723 01de 15BA      		out 0x15,__zero_reg__
 333:setup.c       **** 	DDR_DATA7_0 = 0;
 724               		.loc 1 333 0
 725 01e0 14BA      		out 0x14,__zero_reg__
 334:setup.c       **** 	
 335:setup.c       **** 	// Verify data
 336:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 726               		.loc 1 336 0
 727 01e2 CE01      		movw r24,r28
 728 01e4 00D0      		rcall gb_flash_read_byte
 729               	.LVL54:
 730               	.L32:
 337:setup.c       **** 	while (data != dataVerify) {
 731               		.loc 1 337 0
 732 01e6 8117      		cp r24,r17
 733 01e8 01F0      		breq .L34
 338:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 734               		.loc 1 338 0
 735 01ea CE01      		movw r24,r28
 736               	.LVL55:
 737 01ec 00D0      		rcall gb_flash_read_byte
 738               	.LVL56:
 739               	.LBB87:
 740               	.LBB88:
 741               		.loc 2 276 0
 742 01ee 9AE1      		ldi r25,lo8(26)
 743 01f0 9A95      	1:	dec r25
 744 01f2 01F4      		brne 1b
 745 01f4 00C0      		rjmp .
 746 01f6 00C0      		rjmp .L32
 747               	.LVL57:
 748               	.L34:
 749               	/* epilogue start */
 750               	.LBE88:
 751               	.LBE87:
 339:setup.c       **** 		_delay_us(5);
 340:setup.c       **** 	}
 341:setup.c       **** }
 752               		.loc 1 341 0
 753 01f8 DF91      		pop r29
 754 01fa CF91      		pop r28
 755               	.LVL58:
 756 01fc 1F91      		pop r17
 757               	.LVL59:
 758 01fe 0F91      		pop r16
 759 0200 FF90      		pop r15
 760 0202 0895      		ret
 761               		.cfi_endproc
 762               	.LFE24:
 764               	.global	setup
 766               	setup:
 767               	.LFB25:
 342:setup.c       **** 
 343:setup.c       **** 
 344:setup.c       **** // Setup
 345:setup.c       **** void setup(void) {
 768               		.loc 1 345 0
 769               		.cfi_startproc
 770               	/* prologue: function */
 771               	/* frame size = 0 */
 772               	/* stack size = 0 */
 773               	.L__stack_usage = 0
 346:setup.c       **** 	// Turn off watchdog
 347:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 774               		.loc 1 347 0
 775 0204 84B7      		in r24,0x34
 776 0206 877F      		andi r24,lo8(-9)
 777 0208 84BF      		out 0x34,r24
 348:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 778               		.loc 1 348 0
 779 020a 88E1      		ldi r24,lo8(24)
 780 020c 81BD      		out 0x21,r24
 349:setup.c       **** 	WDTCR = 0;
 781               		.loc 1 349 0
 782 020e 11BC      		out 0x21,__zero_reg__
 350:setup.c       **** 	
 351:setup.c       **** 	// Reset common lines
 352:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 783               		.loc 1 352 0
 784 0210 00D0      		rcall rd_wr_csmreq_cs2_reset
 785               	.LVL60:
 353:setup.c       **** 	
 354:setup.c       **** 	// Set outputs
 355:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN);
 786               		.loc 1 355 0
 787 0212 81B3      		in r24,0x11
 788 0214 8867      		ori r24,lo8(120)
 789 0216 81BB      		out 0x11,r24
 356:setup.c       **** 	DDRE |= (1<<CS2_PIN);
 790               		.loc 1 356 0
 791 0218 329A      		sbi 0x6,2
 357:setup.c       **** 	
 358:setup.c       **** 	// Pull ups
 359:setup.c       **** 	PORTE |= (1<<PE0);
 792               		.loc 1 359 0
 793 021a 389A      		sbi 0x7,0
 360:setup.c       **** 	PORTD |= (1<<PD7) | (1<<PD2);
 794               		.loc 1 360 0
 795 021c 82B3      		in r24,0x12
 796 021e 8468      		ori r24,lo8(-124)
 797 0220 82BB      		out 0x12,r24
 361:setup.c       **** 	
 362:setup.c       **** 	// Set all pins as inputs
 363:setup.c       **** 	PORT_DATA7_0 = 0;
 798               		.loc 1 363 0
 799 0222 15BA      		out 0x15,__zero_reg__
 364:setup.c       **** 	DDR_DATA7_0 = 0;
 800               		.loc 1 364 0
 801 0224 14BA      		out 0x14,__zero_reg__
 365:setup.c       **** 	PORT_ADDR7_0 = 0;
 802               		.loc 1 365 0
 803 0226 18BA      		out 0x18,__zero_reg__
 366:setup.c       **** 	DDR_ADDR7_0 = 0;
 804               		.loc 1 366 0
 805 0228 17BA      		out 0x17,__zero_reg__
 367:setup.c       **** 	PORT_ADDR15_8 = 0;
 806               		.loc 1 367 0
 807 022a 1BBA      		out 0x1b,__zero_reg__
 368:setup.c       **** 	DDR_ADDR15_8 = 0;
 808               		.loc 1 368 0
 809 022c 1ABA      		out 0x1a,__zero_reg__
 369:setup.c       **** 	
 370:setup.c       **** 	// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 371:setup.c       **** 	cs2Pin_low;
 810               		.loc 1 371 0
 811 022e 3A98      		cbi 0x7,2
 812               	.LVL61:
 813               	.LBB89:
 814               	.LBB90:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 815               		.loc 2 187 0
 816 0230 2FEF      		ldi r18,lo8(159999)
 817 0232 80E7      		ldi r24,hi8(159999)
 818 0234 92E0      		ldi r25,hlo8(159999)
 819 0236 2150      	1:	subi r18,1
 820 0238 8040      		sbci r24,0
 821 023a 9040      		sbci r25,0
 822 023c 01F4      		brne 1b
 823 023e 00C0      		rjmp .
 824 0240 0000      		nop
 825               	.LVL62:
 826               	.LBE90:
 827               	.LBE89:
 372:setup.c       **** 	_delay_ms(50);
 373:setup.c       **** 	cs2Pin_high;
 828               		.loc 1 373 0
 829 0242 3A9A      		sbi 0x7,2
 374:setup.c       **** 	
 375:setup.c       **** 	// Light LED
 376:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 830               		.loc 1 376 0
 831 0244 939A      		sbi 0x12,3
 832               	.LVL63:
 833               	.LBB91:
 834               	.LBB92:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 835               		.loc 2 187 0
 836 0246 2FEF      		ldi r18,lo8(1599999)
 837 0248 89E6      		ldi r24,hi8(1599999)
 838 024a 98E1      		ldi r25,hlo8(1599999)
 839 024c 2150      	1:	subi r18,1
 840 024e 8040      		sbci r24,0
 841 0250 9040      		sbci r25,0
 842 0252 01F4      		brne 1b
 843 0254 00C0      		rjmp .
 844 0256 0000      		nop
 845               	.LVL64:
 846               	.LBE92:
 847               	.LBE91:
 377:setup.c       **** 	_delay_ms(500);
 378:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 848               		.loc 1 378 0
 849 0258 9398      		cbi 0x12,3
 379:setup.c       **** 	
 380:setup.c       **** 	// Setup USART
 381:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 850               		.loc 1 381 0
 851 025a 19B8      		out 0x9,__zero_reg__
 382:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 852               		.loc 1 382 0
 853 025c 539A      		sbi 0xa,3
 383:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 854               		.loc 1 383 0
 855 025e 549A      		sbi 0xa,4
 384:setup.c       **** 	
 385:setup.c       **** 	// Turn on interrupts
 386:setup.c       **** 	sei();
 856               		.loc 1 386 0
 857               	/* #APP */
 858               	 ;  386 "setup.c" 1
 859 0260 7894      		sei
 860               	 ;  0 "" 2
 861               	/* #NOAPP */
 862 0262 0895      		ret
 863               		.cfi_endproc
 864               	.LFE25:
 866               		.section	.text.startup,"ax",@progbits
 867               	.global	main
 869               	main:
 870               	.LFB26:
 871               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW Mini
   3:main.c        ****  PCB version: 1.0
   4:main.c        ****  Firmware version: R14
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 15/05/2019
   8:main.c        ****  
   9:main.c        ****  GBxCart RW Mini allows you to dump your Gameboy/Gameboy Colour games ROM, save the RAM, write to t
  10:main.c        ****  write to certain Gameboy flash carts. GBA carts are not supported, please check out the non-Mini v
  11:main.c        ****  
  12:main.c        ****  The ATmega8515 talks to the cartridge and interfaces with the CH340G serial to USB converter with 
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 16MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BO
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart Mini RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** 
  47:main.c        **** 
  48:main.c        **** #define F_CPU 16000000 // 16 MHz
  49:main.c        **** #define PCB_VERSION 100 // Mini v1.0
  50:main.c        **** #define FIRMWARE_VERSION 14
  51:main.c        **** 
  52:main.c        **** #include <avr/io.h>
  53:main.c        **** #include <avr/wdt.h>
  54:main.c        **** #include <avr/eeprom.h>
  55:main.c        **** #include <avr/interrupt.h>
  56:main.c        **** #include <avr/sleep.h>
  57:main.c        **** #include <util/delay.h>
  58:main.c        **** #include <stdlib.h>
  59:main.c        **** #include <string.h>
  60:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  61:main.c        **** 
  62:main.c        **** 
  63:main.c        **** int main(void) {
 872               		.loc 3 63 0
 873               		.cfi_startproc
 874               	/* prologue: function */
 875               	/* frame size = 0 */
 876               	/* stack size = 0 */
 877               	.L__stack_usage = 0
  64:main.c        **** 	setup();
 878               		.loc 3 64 0
 879 0000 00D0      		rcall setup
 880               	.LVL65:
  65:main.c        **** 	
  66:main.c        **** 	uint32_t address = 0;
  67:main.c        **** 	uint8_t resetCommonLines = 1;
 881               		.loc 3 67 0
 882 0002 5524      		clr r5
 883 0004 5394      		inc r5
  66:main.c        **** 	uint8_t resetCommonLines = 1;
 884               		.loc 3 66 0
 885 0006 C12C      		mov r12,__zero_reg__
 886 0008 D12C      		mov r13,__zero_reg__
 887 000a 7601      		movw r14,r12
 888               	.LBB93:
 889               	.LBB94:
 890               	.LBB95:
 891               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 892               		.loc 4 105 0
 893 000c 2224      		clr r2
 894 000e 2A94      		dec r2
 895 0010 322C      		mov r3,r2
 896               	.LBE95:
 897               	.LBE94:
 898               	.LBE93:
 899               	.LBB98:
  68:main.c        **** 	
  69:main.c        **** 	while(1) {
  70:main.c        **** 		if (resetCommonLines == 1) {
  71:main.c        **** 			rd_wr_csmreq_cs2_reset();
  72:main.c        **** 		}
  73:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  74:main.c        **** 		
  75:main.c        **** 		
  76:main.c        **** 		// Return the cart mode in use
  77:main.c        **** 		if (receivedChar == CART_MODE) {
  78:main.c        **** 			USART_Transmit(cartMode);
  79:main.c        **** 		}
  80:main.c        **** 		
  81:main.c        **** 		// Change to GB mode or GBA mode if requested
  82:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  83:main.c        **** 			gb_mode();
  84:main.c        **** 		}
  85:main.c        **** 		
  86:main.c        **** 		// Set address
  87:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
  88:main.c        **** 			usart_read_chars(); // Read start address
  89:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		
  93:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
  94:main.c        **** 		
  95:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
  96:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
  97:main.c        **** 			gb_mode();
  98:main.c        **** 			receivedChar = '1';
  99:main.c        **** 			while (receivedChar == '1') {
 100:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 101:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 102:main.c        **** 					USART_Transmit(read_8bit_data(address));
 103:main.c        **** 					address++;
 104:main.c        **** 				}
 105:main.c        **** 				
 106:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 107:main.c        **** 				receivedChar = USART_Receive();
 108:main.c        **** 			}
 109:main.c        **** 		}
 110:main.c        **** 		
 111:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 112:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 113:main.c        **** 			gb_mode();
 114:main.c        **** 			
 115:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 116:main.c        **** 			usart_read_bytes(64);
 117:main.c        **** 			
 118:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 119:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 120:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 121:main.c        **** 				address++;
 122:main.c        **** 			}
 123:main.c        **** 			
 124:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 125:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 126:main.c        **** 		}
 127:main.c        **** 		
 128:main.c        **** 		// Set bank address and write a byte
 129:main.c        **** 		else if (receivedChar == SET_BANK) {
 130:main.c        **** 			gb_mode();
 131:main.c        **** 			
 132:main.c        **** 			usart_read_chars(); // Read start address
 133:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 134:main.c        **** 			
 135:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 136:main.c        **** 			if (receivedChar == 'B') {
 137:main.c        **** 				usart_read_chars(); // Read data
 138:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 139:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 140:main.c        **** 				
 141:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 142:main.c        **** 			}
 143:main.c        **** 		}
 144:main.c        **** 		
 145:main.c        **** 		
 146:main.c        **** 		// ---------- GB FLASH CARTS ----------
 147:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 148:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 149:main.c        **** 			flashWriteWePin = USART_Receive();
 150:main.c        **** 			
 151:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 152:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 153:main.c        **** 				audioPin_high;
 154:main.c        **** 			}
 155:main.c        **** 		}
 156:main.c        **** 		
 157:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 158:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 159:main.c        **** 			flashBank1CommandWrites = 1;
 160:main.c        **** 		}
 161:main.c        **** 		
 162:main.c        **** 		// Load the program method to use
 163:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 164:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 165:main.c        **** 				usart_read_chars(); // Address
 166:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 167:main.c        **** 				USART_Transmit(SEND_ACK);
 168:main.c        **** 				
 169:main.c        **** 				usart_read_chars(); // Data
 170:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 171:main.c        **** 				USART_Transmit(SEND_ACK);
 172:main.c        **** 			}
 173:main.c        **** 		}
 174:main.c        **** 		
 175:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 176:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 177:main.c        **** 			usart_read_chars(); // Read address
 178:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 179:main.c        **** 			
 180:main.c        **** 			usart_read_chars(); // Read data byte
 181:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 182:main.c        **** 			
 183:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 184:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 185:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 186:main.c        **** 			
 187:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 188:main.c        **** 		}
 189:main.c        **** 		
 190:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 191:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 192:main.c        **** 			usart_read_bytes(64);
 193:main.c        **** 			
 194:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 195:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 196:main.c        **** 				if (flashBank1CommandWrites == 0) {
 197:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 198:main.c        **** 				}
 199:main.c        **** 				else { // Some flash carts need to change to bank 1 to issue flash commands
 200:main.c        **** 					gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 201:main.c        **** 				}
 202:main.c        **** 				address++;
 203:main.c        **** 			}
 204:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 205:main.c        **** 			
 206:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 207:main.c        **** 		}
 208:main.c        **** 		
 209:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 210:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 211:main.c        **** 			usart_read_bytes(32);
 212:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 213:main.c        **** 			
 214:main.c        **** 			// Setup buffered write
 215:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 216:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 217:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 218:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 219:main.c        **** 			_delay_us(1);
 220:main.c        **** 			
 221:main.c        **** 			// Write data
 222:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 223:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 224:main.c        **** 				address++;
 225:main.c        **** 			}
 226:main.c        **** 			
 227:main.c        **** 			// Write buffer to flash
 228:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 229:main.c        **** 			_delay_us(200);
 230:main.c        **** 			
 231:main.c        **** 			// Verify last byte written
 232:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 233:main.c        **** 			uint8_t verifyCount = 0;
 234:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 235:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 236:main.c        **** 				_delay_us(5);
 237:main.c        **** 				verifyCount++;
 238:main.c        **** 				if (verifyCount >= 200) {
 239:main.c        **** 					/*gb_flash_write_bus_cycle(0xAAA, 0xAA);
 240:main.c        **** 					gb_flash_write_bus_cycle(address, 0x55);
 241:main.c        **** 					gb_flash_write_bus_cycle(0x555, 0xF0);
 242:main.c        **** 					
 243:main.c        **** 					cs2Pin_low;
 244:main.c        **** 					_delay_ms(200);
 245:main.c        **** 					cs2Pin_high;
 246:main.c        **** 					_delay_ms(200);
 247:main.c        **** 					
 248:main.c        **** 					gb_flash_write_bus_cycle(0x555, 0xF0);*/
 249:main.c        **** 					
 250:main.c        **** 					_delay_ms(500);
 251:main.c        **** 					break;
 252:main.c        **** 				}
 253:main.c        **** 			}
 254:main.c        **** 			
 255:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 256:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 257:main.c        **** 		}
 258:main.c        **** 		
 259:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 260:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 261:main.c        **** 			usart_read_bytes(256);
 262:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 263:main.c        **** 			
 264:main.c        **** 			// Setup buffered write
 265:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 266:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 267:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 268:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 269:main.c        **** 			_delay_us(50);
 270:main.c        **** 			
 271:main.c        **** 			// Write data
 272:main.c        **** 			for (int x = 0; x < 256; x++) {
 273:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 274:main.c        **** 				address++;
 275:main.c        **** 			}
 276:main.c        **** 			
 277:main.c        **** 			// Write buffer to flash
 278:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 279:main.c        **** 			
 280:main.c        **** 			// Verify last byte written
 281:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 282:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 283:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 284:main.c        **** 				_delay_us(5);
 285:main.c        **** 			}
 286:main.c        **** 			
 287:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 288:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 289:main.c        **** 		}
 290:main.c        **** 		
 291:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 292:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 293:main.c        **** 			usart_read_bytes(128);
 294:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 295:main.c        **** 			
 296:main.c        **** 			// Enable flash chip access
 297:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 298:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 299:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 300:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 301:main.c        **** 			_delay_us(5);
 302:main.c        **** 			
 303:main.c        **** 			// Re-Enable writes to MBC registers
 304:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 305:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 306:main.c        **** 			_delay_us(5);
 307:main.c        **** 			
 308:main.c        **** 			// Bank 1 for commands
 309:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 310:main.c        **** 			_delay_us(5);
 311:main.c        **** 			
 312:main.c        **** 			
 313:main.c        **** 			// Write setup
 314:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 315:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 316:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 317:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 318:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 319:main.c        **** 			_delay_us(5);
 320:main.c        **** 			
 321:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 322:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 323:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 324:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 325:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 326:main.c        **** 			_delay_us(5);
 327:main.c        **** 			
 328:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 329:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 330:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 331:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 332:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 333:main.c        **** 			_delay_us(5);
 334:main.c        **** 			
 335:main.c        **** 			// Set bank back
 336:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 337:main.c        **** 			_delay_us(5);
 338:main.c        **** 			
 339:main.c        **** 			// Disable writes to MBC registers
 340:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 341:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 342:main.c        **** 			_delay_us(5);
 343:main.c        **** 			
 344:main.c        **** 			// Undo Wakeup
 345:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 346:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 347:main.c        **** 			_delay_us(5);
 348:main.c        **** 			
 349:main.c        **** 			
 350:main.c        **** 			// Write data
 351:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 352:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 353:main.c        **** 				_delay_us(5);
 354:main.c        **** 				address++;
 355:main.c        **** 			}
 356:main.c        **** 			
 357:main.c        **** 			// Write buffer to flash
 358:main.c        **** 			address--;
 359:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 360:main.c        **** 			address++;
 361:main.c        **** 			_delay_ms(10);
 362:main.c        **** 			
 363:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 364:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 365:main.c        **** 		}
 366:main.c        **** 		
 367:main.c        **** 		
 368:main.c        **** 		// ---------- General commands ----------
 369:main.c        **** 		// Set any pin as input/output
 370:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 371:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 372:main.c        **** 			char portChar = USART_Receive();
 373:main.c        **** 			usart_read_chars();
 374:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 375:main.c        **** 			
 376:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 377:main.c        **** 			if (receivedChar == SET_INPUT) {
 378:main.c        **** 				if (portChar == 'A') {
 379:main.c        **** 					DDRA &= ~(setValue);
 380:main.c        **** 				}
 381:main.c        **** 				else if (portChar == 'B') {
 382:main.c        **** 					DDRB &= ~(setValue);
 383:main.c        **** 				}
 384:main.c        **** 				else if (portChar == 'C') {
 385:main.c        **** 					DDRC &= ~(setValue);
 386:main.c        **** 				}
 387:main.c        **** 				else if (portChar == 'D') {
 388:main.c        **** 					DDRD &= ~(setValue);
 389:main.c        **** 				}
 390:main.c        **** 				else if (portChar == 'E') {
 391:main.c        **** 					DDRE &= ~(setValue);
 392:main.c        **** 				}
 393:main.c        **** 			}
 394:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 395:main.c        **** 				if (portChar == 'A') {
 396:main.c        **** 					DDRA |= (setValue);
 397:main.c        **** 				}
 398:main.c        **** 				else if (portChar == 'B') {
 399:main.c        **** 					DDRB |= (setValue);
 400:main.c        **** 				}
 401:main.c        **** 				else if (portChar == 'C') {
 402:main.c        **** 					DDRC |= (setValue);
 403:main.c        **** 				}
 404:main.c        **** 				else if (portChar == 'D') {
 405:main.c        **** 					DDRD |= (setValue);
 406:main.c        **** 				}
 407:main.c        **** 				else if (portChar == 'E') {
 408:main.c        **** 					DDRE |= (setValue);
 409:main.c        **** 				}
 410:main.c        **** 			}
 411:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 412:main.c        **** 		}
 413:main.c        **** 		
 414:main.c        **** 		// Set pin output as low
 415:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 416:main.c        **** 			char portChar = USART_Receive();			
 417:main.c        **** 			usart_read_chars();
 418:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 419:main.c        **** 			
 420:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 421:main.c        **** 			if (portChar == 'A') {
 422:main.c        **** 				PORTA &= ~(setValue);
 423:main.c        **** 			}
 424:main.c        **** 			else if (portChar == 'B') {
 425:main.c        **** 				PORTB &= ~(setValue);
 426:main.c        **** 			}
 427:main.c        **** 			else if (portChar == 'C') {
 428:main.c        **** 				PORTC &= ~(setValue);
 429:main.c        **** 			}
 430:main.c        **** 			else if (portChar == 'D') {
 431:main.c        **** 				PORTD &= ~(setValue);
 432:main.c        **** 			}
 433:main.c        **** 			else if (portChar == 'E') {
 434:main.c        **** 				PORTE &= ~(setValue);
 435:main.c        **** 			}
 436:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 437:main.c        **** 		}
 438:main.c        **** 		
 439:main.c        **** 		// Set pin output as high
 440:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 441:main.c        **** 			char portChar = USART_Receive();			
 442:main.c        **** 			usart_read_chars();
 443:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 444:main.c        **** 			
 445:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 446:main.c        **** 			if (portChar == 'A') {
 447:main.c        **** 				PORTA |= (setValue);
 448:main.c        **** 			}
 449:main.c        **** 			else if (portChar == 'B') {
 450:main.c        **** 				PORTB |= (setValue);
 451:main.c        **** 			}
 452:main.c        **** 			else if (portChar == 'C') {
 453:main.c        **** 				PORTC |= (setValue);
 454:main.c        **** 			}
 455:main.c        **** 			else if (portChar == 'D') {
 456:main.c        **** 				PORTD |= (setValue);
 457:main.c        **** 			}
 458:main.c        **** 			else if (portChar == 'E') {
 459:main.c        **** 				PORTE |= (setValue);
 460:main.c        **** 			}
 461:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 462:main.c        **** 		}
 463:main.c        **** 		
 464:main.c        **** 		// Read all pins of a PORT and return the value
 465:main.c        **** 		else if (receivedChar == READ_INPUT) {
 466:main.c        **** 			char portChar = USART_Receive();			
 467:main.c        **** 			
 468:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 469:main.c        **** 			if (portChar == 'A') {
 470:main.c        **** 				USART_Transmit(PINA);
 471:main.c        **** 			}
 472:main.c        **** 			else if (portChar == 'B') {
 473:main.c        **** 				USART_Transmit(PINB);
 474:main.c        **** 			}
 475:main.c        **** 			else if (portChar == 'C') {
 476:main.c        **** 				USART_Transmit(PINC);
 477:main.c        **** 			}
 478:main.c        **** 			else if (portChar == 'D') {
 479:main.c        **** 				USART_Transmit(PIND);
 480:main.c        **** 			}
 481:main.c        **** 			else if (portChar == 'E') {
 482:main.c        **** 				USART_Transmit(PINE);
 483:main.c        **** 			}
 484:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 485:main.c        **** 		}
 486:main.c        **** 		
 487:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 488:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 489:main.c        **** 			char commonChar = USART_Receive();
 490:main.c        **** 			if (commonChar == '1') {
 491:main.c        **** 				resetCommonLines = 1;
 900               		.loc 3 491 0
 901 0012 4424      		clr r4
 902 0014 4394      		inc r4
 903 0016 20E0      		ldi r18,lo8(receivedBuffer+128)
 904 0018 622E      		mov r6,r18
 905 001a 20E0      		ldi r18,hi8(receivedBuffer+128)
 906 001c 722E      		mov r7,r18
 907               	.LVL66:
 908               	.L37:
 909               	.LBE98:
  70:main.c        **** 			rd_wr_csmreq_cs2_reset();
 910               		.loc 3 70 0
 911 001e 21E0      		ldi r18,lo8(1)
 912 0020 5212      		cpse r5,r18
 913 0022 00C0      		rjmp .L38
 914               	.LVL67:
 915               	.L115:
  71:main.c        **** 		}
 916               		.loc 3 71 0
 917 0024 00D0      		rcall rd_wr_csmreq_cs2_reset
 918               	.LVL68:
 919               	.L38:
  73:main.c        **** 		
 920               		.loc 3 73 0
 921 0026 00D0      		rcall USART_Receive
 922               	.LVL69:
 923 0028 8093 0000 		sts receivedChar,r24
  77:main.c        **** 			USART_Transmit(cartMode);
 924               		.loc 3 77 0
 925 002c 8334      		cpi r24,lo8(67)
 926 002e 01F4      		brne .L39
  78:main.c        **** 		}
 927               		.loc 3 78 0
 928 0030 8091 0000 		lds r24,cartMode
 929 0034 00C0      		rjmp .L116
 930               	.L39:
  82:main.c        **** 			gb_mode();
 931               		.loc 3 82 0
 932 0036 8734      		cpi r24,lo8(71)
 933 0038 01F4      		brne .L41
  83:main.c        **** 		}
 934               		.loc 3 83 0
 935 003a 00D0      		rcall gb_mode
 936               	.LVL70:
 937 003c 00C0      		rjmp .L37
 938               	.L41:
  87:main.c        **** 			usart_read_chars(); // Read start address
 939               		.loc 3 87 0
 940 003e 8134      		cpi r24,lo8(65)
 941 0040 01F4      		brne .L42
  88:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 942               		.loc 3 88 0
 943 0042 00D0      		rcall usart_read_chars
 944               	.LVL71:
  89:main.c        **** 		}
 945               		.loc 3 89 0
 946 0044 40E1      		ldi r20,lo8(16)
 947 0046 50E0      		ldi r21,0
 948 0048 60E0      		ldi r22,0
 949 004a 70E0      		ldi r23,0
 950 004c 80E0      		ldi r24,lo8(receivedBuffer)
 951 004e 90E0      		ldi r25,hi8(receivedBuffer)
 952 0050 00D0      		rcall strtol
 953               	.LVL72:
 954 0052 6B01      		movw r12,r22
 955 0054 7C01      		movw r14,r24
 956               	.LVL73:
 957 0056 00C0      		rjmp .L37
 958               	.L42:
  96:main.c        **** 			gb_mode();
 959               		.loc 3 96 0
 960 0058 8235      		cpi r24,lo8(82)
 961 005a 01F4      		brne .L43
  97:main.c        **** 			receivedChar = '1';
 962               		.loc 3 97 0
 963 005c 00D0      		rcall gb_mode
 964               	.LVL74:
  98:main.c        **** 			while (receivedChar == '1') {
 965               		.loc 3 98 0
 966 005e 81E3      		ldi r24,lo8(49)
 967               	.LVL75:
 968               	.L118:
 107:main.c        **** 			}
 969               		.loc 3 107 0
 970 0060 8093 0000 		sts receivedChar,r24
 971               	.LVL76:
  99:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 972               		.loc 3 99 0
 973 0064 8091 0000 		lds r24,receivedChar
 974 0068 8133      		cpi r24,lo8(49)
 975 006a 01F4      		brne .L37
 100:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 976               		.loc 3 100 0
 977 006c 939A      		sbi 0x12,3
 978               	.LVL77:
 979 006e C0E0      		ldi r28,0
 980 0070 D0E0      		ldi r29,0
 981               	.LVL78:
 982               	.L45:
 983               	.LBB99:
 102:main.c        **** 					address++;
 984               		.loc 3 102 0 discriminator 3
 985 0072 CE01      		movw r24,r28
 986 0074 8C0D      		add r24,r12
 987 0076 9D1D      		adc r25,r13
 988 0078 00D0      		rcall read_8bit_data
 989               	.LVL79:
 990 007a 00D0      		rcall USART_Transmit
 991               	.LVL80:
 992 007c 2196      		adiw r28,1
 993               	.LVL81:
 101:main.c        **** 					USART_Transmit(read_8bit_data(address));
 994               		.loc 3 101 0 discriminator 3
 995 007e C034      		cpi r28,64
 996 0080 D105      		cpc r29,__zero_reg__
 997 0082 01F4      		brne .L45
 998 0084 80E4      		ldi r24,64
 999 0086 C80E      		add r12,r24
 1000 0088 D11C      		adc r13,__zero_reg__
 1001 008a E11C      		adc r14,__zero_reg__
 1002 008c F11C      		adc r15,__zero_reg__
 1003               	.LBE99:
 106:main.c        **** 				receivedChar = USART_Receive();
 1004               		.loc 3 106 0
 1005 008e 9398      		cbi 0x12,3
 107:main.c        **** 			}
 1006               		.loc 3 107 0
 1007 0090 00D0      		rcall USART_Receive
 1008               	.LVL82:
 1009 0092 00C0      		rjmp .L118
 1010               	.LVL83:
 1011               	.L43:
 112:main.c        **** 			gb_mode();
 1012               		.loc 3 112 0
 1013 0094 8735      		cpi r24,lo8(87)
 1014 0096 01F4      		brne .L47
 113:main.c        **** 			
 1015               		.loc 3 113 0
 1016 0098 00D0      		rcall gb_mode
 1017               	.LVL84:
 116:main.c        **** 			
 1018               		.loc 3 116 0
 1019 009a 80E4      		ldi r24,lo8(64)
 1020 009c 90E0      		ldi r25,0
 1021 009e 00D0      		rcall usart_read_bytes
 1022               	.LVL85:
 118:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1023               		.loc 3 118 0
 1024 00a0 939A      		sbi 0x12,3
 1025               	.LVL86:
 1026 00a2 00E0      		ldi r16,lo8(receivedBuffer)
 1027 00a4 10E0      		ldi r17,hi8(receivedBuffer)
 1028 00a6 C0E0      		ldi r28,0
 1029 00a8 D0E0      		ldi r29,0
 1030               	.LVL87:
 1031               	.L48:
 1032               	.LBB100:
 120:main.c        **** 				address++;
 1033               		.loc 3 120 0 discriminator 3
 1034 00aa F801      		movw r30,r16
 1035 00ac 6191      		ld r22,Z+
 1036 00ae 8F01      		movw r16,r30
 1037 00b0 CE01      		movw r24,r28
 1038 00b2 8C0D      		add r24,r12
 1039 00b4 9D1D      		adc r25,r13
 1040 00b6 41E0      		ldi r20,lo8(1)
 1041 00b8 00D0      		rcall write_8bit_data
 1042               	.LVL88:
 1043 00ba 2196      		adiw r28,1
 1044               	.LVL89:
 119:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 1045               		.loc 3 119 0 discriminator 3
 1046 00bc C034      		cpi r28,64
 1047 00be D105      		cpc r29,__zero_reg__
 1048 00c0 01F4      		brne .L48
 1049 00c2 F0E4      		ldi r31,64
 1050 00c4 CF0E      		add r12,r31
 1051 00c6 D11C      		adc r13,__zero_reg__
 1052 00c8 E11C      		adc r14,__zero_reg__
 1053 00ca F11C      		adc r15,__zero_reg__
 1054 00cc 00C0      		rjmp .L130
 1055               	.LVL90:
 1056               	.L47:
 1057               	.LBE100:
 129:main.c        **** 			gb_mode();
 1058               		.loc 3 129 0
 1059 00ce 8234      		cpi r24,lo8(66)
 1060 00d0 01F4      		brne .L49
 1061               	.LBB101:
 130:main.c        **** 			
 1062               		.loc 3 130 0
 1063 00d2 00D0      		rcall gb_mode
 1064               	.LVL91:
 132:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1065               		.loc 3 132 0
 1066 00d4 00D0      		rcall usart_read_chars
 1067               	.LVL92:
 133:main.c        **** 			
 1068               		.loc 3 133 0
 1069 00d6 40E1      		ldi r20,lo8(16)
 1070 00d8 50E0      		ldi r21,0
 1071 00da 60E0      		ldi r22,0
 1072 00dc 70E0      		ldi r23,0
 1073 00de 80E0      		ldi r24,lo8(receivedBuffer)
 1074 00e0 90E0      		ldi r25,hi8(receivedBuffer)
 1075 00e2 00D0      		rcall strtol
 1076               	.LVL93:
 1077 00e4 4B01      		movw r8,r22
 1078 00e6 5C01      		movw r10,r24
 1079               	.LVL94:
 135:main.c        **** 			if (receivedChar == 'B') {
 1080               		.loc 3 135 0
 1081 00e8 00D0      		rcall USART_Receive
 1082               	.LVL95:
 1083 00ea 8093 0000 		sts receivedChar,r24
 136:main.c        **** 				usart_read_chars(); // Read data
 1084               		.loc 3 136 0
 1085 00ee 8234      		cpi r24,lo8(66)
 1086 00f0 01F0      		breq .+2
 1087 00f2 00C0      		rjmp .L37
 1088               	.LBB102:
 137:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 1089               		.loc 3 137 0
 1090 00f4 00D0      		rcall usart_read_chars
 1091               	.LVL96:
 138:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 1092               		.loc 3 138 0
 1093 00f6 80E0      		ldi r24,lo8(receivedBuffer)
 1094 00f8 90E0      		ldi r25,hi8(receivedBuffer)
 1095 00fa 00D0      		rcall atoi
 1096               	.LVL97:
 139:main.c        **** 				
 1097               		.loc 3 139 0
 1098 00fc 8093 0000 		sts lastBankAccessed,r24
 141:main.c        **** 			}
 1099               		.loc 3 141 0
 1100 0100 40E0      		ldi r20,0
 1101 0102 682F      		mov r22,r24
 1102 0104 C401      		movw r24,r8
 1103               	.LVL98:
 1104 0106 00D0      		rcall write_8bit_data
 1105               	.LVL99:
 1106 0108 00C0      		rjmp .L37
 1107               	.LVL100:
 1108               	.L49:
 1109               	.LBE102:
 1110               	.LBE101:
 148:main.c        **** 			flashWriteWePin = USART_Receive();
 1111               		.loc 3 148 0
 1112 010a 8035      		cpi r24,lo8(80)
 1113 010c 01F4      		brne .L50
 149:main.c        **** 			
 1114               		.loc 3 149 0
 1115 010e 00D0      		rcall USART_Receive
 1116               	.LVL101:
 1117 0110 8093 0000 		sts flashWriteWePin,r24
 151:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 1118               		.loc 3 151 0
 1119 0114 8134      		cpi r24,lo8(65)
 1120 0116 01F0      		breq .+2
 1121 0118 00C0      		rjmp .L37
 152:main.c        **** 				audioPin_high;
 1122               		.loc 3 152 0
 1123 011a 319A      		sbi 0x6,1
 153:main.c        **** 			}
 1124               		.loc 3 153 0
 1125 011c 399A      		sbi 0x7,1
 1126 011e 00C0      		rjmp .L37
 1127               	.L50:
 158:main.c        **** 			flashBank1CommandWrites = 1;
 1128               		.loc 3 158 0
 1129 0120 8E34      		cpi r24,lo8(78)
 1130 0122 01F4      		brne .L51
 159:main.c        **** 		}
 1131               		.loc 3 159 0
 1132 0124 4092 0000 		sts flashBank1CommandWrites,r4
 1133 0128 00C0      		rjmp .L37
 1134               	.L51:
 163:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 1135               		.loc 3 163 0
 1136 012a 8534      		cpi r24,lo8(69)
 1137 012c 01F4      		brne .L52
 1138 012e C0E0      		ldi r28,lo8(flashWriteCycle)
 1139 0130 D0E0      		ldi r29,hi8(flashWriteCycle)
 1140               	.L53:
 1141               	.LBB103:
 165:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 1142               		.loc 3 165 0 discriminator 3
 1143 0132 00D0      		rcall usart_read_chars
 1144               	.LVL102:
 166:main.c        **** 				USART_Transmit(SEND_ACK);
 1145               		.loc 3 166 0 discriminator 3
 1146 0134 40E1      		ldi r20,lo8(16)
 1147 0136 50E0      		ldi r21,0
 1148 0138 60E0      		ldi r22,0
 1149 013a 70E0      		ldi r23,0
 1150 013c 80E0      		ldi r24,lo8(receivedBuffer)
 1151 013e 90E0      		ldi r25,hi8(receivedBuffer)
 1152 0140 00D0      		rcall strtol
 1153               	.LVL103:
 1154 0142 7983      		std Y+1,r23
 1155 0144 6883      		st Y,r22
 167:main.c        **** 				
 1156               		.loc 3 167 0 discriminator 3
 1157 0146 81E3      		ldi r24,lo8(49)
 1158 0148 00D0      		rcall USART_Transmit
 1159               	.LVL104:
 169:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 1160               		.loc 3 169 0 discriminator 3
 1161 014a 00D0      		rcall usart_read_chars
 1162               	.LVL105:
 170:main.c        **** 				USART_Transmit(SEND_ACK);
 1163               		.loc 3 170 0 discriminator 3
 1164 014c 40E1      		ldi r20,lo8(16)
 1165 014e 50E0      		ldi r21,0
 1166 0150 60E0      		ldi r22,0
 1167 0152 70E0      		ldi r23,0
 1168 0154 80E0      		ldi r24,lo8(receivedBuffer)
 1169 0156 90E0      		ldi r25,hi8(receivedBuffer)
 1170 0158 00D0      		rcall strtol
 1171               	.LVL106:
 1172 015a 7B83      		std Y+3,r23
 1173 015c 6A83      		std Y+2,r22
 171:main.c        **** 			}
 1174               		.loc 3 171 0 discriminator 3
 1175 015e 81E3      		ldi r24,lo8(49)
 1176 0160 00D0      		rcall USART_Transmit
 1177               	.LVL107:
 1178 0162 2496      		adiw r28,4
 164:main.c        **** 				usart_read_chars(); // Address
 1179               		.loc 3 164 0 discriminator 3
 1180 0164 80E0      		ldi r24,lo8(flashWriteCycle+12)
 1181 0166 90E0      		ldi r25,hi8(flashWriteCycle+12)
 1182 0168 8C17      		cp r24,r28
 1183 016a 9D07      		cpc r25,r29
 1184 016c 01F4      		brne .L53
 1185 016e 00C0      		rjmp .L37
 1186               	.L52:
 1187               	.LBE103:
 176:main.c        **** 			usart_read_chars(); // Read address
 1188               		.loc 3 176 0
 1189 0170 8634      		cpi r24,lo8(70)
 1190 0172 01F4      		brne .L54
 1191               	.LBB104:
 177:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 1192               		.loc 3 177 0
 1193 0174 00D0      		rcall usart_read_chars
 1194               	.LVL108:
 178:main.c        **** 			
 1195               		.loc 3 178 0
 1196 0176 40E1      		ldi r20,lo8(16)
 1197 0178 50E0      		ldi r21,0
 1198 017a 60E0      		ldi r22,0
 1199 017c 70E0      		ldi r23,0
 1200 017e 80E0      		ldi r24,lo8(receivedBuffer)
 1201 0180 90E0      		ldi r25,hi8(receivedBuffer)
 1202 0182 00D0      		rcall strtol
 1203               	.LVL109:
 1204 0184 4B01      		movw r8,r22
 1205 0186 5C01      		movw r10,r24
 1206               	.LVL110:
 180:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 1207               		.loc 3 180 0
 1208 0188 00D0      		rcall usart_read_chars
 1209               	.LVL111:
 181:main.c        **** 			
 1210               		.loc 3 181 0
 1211 018a 40E1      		ldi r20,lo8(16)
 1212 018c 50E0      		ldi r21,0
 1213 018e 60E0      		ldi r22,0
 1214 0190 70E0      		ldi r23,0
 1215 0192 80E0      		ldi r24,lo8(receivedBuffer)
 1216 0194 90E0      		ldi r25,hi8(receivedBuffer)
 1217 0196 00D0      		rcall strtol
 1218               	.LVL112:
 183:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 1219               		.loc 3 183 0
 1220 0198 939A      		sbi 0x12,3
 184:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 1221               		.loc 3 184 0
 1222 019a C401      		movw r24,r8
 1223 019c 00D0      		rcall gb_flash_write_bus_cycle
 1224               	.LVL113:
 1225               	.L130:
 185:main.c        **** 			
 1226               		.loc 3 185 0
 1227 019e 9398      		cbi 0x12,3
 187:main.c        **** 		}
 1228               		.loc 3 187 0
 1229 01a0 81E3      		ldi r24,lo8(49)
 1230 01a2 00C0      		rjmp .L116
 1231               	.LVL114:
 1232               	.L54:
 1233               	.LBE104:
 191:main.c        **** 			usart_read_bytes(64);
 1234               		.loc 3 191 0
 1235 01a4 8435      		cpi r24,lo8(84)
 1236 01a6 01F4      		brne .L55
 192:main.c        **** 			
 1237               		.loc 3 192 0
 1238 01a8 80E4      		ldi r24,lo8(64)
 1239 01aa 90E0      		ldi r25,0
 1240 01ac 00D0      		rcall usart_read_bytes
 1241               	.LVL115:
 194:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1242               		.loc 3 194 0
 1243 01ae 939A      		sbi 0x12,3
 1244               	.LVL116:
 1245 01b0 C0E0      		ldi r28,lo8(receivedBuffer)
 1246 01b2 D0E0      		ldi r29,hi8(receivedBuffer)
 1247 01b4 80E4      		ldi r24,lo8(64)
 1248 01b6 B82E      		mov r11,r24
 1249 01b8 8601      		movw r16,r12
 1250 01ba 0050      		subi r16,lo8(receivedBuffer)
 1251 01bc 1040      		sbci r17,hi8(receivedBuffer)
 1252               	.LVL117:
 1253               	.L58:
 1254               	.LBB105:
 196:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 1255               		.loc 3 196 0
 1256 01be 8091 0000 		lds r24,flashBank1CommandWrites
 197:main.c        **** 				}
 1257               		.loc 3 197 0
 1258 01c2 6881      		ld r22,Y
 196:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 1259               		.loc 3 196 0
 1260 01c4 8111      		cpse r24,__zero_reg__
 1261 01c6 00C0      		rjmp .L56
 197:main.c        **** 				}
 1262               		.loc 3 197 0
 1263 01c8 C801      		movw r24,r16
 1264 01ca 8C0F      		add r24,r28
 1265 01cc 9D1F      		adc r25,r29
 1266 01ce 00D0      		rcall gb_flash_write_byte
 1267               	.LVL118:
 1268 01d0 00C0      		rjmp .L57
 1269               	.L56:
 200:main.c        **** 				}
 1270               		.loc 3 200 0
 1271 01d2 C801      		movw r24,r16
 1272 01d4 8C0F      		add r24,r28
 1273 01d6 9D1F      		adc r25,r29
 1274 01d8 00D0      		rcall gb_flash_write_byte_bank1_commands
 1275               	.LVL119:
 1276               	.L57:
 1277 01da BA94      		dec r11
 1278 01dc 2196      		adiw r28,1
 1279               	.LVL120:
 195:main.c        **** 				if (flashBank1CommandWrites == 0) {
 1280               		.loc 3 195 0 discriminator 2
 1281 01de B110      		cpse r11,__zero_reg__
 1282 01e0 00C0      		rjmp .L58
 1283 01e2 90E4      		ldi r25,64
 1284 01e4 C90E      		add r12,r25
 1285 01e6 D11C      		adc r13,__zero_reg__
 1286 01e8 E11C      		adc r14,__zero_reg__
 1287 01ea F11C      		adc r15,__zero_reg__
 1288 01ec 00C0      		rjmp .L119
 1289               	.LVL121:
 1290               	.L55:
 1291               	.LBE105:
 210:main.c        **** 			usart_read_bytes(32);
 1292               		.loc 3 210 0
 1293 01ee 8935      		cpi r24,lo8(89)
 1294 01f0 01F0      		breq .+2
 1295 01f2 00C0      		rjmp .L59
 1296               	.LBB106:
 211:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1297               		.loc 3 211 0
 1298 01f4 80E2      		ldi r24,lo8(32)
 1299 01f6 90E0      		ldi r25,0
 1300 01f8 00D0      		rcall usart_read_bytes
 1301               	.LVL122:
 212:main.c        **** 			
 1302               		.loc 3 212 0
 1303 01fa 939A      		sbi 0x12,3
 215:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 1304               		.loc 3 215 0
 1305 01fc 6AEA      		ldi r22,lo8(-86)
 1306 01fe 8AEA      		ldi r24,lo8(-86)
 1307 0200 9AE0      		ldi r25,lo8(10)
 1308 0202 00D0      		rcall gb_flash_write_bus_cycle
 1309               	.LVL123:
 216:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 1310               		.loc 3 216 0
 1311 0204 65E5      		ldi r22,lo8(85)
 1312 0206 85E5      		ldi r24,lo8(85)
 1313 0208 95E0      		ldi r25,lo8(5)
 1314 020a 00D0      		rcall gb_flash_write_bus_cycle
 1315               	.LVL124:
 217:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 1316               		.loc 3 217 0
 1317 020c 5601      		movw r10,r12
 1318 020e 65E2      		ldi r22,lo8(37)
 1319 0210 C601      		movw r24,r12
 1320 0212 00D0      		rcall gb_flash_write_bus_cycle
 1321               	.LVL125:
 218:main.c        **** 			_delay_us(1);
 1322               		.loc 3 218 0
 1323 0214 6FE1      		ldi r22,lo8(31)
 1324 0216 C601      		movw r24,r12
 1325 0218 00D0      		rcall gb_flash_write_bus_cycle
 1326               	.LVL126:
 1327               	.LBB107:
 1328               	.LBB108:
 1329               		.loc 2 276 0
 1330 021a E5E0      		ldi r30,lo8(5)
 1331 021c EA95      	1:	dec r30
 1332 021e 01F4      		brne 1b
 1333 0220 0000      		nop
 1334               	.LVL127:
 1335 0222 00E0      		ldi r16,lo8(receivedBuffer)
 1336 0224 10E0      		ldi r17,hi8(receivedBuffer)
 1337 0226 C0E0      		ldi r28,0
 1338 0228 D0E0      		ldi r29,0
 1339               	.LVL128:
 1340               	.L60:
 1341               	.LBE108:
 1342               	.LBE107:
 1343               	.LBB109:
 223:main.c        **** 				address++;
 1344               		.loc 3 223 0 discriminator 3
 1345 022a F801      		movw r30,r16
 1346 022c 6191      		ld r22,Z+
 1347 022e 8F01      		movw r16,r30
 1348 0230 CE01      		movw r24,r28
 1349 0232 8A0D      		add r24,r10
 1350 0234 9B1D      		adc r25,r11
 1351 0236 00D0      		rcall gb_flash_write_bus_cycle
 1352               	.LVL129:
 1353 0238 2196      		adiw r28,1
 1354               	.LVL130:
 222:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1355               		.loc 3 222 0 discriminator 3
 1356 023a C032      		cpi r28,32
 1357 023c D105      		cpc r29,__zero_reg__
 1358 023e 01F4      		brne .L60
 1359 0240 F0E2      		ldi r31,32
 1360 0242 CF0E      		add r12,r31
 1361 0244 D11C      		adc r13,__zero_reg__
 1362 0246 E11C      		adc r14,__zero_reg__
 1363 0248 F11C      		adc r15,__zero_reg__
 1364               	.LBE109:
 228:main.c        **** 			_delay_us(200);
 1365               		.loc 3 228 0
 1366 024a C601      		movw r24,r12
 1367 024c 8097      		sbiw r24,32
 1368 024e 69E2      		ldi r22,lo8(41)
 1369 0250 00D0      		rcall gb_flash_write_bus_cycle
 1370               	.LVL131:
 1371               	.LBB110:
 1372               	.LBB111:
 1373               		.loc 2 276 0
 1374 0252 8FE1      		ldi r24,lo8(799)
 1375 0254 93E0      		ldi r25,hi8(799)
 1376 0256 0197      	1:	sbiw r24,1
 1377 0258 01F4      		brne 1b
 1378 025a 00C0      		rjmp .
 1379 025c 0000      		nop
 1380               	.LVL132:
 1381               	.LBE111:
 1382               	.LBE110:
 232:main.c        **** 			uint8_t verifyCount = 0;
 1383               		.loc 3 232 0
 1384 025e E601      		movw r28,r12
 1385               	.LVL133:
 1386 0260 2197      		sbiw r28,1
 1387 0262 CE01      		movw r24,r28
 1388 0264 00D0      		rcall gb_flash_read_byte
 1389               	.LVL134:
 234:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 1390               		.loc 3 234 0
 1391 0266 18EC      		ldi r17,lo8(-56)
 1392               	.LVL135:
 1393               	.L61:
 1394 0268 9091 0000 		lds r25,receivedBuffer+31
 1395 026c 8917      		cp r24,r25
 1396 026e 01F4      		brne .+2
 1397 0270 00C0      		rjmp .L119
 235:main.c        **** 				_delay_us(5);
 1398               		.loc 3 235 0
 1399 0272 CE01      		movw r24,r28
 1400               	.LVL136:
 1401 0274 00D0      		rcall gb_flash_read_byte
 1402               	.LVL137:
 1403               	.LBB112:
 1404               	.LBB113:
 1405               		.loc 2 276 0
 1406 0276 9AE1      		ldi r25,lo8(26)
 1407 0278 9A95      	1:	dec r25
 1408 027a 01F4      		brne 1b
 1409 027c 00C0      		rjmp .
 1410               	.LVL138:
 1411 027e 1150      		subi r17,lo8(-(-1))
 1412               	.LVL139:
 1413               	.LBE113:
 1414               	.LBE112:
 238:main.c        **** 					/*gb_flash_write_bus_cycle(0xAAA, 0xAA);
 1415               		.loc 3 238 0
 1416 0280 01F4      		brne .L61
 1417               	.LVL140:
 1418               	.LBB114:
 1419               	.LBB115:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1420               		.loc 2 187 0
 1421 0282 EFEF      		ldi r30,lo8(1599999)
 1422 0284 F9E6      		ldi r31,hi8(1599999)
 1423 0286 28E1      		ldi r18,hlo8(1599999)
 1424 0288 E150      	1:	subi r30,1
 1425 028a F040      		sbci r31,0
 1426 028c 2040      		sbci r18,0
 1427 028e 01F4      		brne 1b
 1428 0290 00C0      		rjmp .L131
 1429               	.LVL141:
 1430               	.L59:
 1431               	.LBE115:
 1432               	.LBE114:
 1433               	.LBE106:
 260:main.c        **** 			usart_read_bytes(256);
 1434               		.loc 3 260 0
 1435 0292 8835      		cpi r24,lo8(88)
 1436 0294 01F0      		breq .+2
 1437 0296 00C0      		rjmp .L64
 1438               	.LBB116:
 261:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1439               		.loc 3 261 0
 1440 0298 80E0      		ldi r24,0
 1441 029a 91E0      		ldi r25,lo8(1)
 1442 029c 00D0      		rcall usart_read_bytes
 1443               	.LVL142:
 262:main.c        **** 			
 1444               		.loc 3 262 0
 1445 029e 939A      		sbi 0x12,3
 265:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 1446               		.loc 3 265 0
 1447 02a0 69EA      		ldi r22,lo8(-87)
 1448 02a2 8AEA      		ldi r24,lo8(-86)
 1449 02a4 9AE0      		ldi r25,lo8(10)
 1450 02a6 00D0      		rcall gb_flash_write_bus_cycle
 1451               	.LVL143:
 266:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 1452               		.loc 3 266 0
 1453 02a8 66E5      		ldi r22,lo8(86)
 1454 02aa 85E5      		ldi r24,lo8(85)
 1455 02ac 95E0      		ldi r25,lo8(5)
 1456 02ae 00D0      		rcall gb_flash_write_bus_cycle
 1457               	.LVL144:
 267:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 1458               		.loc 3 267 0
 1459 02b0 5601      		movw r10,r12
 1460 02b2 66E2      		ldi r22,lo8(38)
 1461 02b4 C601      		movw r24,r12
 1462 02b6 00D0      		rcall gb_flash_write_bus_cycle
 1463               	.LVL145:
 268:main.c        **** 			_delay_us(50);
 1464               		.loc 3 268 0
 1465 02b8 6FEF      		ldi r22,lo8(-1)
 1466 02ba C601      		movw r24,r12
 1467 02bc 00D0      		rcall gb_flash_write_bus_cycle
 1468               	.LVL146:
 1469               	.LBB117:
 1470               	.LBB118:
 1471               		.loc 2 276 0
 1472 02be 87EC      		ldi r24,lo8(199)
 1473 02c0 90E0      		ldi r25,hi8(199)
 1474 02c2 0197      	1:	sbiw r24,1
 1475 02c4 01F4      		brne 1b
 1476 02c6 00C0      		rjmp .
 1477 02c8 0000      		nop
 1478               	.LVL147:
 1479 02ca 00E0      		ldi r16,lo8(receivedBuffer)
 1480 02cc 10E0      		ldi r17,hi8(receivedBuffer)
 1481               	.LBE118:
 1482               	.LBE117:
 1483               	.LBB119:
 272:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1484               		.loc 3 272 0
 1485 02ce C0E0      		ldi r28,0
 1486 02d0 D0E0      		ldi r29,0
 1487               	.LVL148:
 1488               	.L65:
 273:main.c        **** 				address++;
 1489               		.loc 3 273 0 discriminator 3
 1490 02d2 F801      		movw r30,r16
 1491 02d4 6191      		ld r22,Z+
 1492 02d6 8F01      		movw r16,r30
 1493 02d8 CE01      		movw r24,r28
 1494 02da 8A0D      		add r24,r10
 1495 02dc 9B1D      		adc r25,r11
 1496 02de 00D0      		rcall gb_flash_write_bus_cycle
 1497               	.LVL149:
 272:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1498               		.loc 3 272 0 discriminator 3
 1499 02e0 2196      		adiw r28,1
 1500               	.LVL150:
 1501 02e2 C115      		cp r28,__zero_reg__
 1502 02e4 F1E0      		ldi r31,1
 1503 02e6 DF07      		cpc r29,r31
 1504 02e8 01F4      		brne .L65
 1505 02ea 2FEF      		ldi r18,-1
 1506 02ec D21A      		sub r13,r18
 1507 02ee E20A      		sbc r14,r18
 1508 02f0 F20A      		sbc r15,r18
 1509               	.LBE119:
 278:main.c        **** 			
 1510               		.loc 3 278 0
 1511 02f2 C601      		movw r24,r12
 1512 02f4 9A95      		dec r25
 1513 02f6 6AE2      		ldi r22,lo8(42)
 1514 02f8 00D0      		rcall gb_flash_write_bus_cycle
 1515               	.LVL151:
 281:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 1516               		.loc 3 281 0
 1517 02fa E601      		movw r28,r12
 1518               	.LVL152:
 1519 02fc 2197      		sbiw r28,1
 1520 02fe CE01      		movw r24,r28
 1521 0300 00D0      		rcall gb_flash_read_byte
 1522               	.LVL153:
 1523               	.L66:
 282:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 1524               		.loc 3 282 0
 1525 0302 9091 0000 		lds r25,receivedBuffer+255
 1526 0306 8917      		cp r24,r25
 1527 0308 01F4      		brne .+2
 1528 030a 00C0      		rjmp .L119
 283:main.c        **** 				_delay_us(5);
 1529               		.loc 3 283 0
 1530 030c CE01      		movw r24,r28
 1531               	.LVL154:
 1532 030e 00D0      		rcall gb_flash_read_byte
 1533               	.LVL155:
 1534               	.LBB120:
 1535               	.LBB121:
 1536               		.loc 2 276 0
 1537 0310 9AE1      		ldi r25,lo8(26)
 1538 0312 9A95      	1:	dec r25
 1539 0314 01F4      		brne 1b
 1540 0316 00C0      		rjmp .
 1541 0318 00C0      		rjmp .L66
 1542               	.LVL156:
 1543               	.L64:
 1544               	.LBE121:
 1545               	.LBE120:
 1546               	.LBE116:
 292:main.c        **** 			usart_read_bytes(128);
 1547               		.loc 3 292 0
 1548 031a 8A35      		cpi r24,lo8(90)
 1549 031c 01F0      		breq .+2
 1550 031e 00C0      		rjmp .L68
 293:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1551               		.loc 3 293 0
 1552 0320 80E8      		ldi r24,lo8(-128)
 1553 0322 90E0      		ldi r25,0
 1554 0324 00D0      		rcall usart_read_bytes
 1555               	.LVL157:
 294:main.c        **** 			
 1556               		.loc 3 294 0
 1557 0326 939A      		sbi 0x12,3
 297:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 1558               		.loc 3 297 0
 1559 0328 69E0      		ldi r22,lo8(9)
 1560 032a 80E2      		ldi r24,lo8(32)
 1561 032c 91E0      		ldi r25,lo8(1)
 1562 032e 00D0      		rcall gb_flash_write_bus_cycle
 1563               	.LVL158:
 298:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 1564               		.loc 3 298 0
 1565 0330 6AEA      		ldi r22,lo8(-86)
 1566 0332 81E2      		ldi r24,lo8(33)
 1567 0334 91E0      		ldi r25,lo8(1)
 1568 0336 00D0      		rcall gb_flash_write_bus_cycle
 1569               	.LVL159:
 299:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1570               		.loc 3 299 0
 1571 0338 65E5      		ldi r22,lo8(85)
 1572 033a 82E2      		ldi r24,lo8(34)
 1573 033c 91E0      		ldi r25,lo8(1)
 1574 033e 00D0      		rcall gb_flash_write_bus_cycle
 1575               	.LVL160:
 300:main.c        **** 			_delay_us(5);
 1576               		.loc 3 300 0
 1577 0340 65EA      		ldi r22,lo8(-91)
 1578 0342 8FE3      		ldi r24,lo8(63)
 1579 0344 91E0      		ldi r25,lo8(1)
 1580 0346 00D0      		rcall gb_flash_write_bus_cycle
 1581               	.LVL161:
 1582               	.LBB122:
 1583               	.LBB123:
 1584               		.loc 2 276 0
 1585 0348 EAE1      		ldi r30,lo8(26)
 1586 034a EA95      	1:	dec r30
 1587 034c 01F4      		brne 1b
 1588 034e 00C0      		rjmp .
 1589               	.LVL162:
 1590               	.LBE123:
 1591               	.LBE122:
 304:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1592               		.loc 3 304 0
 1593 0350 61E1      		ldi r22,lo8(17)
 1594 0352 80E2      		ldi r24,lo8(32)
 1595 0354 91E0      		ldi r25,lo8(1)
 1596 0356 00D0      		rcall gb_flash_write_bus_cycle
 1597               	.LVL163:
 305:main.c        **** 			_delay_us(5);
 1598               		.loc 3 305 0
 1599 0358 65EA      		ldi r22,lo8(-91)
 1600 035a 8FE3      		ldi r24,lo8(63)
 1601 035c 91E0      		ldi r25,lo8(1)
 1602 035e 00D0      		rcall gb_flash_write_bus_cycle
 1603               	.LVL164:
 1604               	.LBB124:
 1605               	.LBB125:
 1606               		.loc 2 276 0
 1607 0360 FAE1      		ldi r31,lo8(26)
 1608 0362 FA95      	1:	dec r31
 1609 0364 01F4      		brne 1b
 1610 0366 00C0      		rjmp .
 1611               	.LVL165:
 1612               	.LBE125:
 1613               	.LBE124:
 309:main.c        **** 			_delay_us(5);
 1614               		.loc 3 309 0
 1615 0368 61E0      		ldi r22,lo8(1)
 1616 036a 80E0      		ldi r24,0
 1617 036c 91E2      		ldi r25,lo8(33)
 1618 036e 00D0      		rcall gb_flash_write_bus_cycle
 1619               	.LVL166:
 1620               	.LBB126:
 1621               	.LBB127:
 1622               		.loc 2 276 0
 1623 0370 2AE1      		ldi r18,lo8(26)
 1624 0372 2A95      	1:	dec r18
 1625 0374 01F4      		brne 1b
 1626 0376 00C0      		rjmp .
 1627               	.LVL167:
 1628               	.LBE127:
 1629               	.LBE126:
 314:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 1630               		.loc 3 314 0
 1631 0378 6FE0      		ldi r22,lo8(15)
 1632 037a 80E2      		ldi r24,lo8(32)
 1633 037c 91E0      		ldi r25,lo8(1)
 1634 037e 00D0      		rcall gb_flash_write_bus_cycle
 1635               	.LVL168:
 315:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 1636               		.loc 3 315 0
 1637 0380 65E5      		ldi r22,lo8(85)
 1638 0382 85E2      		ldi r24,lo8(37)
 1639 0384 91E0      		ldi r25,lo8(1)
 1640 0386 00D0      		rcall gb_flash_write_bus_cycle
 1641               	.LVL169:
 316:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 1642               		.loc 3 316 0
 1643 0388 65E5      		ldi r22,lo8(85)
 1644 038a 86E2      		ldi r24,lo8(38)
 1645 038c 91E0      		ldi r25,lo8(1)
 1646 038e 00D0      		rcall gb_flash_write_bus_cycle
 1647               	.LVL170:
 317:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1648               		.loc 3 317 0
 1649 0390 6AEA      		ldi r22,lo8(-86)
 1650 0392 87E2      		ldi r24,lo8(39)
 1651 0394 91E0      		ldi r25,lo8(1)
 1652 0396 00D0      		rcall gb_flash_write_bus_cycle
 1653               	.LVL171:
 318:main.c        **** 			_delay_us(5);
 1654               		.loc 3 318 0
 1655 0398 65EA      		ldi r22,lo8(-91)
 1656 039a 8FE3      		ldi r24,lo8(63)
 1657 039c 91E0      		ldi r25,lo8(1)
 1658 039e 00D0      		rcall gb_flash_write_bus_cycle
 1659               	.LVL172:
 1660               	.LBB128:
 1661               	.LBB129:
 1662               		.loc 2 276 0
 1663 03a0 8AE1      		ldi r24,lo8(26)
 1664 03a2 8A95      	1:	dec r24
 1665 03a4 01F4      		brne 1b
 1666 03a6 00C0      		rjmp .
 1667               	.LVL173:
 1668               	.LBE129:
 1669               	.LBE128:
 321:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 1670               		.loc 3 321 0
 1671 03a8 6FE0      		ldi r22,lo8(15)
 1672 03aa 80E2      		ldi r24,lo8(32)
 1673 03ac 91E0      		ldi r25,lo8(1)
 1674 03ae 00D0      		rcall gb_flash_write_bus_cycle
 1675               	.LVL174:
 322:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 1676               		.loc 3 322 0
 1677 03b0 6AE2      		ldi r22,lo8(42)
 1678 03b2 85E2      		ldi r24,lo8(37)
 1679 03b4 91E0      		ldi r25,lo8(1)
 1680 03b6 00D0      		rcall gb_flash_write_bus_cycle
 1681               	.LVL175:
 323:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 1682               		.loc 3 323 0
 1683 03b8 6AEA      		ldi r22,lo8(-86)
 1684 03ba 86E2      		ldi r24,lo8(38)
 1685 03bc 91E0      		ldi r25,lo8(1)
 1686 03be 00D0      		rcall gb_flash_write_bus_cycle
 1687               	.LVL176:
 324:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1688               		.loc 3 324 0
 1689 03c0 65E5      		ldi r22,lo8(85)
 1690 03c2 87E2      		ldi r24,lo8(39)
 1691 03c4 91E0      		ldi r25,lo8(1)
 1692 03c6 00D0      		rcall gb_flash_write_bus_cycle
 1693               	.LVL177:
 325:main.c        **** 			_delay_us(5);
 1694               		.loc 3 325 0
 1695 03c8 65EA      		ldi r22,lo8(-91)
 1696 03ca 8FE3      		ldi r24,lo8(63)
 1697 03cc 91E0      		ldi r25,lo8(1)
 1698 03ce 00D0      		rcall gb_flash_write_bus_cycle
 1699               	.LVL178:
 1700               	.LBB130:
 1701               	.LBB131:
 1702               		.loc 2 276 0
 1703 03d0 9AE1      		ldi r25,lo8(26)
 1704 03d2 9A95      	1:	dec r25
 1705 03d4 01F4      		brne 1b
 1706 03d6 00C0      		rjmp .
 1707               	.LVL179:
 1708               	.LBE131:
 1709               	.LBE130:
 328:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 1710               		.loc 3 328 0
 1711 03d8 6FE0      		ldi r22,lo8(15)
 1712 03da 80E2      		ldi r24,lo8(32)
 1713 03dc 91E0      		ldi r25,lo8(1)
 1714 03de 00D0      		rcall gb_flash_write_bus_cycle
 1715               	.LVL180:
 329:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 1716               		.loc 3 329 0
 1717 03e0 65E5      		ldi r22,lo8(85)
 1718 03e2 85E2      		ldi r24,lo8(37)
 1719 03e4 91E0      		ldi r25,lo8(1)
 1720 03e6 00D0      		rcall gb_flash_write_bus_cycle
 1721               	.LVL181:
 330:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 1722               		.loc 3 330 0
 1723 03e8 65E5      		ldi r22,lo8(85)
 1724 03ea 86E2      		ldi r24,lo8(38)
 1725 03ec 91E0      		ldi r25,lo8(1)
 1726 03ee 00D0      		rcall gb_flash_write_bus_cycle
 1727               	.LVL182:
 331:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1728               		.loc 3 331 0
 1729 03f0 60EA      		ldi r22,lo8(-96)
 1730 03f2 87E2      		ldi r24,lo8(39)
 1731 03f4 91E0      		ldi r25,lo8(1)
 1732 03f6 00D0      		rcall gb_flash_write_bus_cycle
 1733               	.LVL183:
 332:main.c        **** 			_delay_us(5);
 1734               		.loc 3 332 0
 1735 03f8 65EA      		ldi r22,lo8(-91)
 1736 03fa 8FE3      		ldi r24,lo8(63)
 1737 03fc 91E0      		ldi r25,lo8(1)
 1738 03fe 00D0      		rcall gb_flash_write_bus_cycle
 1739               	.LVL184:
 1740               	.LBB132:
 1741               	.LBB133:
 1742               		.loc 2 276 0
 1743 0400 EAE1      		ldi r30,lo8(26)
 1744 0402 EA95      	1:	dec r30
 1745 0404 01F4      		brne 1b
 1746 0406 00C0      		rjmp .
 1747               	.LVL185:
 1748               	.LBE133:
 1749               	.LBE132:
 336:main.c        **** 			_delay_us(5);
 1750               		.loc 3 336 0
 1751 0408 40E0      		ldi r20,0
 1752 040a 6091 0000 		lds r22,lastBankAccessed
 1753 040e 80E0      		ldi r24,0
 1754 0410 91E2      		ldi r25,lo8(33)
 1755 0412 00D0      		rcall write_8bit_data
 1756               	.LVL186:
 1757               	.LBB134:
 1758               	.LBB135:
 1759               		.loc 2 276 0
 1760 0414 FAE1      		ldi r31,lo8(26)
 1761 0416 FA95      	1:	dec r31
 1762 0418 01F4      		brne 1b
 1763 041a 00C0      		rjmp .
 1764               	.LVL187:
 1765               	.LBE135:
 1766               	.LBE134:
 340:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1767               		.loc 3 340 0
 1768 041c 60E1      		ldi r22,lo8(16)
 1769 041e 80E2      		ldi r24,lo8(32)
 1770 0420 91E0      		ldi r25,lo8(1)
 1771 0422 00D0      		rcall gb_flash_write_bus_cycle
 1772               	.LVL188:
 341:main.c        **** 			_delay_us(5);
 1773               		.loc 3 341 0
 1774 0424 65EA      		ldi r22,lo8(-91)
 1775 0426 8FE3      		ldi r24,lo8(63)
 1776 0428 91E0      		ldi r25,lo8(1)
 1777 042a 00D0      		rcall gb_flash_write_bus_cycle
 1778               	.LVL189:
 1779               	.LBB136:
 1780               	.LBB137:
 1781               		.loc 2 276 0
 1782 042c 2AE1      		ldi r18,lo8(26)
 1783 042e 2A95      	1:	dec r18
 1784 0430 01F4      		brne 1b
 1785 0432 00C0      		rjmp .
 1786               	.LVL190:
 1787               	.LBE137:
 1788               	.LBE136:
 345:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1789               		.loc 3 345 0
 1790 0434 68E0      		ldi r22,lo8(8)
 1791 0436 80E2      		ldi r24,lo8(32)
 1792 0438 91E0      		ldi r25,lo8(1)
 1793 043a 00D0      		rcall gb_flash_write_bus_cycle
 1794               	.LVL191:
 346:main.c        **** 			_delay_us(5);
 1795               		.loc 3 346 0
 1796 043c 65EA      		ldi r22,lo8(-91)
 1797 043e 8FE3      		ldi r24,lo8(63)
 1798 0440 91E0      		ldi r25,lo8(1)
 1799 0442 00D0      		rcall gb_flash_write_bus_cycle
 1800               	.LVL192:
 1801               	.LBB138:
 1802               	.LBB139:
 1803               		.loc 2 276 0
 1804 0444 8AE1      		ldi r24,lo8(26)
 1805 0446 8A95      	1:	dec r24
 1806 0448 01F4      		brne 1b
 1807 044a 00C0      		rjmp .
 1808               	.LVL193:
 1809 044c C0E0      		ldi r28,lo8(receivedBuffer)
 1810 044e D0E0      		ldi r29,hi8(receivedBuffer)
 1811               	.L69:
 1812               	.LBE139:
 1813               	.LBE138:
 1814               	.LBB140:
 351:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1815               		.loc 3 351 0 discriminator 1
 1816 0450 6C16      		cp r6,r28
 1817 0452 7D06      		cpc r7,r29
 1818 0454 01F0      		breq .L132
 352:main.c        **** 				_delay_us(5);
 1819               		.loc 3 352 0 discriminator 3
 1820 0456 6991      		ld r22,Y+
 1821 0458 C601      		movw r24,r12
 1822 045a 00D0      		rcall gb_flash_write_bus_cycle
 1823               	.LVL194:
 1824               	.LBB141:
 1825               	.LBB142:
 1826               		.loc 2 276 0 discriminator 3
 1827 045c 9AE1      		ldi r25,lo8(26)
 1828 045e 9A95      	1:	dec r25
 1829 0460 01F4      		brne 1b
 1830 0462 00C0      		rjmp .
 1831               	.LVL195:
 1832               	.LBE142:
 1833               	.LBE141:
 354:main.c        **** 			}
 1834               		.loc 3 354 0 discriminator 3
 1835 0464 EFEF      		ldi r30,-1
 1836 0466 CE1A      		sub r12,r30
 1837 0468 DE0A      		sbc r13,r30
 1838 046a EE0A      		sbc r14,r30
 1839 046c FE0A      		sbc r15,r30
 1840               	.LVL196:
 1841 046e 00C0      		rjmp .L69
 1842               	.L132:
 1843               	.LVL197:
 1844               	.LBE140:
 359:main.c        **** 			address++;
 1845               		.loc 3 359 0
 1846 0470 6FEF      		ldi r22,lo8(-1)
 1847 0472 D701      		movw r26,r14
 1848 0474 C601      		movw r24,r12
 1849 0476 0197      		sbiw r24,1
 1850 0478 A109      		sbc r26,__zero_reg__
 1851 047a B109      		sbc r27,__zero_reg__
 1852               	.LVL198:
 1853 047c 00D0      		rcall gb_flash_write_bus_cycle
 1854               	.LVL199:
 1855               	.LBB143:
 1856               	.LBB144:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1857               		.loc 2 187 0
 1858 047e 8FE3      		ldi r24,lo8(-25537)
 1859 0480 9CE9      		ldi r25,hi8(-25537)
 1860 0482 0197      	1:	sbiw r24,1
 1861 0484 01F4      		brne 1b
 1862               	.LVL200:
 1863               	.L131:
 1864 0486 00C0      		rjmp .
 1865 0488 0000      		nop
 1866               	.L119:
 1867               	.LBE144:
 1868               	.LBE143:
 363:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 1869               		.loc 3 363 0
 1870 048a 81E3      		ldi r24,lo8(49)
 1871 048c 00C0      		rjmp .L117
 1872               	.LVL201:
 1873               	.L68:
 371:main.c        **** 			char portChar = USART_Receive();
 1874               		.loc 3 371 0
 1875 048e 8934      		cpi r24,lo8(73)
 1876 0490 01F0      		breq .L71
 371:main.c        **** 			char portChar = USART_Receive();
 1877               		.loc 3 371 0 is_stmt 0 discriminator 1
 1878 0492 8F34      		cpi r24,lo8(79)
 1879 0494 01F0      		breq .+2
 1880 0496 00C0      		rjmp .L72
 1881               	.L71:
 1882               	.LBB145:
 372:main.c        **** 			usart_read_chars();
 1883               		.loc 3 372 0 is_stmt 1
 1884 0498 00D0      		rcall USART_Receive
 1885               	.LVL202:
 1886 049a C82F      		mov r28,r24
 1887               	.LVL203:
 373:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 1888               		.loc 3 373 0
 1889 049c 00D0      		rcall usart_read_chars
 1890               	.LVL204:
 374:main.c        **** 			
 1891               		.loc 3 374 0
 1892 049e 40E1      		ldi r20,lo8(16)
 1893 04a0 50E0      		ldi r21,0
 1894 04a2 60E0      		ldi r22,0
 1895 04a4 70E0      		ldi r23,0
 1896 04a6 80E0      		ldi r24,lo8(receivedBuffer)
 1897 04a8 90E0      		ldi r25,hi8(receivedBuffer)
 1898 04aa 00D0      		rcall strtol
 1899               	.LVL205:
 376:main.c        **** 			if (receivedChar == SET_INPUT) {
 1900               		.loc 3 376 0
 1901 04ac 939A      		sbi 0x12,3
 377:main.c        **** 				if (portChar == 'A') {
 1902               		.loc 3 377 0
 1903 04ae 8091 0000 		lds r24,receivedChar
 1904 04b2 8934      		cpi r24,lo8(73)
 1905 04b4 01F4      		brne .L73
 378:main.c        **** 					DDRA &= ~(setValue);
 1906               		.loc 3 378 0
 1907 04b6 C134      		cpi r28,lo8(65)
 1908 04b8 01F4      		brne .L74
 379:main.c        **** 				}
 1909               		.loc 3 379 0
 1910 04ba 8AB3      		in r24,0x1a
 1911 04bc 6095      		com r22
 1912               	.LVL206:
 1913 04be 6823      		and r22,r24
 1914               	.LVL207:
 1915 04c0 00C0      		rjmp .L121
 1916               	.LVL208:
 1917               	.L74:
 381:main.c        **** 					DDRB &= ~(setValue);
 1918               		.loc 3 381 0
 1919 04c2 C234      		cpi r28,lo8(66)
 1920 04c4 01F4      		brne .L76
 382:main.c        **** 				}
 1921               		.loc 3 382 0
 1922 04c6 87B3      		in r24,0x17
 1923 04c8 6095      		com r22
 1924               	.LVL209:
 1925 04ca 6823      		and r22,r24
 1926               	.LVL210:
 1927 04cc 00C0      		rjmp .L122
 1928               	.LVL211:
 1929               	.L76:
 384:main.c        **** 					DDRC &= ~(setValue);
 1930               		.loc 3 384 0
 1931 04ce C334      		cpi r28,lo8(67)
 1932 04d0 01F4      		brne .L77
 385:main.c        **** 				}
 1933               		.loc 3 385 0
 1934 04d2 84B3      		in r24,0x14
 1935 04d4 6095      		com r22
 1936               	.LVL212:
 1937 04d6 6823      		and r22,r24
 1938               	.LVL213:
 1939 04d8 00C0      		rjmp .L127
 1940               	.LVL214:
 1941               	.L77:
 387:main.c        **** 					DDRD &= ~(setValue);
 1942               		.loc 3 387 0
 1943 04da C434      		cpi r28,lo8(68)
 1944 04dc 01F4      		brne .L78
 388:main.c        **** 				}
 1945               		.loc 3 388 0
 1946 04de 81B3      		in r24,0x11
 1947 04e0 6095      		com r22
 1948               	.LVL215:
 1949 04e2 6823      		and r22,r24
 1950               	.LVL216:
 1951 04e4 00C0      		rjmp .L128
 1952               	.LVL217:
 1953               	.L78:
 390:main.c        **** 					DDRE &= ~(setValue);
 1954               		.loc 3 390 0
 1955 04e6 C534      		cpi r28,lo8(69)
 1956 04e8 01F0      		breq .+2
 1957 04ea 00C0      		rjmp .L97
 391:main.c        **** 				}
 1958               		.loc 3 391 0
 1959 04ec 86B1      		in r24,0x6
 1960 04ee 6095      		com r22
 1961               	.LVL218:
 1962 04f0 6823      		and r22,r24
 1963               	.LVL219:
 1964 04f2 00C0      		rjmp .L129
 1965               	.LVL220:
 1966               	.L73:
 394:main.c        **** 				if (portChar == 'A') {
 1967               		.loc 3 394 0
 1968 04f4 8F34      		cpi r24,lo8(79)
 1969 04f6 01F0      		breq .+2
 1970 04f8 00C0      		rjmp .L97
 395:main.c        **** 					DDRA |= (setValue);
 1971               		.loc 3 395 0
 1972 04fa C134      		cpi r28,lo8(65)
 1973 04fc 01F4      		brne .L79
 396:main.c        **** 				}
 1974               		.loc 3 396 0
 1975 04fe 8AB3      		in r24,0x1a
 1976 0500 682B      		or r22,r24
 1977               	.LVL221:
 1978               	.L121:
 1979 0502 6ABB      		out 0x1a,r22
 1980 0504 00C0      		rjmp .L97
 1981               	.LVL222:
 1982               	.L79:
 398:main.c        **** 					DDRB |= (setValue);
 1983               		.loc 3 398 0
 1984 0506 C234      		cpi r28,lo8(66)
 1985 0508 01F4      		brne .L80
 399:main.c        **** 				}
 1986               		.loc 3 399 0
 1987 050a 87B3      		in r24,0x17
 1988 050c 682B      		or r22,r24
 1989               	.LVL223:
 1990               	.L122:
 1991 050e 67BB      		out 0x17,r22
 1992 0510 00C0      		rjmp .L97
 1993               	.LVL224:
 1994               	.L80:
 401:main.c        **** 					DDRC |= (setValue);
 1995               		.loc 3 401 0
 1996 0512 C334      		cpi r28,lo8(67)
 1997 0514 01F4      		brne .L81
 402:main.c        **** 				}
 1998               		.loc 3 402 0
 1999 0516 84B3      		in r24,0x14
 2000 0518 682B      		or r22,r24
 2001               	.LVL225:
 2002               	.L127:
 2003 051a 64BB      		out 0x14,r22
 2004 051c 00C0      		rjmp .L97
 2005               	.LVL226:
 2006               	.L81:
 404:main.c        **** 					DDRD |= (setValue);
 2007               		.loc 3 404 0
 2008 051e C434      		cpi r28,lo8(68)
 2009 0520 01F4      		brne .L82
 405:main.c        **** 				}
 2010               		.loc 3 405 0
 2011 0522 81B3      		in r24,0x11
 2012 0524 682B      		or r22,r24
 2013               	.LVL227:
 2014               	.L128:
 2015 0526 61BB      		out 0x11,r22
 2016 0528 00C0      		rjmp .L97
 2017               	.LVL228:
 2018               	.L82:
 407:main.c        **** 					DDRE |= (setValue);
 2019               		.loc 3 407 0
 2020 052a C534      		cpi r28,lo8(69)
 2021 052c 01F0      		breq .+2
 2022 052e 00C0      		rjmp .L97
 408:main.c        **** 				}
 2023               		.loc 3 408 0
 2024 0530 86B1      		in r24,0x6
 2025 0532 682B      		or r22,r24
 2026               	.LVL229:
 2027               	.L129:
 2028 0534 66B9      		out 0x6,r22
 2029 0536 00C0      		rjmp .L97
 2030               	.LVL230:
 2031               	.L72:
 2032               	.LBE145:
 415:main.c        **** 			char portChar = USART_Receive();			
 2033               		.loc 3 415 0
 2034 0538 8C34      		cpi r24,lo8(76)
 2035 053a 01F4      		brne .L83
 2036               	.LBB146:
 416:main.c        **** 			usart_read_chars();
 2037               		.loc 3 416 0
 2038 053c 00D0      		rcall USART_Receive
 2039               	.LVL231:
 2040 053e C82F      		mov r28,r24
 2041               	.LVL232:
 417:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2042               		.loc 3 417 0
 2043 0540 00D0      		rcall usart_read_chars
 2044               	.LVL233:
 418:main.c        **** 			
 2045               		.loc 3 418 0
 2046 0542 40E1      		ldi r20,lo8(16)
 2047 0544 50E0      		ldi r21,0
 2048 0546 60E0      		ldi r22,0
 2049 0548 70E0      		ldi r23,0
 2050 054a 80E0      		ldi r24,lo8(receivedBuffer)
 2051 054c 90E0      		ldi r25,hi8(receivedBuffer)
 2052 054e 00D0      		rcall strtol
 2053               	.LVL234:
 420:main.c        **** 			if (portChar == 'A') {
 2054               		.loc 3 420 0
 2055 0550 939A      		sbi 0x12,3
 421:main.c        **** 				PORTA &= ~(setValue);
 2056               		.loc 3 421 0
 2057 0552 C134      		cpi r28,lo8(65)
 2058 0554 01F4      		brne .L84
 422:main.c        **** 			}
 2059               		.loc 3 422 0
 2060 0556 8BB3      		in r24,0x1b
 2061 0558 6095      		com r22
 2062               	.LVL235:
 2063 055a 6823      		and r22,r24
 2064               	.LVL236:
 2065 055c 00C0      		rjmp .L126
 2066               	.LVL237:
 2067               	.L84:
 424:main.c        **** 				PORTB &= ~(setValue);
 2068               		.loc 3 424 0
 2069 055e C234      		cpi r28,lo8(66)
 2070 0560 01F4      		brne .L86
 425:main.c        **** 			}
 2071               		.loc 3 425 0
 2072 0562 88B3      		in r24,0x18
 2073 0564 6095      		com r22
 2074               	.LVL238:
 2075 0566 6823      		and r22,r24
 2076               	.LVL239:
 2077 0568 00C0      		rjmp .L125
 2078               	.LVL240:
 2079               	.L86:
 427:main.c        **** 				PORTC &= ~(setValue);
 2080               		.loc 3 427 0
 2081 056a C334      		cpi r28,lo8(67)
 2082 056c 01F4      		brne .L87
 428:main.c        **** 			}
 2083               		.loc 3 428 0
 2084 056e 85B3      		in r24,0x15
 2085 0570 6095      		com r22
 2086               	.LVL241:
 2087 0572 6823      		and r22,r24
 2088               	.LVL242:
 2089 0574 00C0      		rjmp .L124
 2090               	.LVL243:
 2091               	.L87:
 430:main.c        **** 				PORTD &= ~(setValue);
 2092               		.loc 3 430 0
 2093 0576 C434      		cpi r28,lo8(68)
 2094 0578 01F4      		brne .L88
 431:main.c        **** 			}
 2095               		.loc 3 431 0
 2096 057a 82B3      		in r24,0x12
 2097 057c 6095      		com r22
 2098               	.LVL244:
 2099 057e 6823      		and r22,r24
 2100               	.LVL245:
 2101 0580 00C0      		rjmp .L123
 2102               	.LVL246:
 2103               	.L88:
 433:main.c        **** 				PORTE &= ~(setValue);
 2104               		.loc 3 433 0
 2105 0582 C534      		cpi r28,lo8(69)
 2106 0584 01F0      		breq .+2
 2107 0586 00C0      		rjmp .L97
 434:main.c        **** 			}
 2108               		.loc 3 434 0
 2109 0588 87B1      		in r24,0x7
 2110 058a 6095      		com r22
 2111               	.LVL247:
 2112 058c 6823      		and r22,r24
 2113               	.LVL248:
 2114 058e 00C0      		rjmp .L120
 2115               	.LVL249:
 2116               	.L83:
 2117               	.LBE146:
 440:main.c        **** 			char portChar = USART_Receive();			
 2118               		.loc 3 440 0
 2119 0590 8834      		cpi r24,lo8(72)
 2120 0592 01F4      		brne .L89
 2121               	.LBB147:
 441:main.c        **** 			usart_read_chars();
 2122               		.loc 3 441 0
 2123 0594 00D0      		rcall USART_Receive
 2124               	.LVL250:
 2125 0596 C82F      		mov r28,r24
 2126               	.LVL251:
 442:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2127               		.loc 3 442 0
 2128 0598 00D0      		rcall usart_read_chars
 2129               	.LVL252:
 443:main.c        **** 			
 2130               		.loc 3 443 0
 2131 059a 40E1      		ldi r20,lo8(16)
 2132 059c 50E0      		ldi r21,0
 2133 059e 60E0      		ldi r22,0
 2134 05a0 70E0      		ldi r23,0
 2135 05a2 80E0      		ldi r24,lo8(receivedBuffer)
 2136 05a4 90E0      		ldi r25,hi8(receivedBuffer)
 2137 05a6 00D0      		rcall strtol
 2138               	.LVL253:
 445:main.c        **** 			if (portChar == 'A') {
 2139               		.loc 3 445 0
 2140 05a8 939A      		sbi 0x12,3
 446:main.c        **** 				PORTA |= (setValue);
 2141               		.loc 3 446 0
 2142 05aa C134      		cpi r28,lo8(65)
 2143 05ac 01F4      		brne .L90
 447:main.c        **** 			}
 2144               		.loc 3 447 0
 2145 05ae 8BB3      		in r24,0x1b
 2146 05b0 682B      		or r22,r24
 2147               	.LVL254:
 2148               	.L126:
 2149 05b2 6BBB      		out 0x1b,r22
 2150 05b4 00C0      		rjmp .L97
 2151               	.LVL255:
 2152               	.L90:
 449:main.c        **** 				PORTB |= (setValue);
 2153               		.loc 3 449 0
 2154 05b6 C234      		cpi r28,lo8(66)
 2155 05b8 01F4      		brne .L92
 450:main.c        **** 			}
 2156               		.loc 3 450 0
 2157 05ba 88B3      		in r24,0x18
 2158 05bc 682B      		or r22,r24
 2159               	.LVL256:
 2160               	.L125:
 2161 05be 68BB      		out 0x18,r22
 2162 05c0 00C0      		rjmp .L97
 2163               	.LVL257:
 2164               	.L92:
 452:main.c        **** 				PORTC |= (setValue);
 2165               		.loc 3 452 0
 2166 05c2 C334      		cpi r28,lo8(67)
 2167 05c4 01F4      		brne .L93
 453:main.c        **** 			}
 2168               		.loc 3 453 0
 2169 05c6 85B3      		in r24,0x15
 2170 05c8 682B      		or r22,r24
 2171               	.LVL258:
 2172               	.L124:
 2173 05ca 65BB      		out 0x15,r22
 2174 05cc 00C0      		rjmp .L97
 2175               	.LVL259:
 2176               	.L93:
 455:main.c        **** 				PORTD |= (setValue);
 2177               		.loc 3 455 0
 2178 05ce C434      		cpi r28,lo8(68)
 2179 05d0 01F4      		brne .L94
 456:main.c        **** 			}
 2180               		.loc 3 456 0
 2181 05d2 82B3      		in r24,0x12
 2182 05d4 682B      		or r22,r24
 2183               	.LVL260:
 2184               	.L123:
 2185 05d6 62BB      		out 0x12,r22
 2186 05d8 00C0      		rjmp .L97
 2187               	.LVL261:
 2188               	.L94:
 458:main.c        **** 				PORTE |= (setValue);
 2189               		.loc 3 458 0
 2190 05da C534      		cpi r28,lo8(69)
 2191 05dc 01F4      		brne .L97
 459:main.c        **** 			}
 2192               		.loc 3 459 0
 2193 05de 87B1      		in r24,0x7
 2194 05e0 682B      		or r22,r24
 2195               	.LVL262:
 2196               	.L120:
 2197 05e2 67B9      		out 0x7,r22
 2198 05e4 00C0      		rjmp .L97
 2199               	.L89:
 2200               	.LBE147:
 465:main.c        **** 			char portChar = USART_Receive();			
 2201               		.loc 3 465 0
 2202 05e6 8434      		cpi r24,lo8(68)
 2203 05e8 01F4      		brne .L95
 2204               	.LBB148:
 466:main.c        **** 			
 2205               		.loc 3 466 0
 2206 05ea 00D0      		rcall USART_Receive
 2207               	.LVL263:
 468:main.c        **** 			if (portChar == 'A') {
 2208               		.loc 3 468 0
 2209 05ec 939A      		sbi 0x12,3
 469:main.c        **** 				USART_Transmit(PINA);
 2210               		.loc 3 469 0
 2211 05ee 8134      		cpi r24,lo8(65)
 2212 05f0 01F4      		brne .L96
 470:main.c        **** 			}
 2213               		.loc 3 470 0
 2214 05f2 89B3      		in r24,0x19
 2215               	.LVL264:
 2216 05f4 00C0      		rjmp .L117
 2217               	.LVL265:
 2218               	.L96:
 472:main.c        **** 				USART_Transmit(PINB);
 2219               		.loc 3 472 0
 2220 05f6 8234      		cpi r24,lo8(66)
 2221 05f8 01F4      		brne .L98
 473:main.c        **** 			}
 2222               		.loc 3 473 0
 2223 05fa 86B3      		in r24,0x16
 2224               	.LVL266:
 2225 05fc 00C0      		rjmp .L117
 2226               	.LVL267:
 2227               	.L98:
 475:main.c        **** 				USART_Transmit(PINC);
 2228               		.loc 3 475 0
 2229 05fe 8334      		cpi r24,lo8(67)
 2230 0600 01F4      		brne .L99
 476:main.c        **** 			}
 2231               		.loc 3 476 0
 2232 0602 83B3      		in r24,0x13
 2233               	.LVL268:
 2234 0604 00C0      		rjmp .L117
 2235               	.LVL269:
 2236               	.L99:
 478:main.c        **** 				USART_Transmit(PIND);
 2237               		.loc 3 478 0
 2238 0606 8434      		cpi r24,lo8(68)
 2239 0608 01F4      		brne .L100
 479:main.c        **** 			}
 2240               		.loc 3 479 0
 2241 060a 80B3      		in r24,0x10
 2242               	.LVL270:
 2243 060c 00C0      		rjmp .L117
 2244               	.LVL271:
 2245               	.L100:
 481:main.c        **** 				USART_Transmit(PINE);
 2246               		.loc 3 481 0
 2247 060e 8534      		cpi r24,lo8(69)
 2248 0610 01F4      		brne .L97
 482:main.c        **** 			}
 2249               		.loc 3 482 0
 2250 0612 85B1      		in r24,0x5
 2251               	.LVL272:
 2252               	.L117:
 2253 0614 00D0      		rcall USART_Transmit
 2254               	.LVL273:
 2255               	.L97:
 484:main.c        **** 		}
 2256               		.loc 3 484 0
 2257 0616 9398      		cbi 0x12,3
 2258               	.LBE148:
 2259 0618 00C0      		rjmp .L37
 2260               	.LVL274:
 2261               	.L95:
 488:main.c        **** 			char commonChar = USART_Receive();
 2262               		.loc 3 488 0
 2263 061a 8D34      		cpi r24,lo8(77)
 2264 061c 01F4      		brne .L101
 2265               	.LBB149:
 489:main.c        **** 			if (commonChar == '1') {
 2266               		.loc 3 489 0
 2267 061e 00D0      		rcall USART_Receive
 2268               	.LVL275:
 490:main.c        **** 				resetCommonLines = 1;
 2269               		.loc 3 490 0
 2270 0620 8133      		cpi r24,lo8(49)
 2271 0622 01F4      		brne .L133
 2272               		.loc 3 491 0
 2273 0624 5524      		clr r5
 2274 0626 5394      		inc r5
 2275 0628 00C0      		rjmp .L115
 2276               	.L133:
 492:main.c        **** 			}
 493:main.c        **** 			else if (commonChar == '0') {
 2277               		.loc 3 493 0
 2278 062a 8033      		cpi r24,lo8(48)
 2279 062c 01F0      		breq .+2
 2280 062e 00C0      		rjmp .L37
 494:main.c        **** 				resetCommonLines = 0;
 2281               		.loc 3 494 0
 2282 0630 512C      		mov r5,__zero_reg__
 2283 0632 00C0      		rjmp .L38
 2284               	.LVL276:
 2285               	.L101:
 2286               	.LBE149:
 495:main.c        **** 			}
 496:main.c        **** 		}
 497:main.c        **** 		
 498:main.c        **** 		// Send back the PCB version number
 499:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 2287               		.loc 3 499 0
 2288 0634 8836      		cpi r24,lo8(104)
 2289 0636 01F4      		brne .L102
 500:main.c        **** 			USART_Transmit(PCB_VERSION);
 2290               		.loc 3 500 0
 2291 0638 84E6      		ldi r24,lo8(100)
 2292 063a 00C0      		rjmp .L116
 2293               	.L102:
 501:main.c        **** 		}
 502:main.c        **** 		
 503:main.c        **** 		// Send back the firmware version number
 504:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 2294               		.loc 3 504 0
 2295 063c 8635      		cpi r24,lo8(86)
 2296 063e 01F4      		brne .L103
 505:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 2297               		.loc 3 505 0
 2298 0640 8EE0      		ldi r24,lo8(14)
 2299               	.LVL277:
 2300               	.L116:
 2301 0642 00D0      		rcall USART_Transmit
 2302               	.LVL278:
 2303 0644 00C0      		rjmp .L37
 2304               	.LVL279:
 2305               	.L103:
 506:main.c        **** 		}
 507:main.c        **** 		
 508:main.c        **** 		// Reset the AVR if it matches the number
 509:main.c        **** 		else if (receivedChar == RESET_AVR) {
 2306               		.loc 3 509 0
 2307 0646 8A32      		cpi r24,lo8(42)
 2308 0648 01F0      		breq .+2
 2309 064a 00C0      		rjmp .L37
 2310               	.LBB150:
 510:main.c        **** 			usart_read_chars();
 2311               		.loc 3 510 0
 2312 064c 00D0      		rcall usart_read_chars
 2313               	.LVL280:
 511:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 2314               		.loc 3 511 0
 2315 064e 40E1      		ldi r20,lo8(16)
 2316 0650 50E0      		ldi r21,0
 2317 0652 60E0      		ldi r22,0
 2318 0654 70E0      		ldi r23,0
 2319 0656 80E0      		ldi r24,lo8(receivedBuffer)
 2320 0658 90E0      		ldi r25,hi8(receivedBuffer)
 2321 065a 00D0      		rcall strtol
 2322               	.LVL281:
 512:main.c        **** 			if (resetValue == RESET_VALUE) {
 2323               		.loc 3 512 0
 2324 065c 613E      		cpi r22,-31
 2325 065e 754E      		sbci r23,-27
 2326 0660 8740      		sbci r24,7
 2327 0662 9105      		cpc r25,__zero_reg__
 2328 0664 01F0      		breq .+2
 2329 0666 00C0      		rjmp .L37
 513:main.c        **** 				// Clear watchdog flag
 514:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 2330               		.loc 3 514 0
 2331 0668 84B7      		in r24,0x34
 2332 066a 877F      		andi r24,lo8(-9)
 2333 066c 84BF      		out 0x34,r24
 515:main.c        **** 				
 516:main.c        **** 				// Start timed sequence
 517:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 2334               		.loc 3 517 0
 2335 066e F8E1      		ldi r31,lo8(24)
 2336 0670 F1BD      		out 0x21,r31
 518:main.c        **** 				
 519:main.c        **** 				// Reset in 250 ms
 520:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 2337               		.loc 3 520 0
 2338 0672 2CE0      		ldi r18,lo8(12)
 2339 0674 21BD      		out 0x21,r18
 2340               	.LVL282:
 2341               	.LBB97:
 2342               	.LBB96:
 2343               		.loc 4 105 0
 2344 0676 C101      		movw r24,r2
 2345               	/* #APP */
 2346               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 2347 0678 0197      		1: sbiw r24,1
 2348 067a 01F4      		brne 1b
 2349               	 ;  0 "" 2
 2350               	.LVL283:
 2351               	/* #NOAPP */
 2352 067c 00C0      		rjmp .L37
 2353               	.LBE96:
 2354               	.LBE97:
 2355               	.LBE150:
 2356               		.cfi_endproc
 2357               	.LFE26:
 2359               	.global	cartMode
 2360               		.data
 2363               	cartMode:
 2364 0000 01        		.byte	1
 2365               	.global	lastBankAccessed
 2366               		.section .bss
 2369               	lastBankAccessed:
 2370 0000 00        		.zero	1
 2371               	.global	flashBank1CommandWrites
 2374               	flashBank1CommandWrites:
 2375 0001 00        		.zero	1
 2376               		.comm	flashWriteCycle,12,1
 2377               		.comm	flashWriteWePin,1,1
 2378               		.comm	receivedChar,1,1
 2379               		.comm	receivedBuffer,256,1
 2380               		.text
 2381               	.Letext0:
 2382               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 2383               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:274    .text:00000086 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:343    .text:000000b4 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:391    .text:000000ca gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:494    .text:00000108 gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:595    .text:0000016c gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:2369   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:766    .text:00000204 setup
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:869    .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:2363   .data:00000000 cartMode
C:\Users\Alex\AppData\Local\Temp\ccGQxChc.s:2374   .bss:00000001 flashBank1CommandWrites

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
