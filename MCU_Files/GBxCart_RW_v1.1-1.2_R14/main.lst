   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R14
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 15/05/2019
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 144:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 145:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 146:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
 147:setup.c       **** 
 148:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 149:setup.c       **** 
 150:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 151:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 152:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 153:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 154:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 155:setup.c       **** 
 156:setup.c       **** #define D0D1_NOT_SWAPPED 0
 157:setup.c       **** #define D0D1_SWAPPED 1
 158:setup.c       **** 
 159:setup.c       **** // General commands
 160:setup.c       **** #define SEND_ACK '1'
 161:setup.c       **** #define CART_MODE 'C'
 162:setup.c       **** #define SET_INPUT 'I'
 163:setup.c       **** #define SET_OUTPUT 'O'
 164:setup.c       **** #define SET_OUTPUT_LOW 'L'
 165:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 166:setup.c       **** #define READ_INPUT 'D'
 167:setup.c       **** #define RESET_COMMON_LINES 'M'
 168:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 169:setup.c       **** #define READ_PCB_VERSION 'h'
 170:setup.c       **** 
 171:setup.c       **** #define RESET_AVR '*'
 172:setup.c       **** #define RESET_VALUE 0x7E5E1
 173:setup.c       **** 
 174:setup.c       **** 
 175:setup.c       **** char receivedBuffer[256];
 176:setup.c       **** char receivedChar;
 177:setup.c       **** uint8_t eepromBuffer[8];
 178:setup.c       **** uint8_t flashChipIdBuffer[2];
 179:setup.c       **** 
 180:setup.c       **** char flashWriteWePin;
 181:setup.c       **** uint16_t flashWriteCycle[3][2];
 182:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 183:setup.c       **** uint8_t lastBankAccessed = 0;
 184:setup.c       **** 
 185:setup.c       **** 
 186:setup.c       **** // Receive USART data
 187:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 187 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 188:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 188 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 189:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 189 0
  26 0004 8CB1      		in r24,0xc
 190:setup.c       **** }
  27               		.loc 1 190 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 191:setup.c       **** 
 192:setup.c       **** // Transmit USART data
 193:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 193 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 194:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 194 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 195:setup.c       **** 	UDR = data;
  47               		.loc 1 195 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 196:setup.c       **** }
 197:setup.c       **** 
 198:setup.c       **** // Read 1-256 bytes from the USART 
 199:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 199 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB123:
 200:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 200 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 200 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 201:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 201 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE123:
 202:setup.c       **** 	}
 203:setup.c       **** }
 106               		.loc 1 203 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 204:setup.c       **** 
 205:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 206:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 206 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 207:setup.c       **** 	int x = 0;
 208:setup.c       **** 	while (1) {
 209:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 209 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 210:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 210 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 211:setup.c       **** 			break;
 212:setup.c       **** 		}
 213:setup.c       **** 		x++;
 214:setup.c       **** 	}
 215:setup.c       **** }
 148               		.loc 1 215 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 216:setup.c       **** 
 217:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 218:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 218 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 219:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 219 0
 167 0050 3A9A      		sbi 0x7,2
 220:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 220 0
 169 0052 949A      		sbi 0x12,4
 221:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 221 0
 171 0054 959A      		sbi 0x12,5
 222:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 222 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 223:setup.c       **** }
 224:setup.c       **** 
 225:setup.c       **** 
 226:setup.c       **** 
 227:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 228:setup.c       **** 
 229:setup.c       **** // Set Gameboy mode
 230:setup.c       **** void gb_mode(void) {
 182               		.loc 1 230 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 231:setup.c       **** 	// Set inputs
 232:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 232 0
 189 005a 15BA      		out 0x15,__zero_reg__
 233:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 233 0
 191 005c 14BA      		out 0x14,__zero_reg__
 234:setup.c       **** 	
 235:setup.c       **** 	// Set outputs
 236:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 236 0
 193 005e 18BA      		out 0x18,__zero_reg__
 237:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 237 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 238:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 238 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 239:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 239 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 240:setup.c       **** }
 241:setup.c       **** 
 242:setup.c       **** // Set the 16 bit address on A15-0
 243:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 243 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 244:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 244 0
 217 006a 9BBB      		out 0x1b,r25
 245:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 245 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 246:setup.c       **** }
 247:setup.c       **** 
 248:setup.c       **** // Set the address and read a byte from the 8 bit data line
 249:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 249 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 250:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 250 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 251:setup.c       **** 	
 252:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 252 0
 239 0072 9498      		cbi 0x12,4
 253:setup.c       **** 	rdPin_low;
 240               		.loc 1 253 0
 241 0074 9598      		cbi 0x12,5
 254:setup.c       **** 	
 255:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 255 0
 243               	/* #APP */
 244               	 ;  255 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 256:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 256 0
 248               	 ;  256 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 257:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 257 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 258:setup.c       **** 	
 259:setup.c       **** 	rdPin_high;
 255               		.loc 1 259 0
 256 007c 959A      		sbi 0x12,5
 260:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 260 0
 258 007e 949A      		sbi 0x12,4
 261:setup.c       **** 	
 262:setup.c       **** 	return data;
 263:setup.c       **** }
 259               		.loc 1 263 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 264:setup.c       **** 
 265:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 266:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 266 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 267:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 267 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 268:setup.c       **** 	
 269:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 269 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 270:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 270 0
 292 0090 D5BB      		out 0x15,r29
 271:setup.c       **** 	
 272:setup.c       **** 	// Pulse WR and mREQ if the type matches
 273:setup.c       **** 	wrPin_low;
 293               		.loc 1 273 0
 294 0092 9698      		cbi 0x12,6
 274:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 274 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 275:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 275 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 276:setup.c       **** 	}
 277:setup.c       **** 	
 278:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 278 0
 302               	/* #APP */
 303               	 ;  278 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 279:setup.c       **** 	
 280:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 280 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 281:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 281 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 282:setup.c       **** 	}
 283:setup.c       **** 	wrPin_high;
 313               		.loc 1 283 0
 314 00a2 969A      		sbi 0x12,6
 284:setup.c       **** 	
 285:setup.c       **** 	// Clear data outputs and set data pins as inputs
 286:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 286 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 287:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 287 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 288:setup.c       **** }
 320               		.loc 1 288 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 289:setup.c       **** 
 290:setup.c       **** 
 291:setup.c       **** 
 292:setup.c       **** // ****** Gameboy Advance functions ****** 
 293:setup.c       **** 
 294:setup.c       **** // Set GBA mode
 295:setup.c       **** void gba_mode(void) {
 333               		.loc 1 295 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 296:setup.c       **** 	// Set outputs for reading ROM addresses as default
 297:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 297 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 298:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 298 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 299:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 299 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 300:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 300 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 301:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 301 0
 349 00b8 8ABB      		out 0x1a,r24
 302:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 302 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 303:setup.c       **** }
 304:setup.c       **** 
 305:setup.c       **** // Set the 24 bit address on A23-0
 306:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 306 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 307:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 307 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 308:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 308 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 309:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 309 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 310:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 310 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 311:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 311 0
 385 00cc 2ABB      		out 0x1a,r18
 312:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 312 0
 387 00ce 27BB      		out 0x17,r18
 313:setup.c       **** 	
 314:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 314 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 315:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 315 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 316:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 316 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 317:setup.c       **** }
 402               		.loc 1 317 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 318:setup.c       **** 
 319:setup.c       **** 
 320:setup.c       **** 
 321:setup.c       **** // ---------- ROM/SRAM ----------
 322:setup.c       **** 
 323:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 324:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 324 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 325:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 325 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 326:setup.c       **** 	
 327:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 327 0
 424 00ec 9498      		cbi 0x12,4
 328:setup.c       **** 	
 329:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 329 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 330:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 330 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 331:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 331 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 332:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 332 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 333:setup.c       **** 	
 334:setup.c       **** 	rdPin_low;
 433               		.loc 1 334 0
 434 00f6 9598      		cbi 0x12,5
 335:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 335 0
 436               	/* #APP */
 437               	 ;  335 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 336:setup.c       **** 	
 337:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 337 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 338:setup.c       **** 	
 339:setup.c       **** 	rdPin_high;
 445               		.loc 1 339 0
 446 00fe 959A      		sbi 0x12,5
 340:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 340 0
 448 0100 949A      		sbi 0x12,4
 341:setup.c       **** 	
 342:setup.c       **** 	return data;
 449               		.loc 1 342 0
 450 0102 90E0      		ldi r25,0
 343:setup.c       **** }
 451               		.loc 1 343 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 344:setup.c       **** 
 345:setup.c       **** // Set the address and read a byte from the 8 bit data line
 346:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 346 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 347:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 347 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 348:setup.c       **** 	
 349:setup.c       **** 	rdPin_low;
 471               		.loc 1 349 0
 472 010a 9598      		cbi 0x12,5
 350:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 473               		.loc 1 350 0
 474 010c 3A98      		cbi 0x7,2
 351:setup.c       **** 	
 352:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 352 0
 476               	/* #APP */
 477               	 ;  352 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 353:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 353 0
 481               	 ;  353 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 354:setup.c       **** 	
 355:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 355 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 356:setup.c       **** 	
 357:setup.c       **** 	cs2Pin_high;
 488               		.loc 1 357 0
 489 0114 3A9A      		sbi 0x7,2
 358:setup.c       **** 	rdPin_high;
 490               		.loc 1 358 0
 491 0116 959A      		sbi 0x12,5
 359:setup.c       **** 	
 360:setup.c       **** 	return data;
 361:setup.c       **** }
 492               		.loc 1 361 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 362:setup.c       **** 
 363:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 364:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 364 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 365:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 365 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 366:setup.c       **** 	
 367:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 367 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 368:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 368 0
 520 0124 C5BB      		out 0x15,r28
 369:setup.c       **** 	
 370:setup.c       **** 	// Pulse WR
 371:setup.c       **** 	wrPin_low;
 521               		.loc 1 371 0
 522 0126 9698      		cbi 0x12,6
 372:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 523               		.loc 1 372 0
 524 0128 3A98      		cbi 0x7,2
 373:setup.c       **** 	
 374:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 374 0
 526               	/* #APP */
 527               	 ;  374 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 375:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 375 0
 531               	 ;  375 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 376:setup.c       **** 	
 377:setup.c       **** 	cs2Pin_high;
 534               		.loc 1 377 0
 535               	/* #NOAPP */
 536 012e 3A9A      		sbi 0x7,2
 378:setup.c       **** 	wrPin_high;
 537               		.loc 1 378 0
 538 0130 969A      		sbi 0x12,6
 379:setup.c       **** 	
 380:setup.c       **** 	// Clear data outputs and set data pins as inputs
 381:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 381 0
 540 0132 15BA      		out 0x15,__zero_reg__
 382:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 382 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 383:setup.c       **** }
 544               		.loc 1 383 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 384:setup.c       **** 
 385:setup.c       **** 
 386:setup.c       **** 
 387:setup.c       **** // ---------- EEPROM ----------
 388:setup.c       **** 
 389:setup.c       **** // Set address/data all high (includes AD0/A23)
 390:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 390 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 391:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 391 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 392:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 392 0
 565 013e 8ABB      		out 0x1a,r24
 393:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 393 0
 567 0140 84BB      		out 0x14,r24
 394:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 394 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 395:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 395 0
 572 0146 8BBB      		out 0x1b,r24
 396:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 396 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 397:setup.c       **** }
 398:setup.c       **** 
 399:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 400:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 400 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 401:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 401 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 402:setup.c       **** 	
 403:setup.c       **** 	int8_t x = 0;
 404:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 404 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 405:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 405 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 406:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 406 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 407:setup.c       **** 		}
 408:setup.c       **** 		else {
 409:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 410:setup.c       **** 		}
 411:setup.c       **** 		x = 15;
 603               		.loc 1 411 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 412:setup.c       **** 	}
 413:setup.c       **** 	else {
 414:setup.c       **** 		if (command == EEPROM_READ) {
 415:setup.c       **** 			address |= (1<<7) | (1<<6);
 416:setup.c       **** 		}
 417:setup.c       **** 		else {
 418:setup.c       **** 			address |= (1<<7);
 419:setup.c       **** 		}
 420:setup.c       **** 		x = 7;
 421:setup.c       **** 	}
 422:setup.c       **** 	
 423:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 424:setup.c       **** 	while (x >= 0) {
 425:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 425 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 409:setup.c       **** 		}
 613               		.loc 1 409 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 414:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 414 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 415:setup.c       **** 		}
 621               		.loc 1 415 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 418:setup.c       **** 		}
 626               		.loc 1 418 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 420:setup.c       **** 	}
 630               		.loc 1 420 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 426:setup.c       **** 			ad0Pin_high;
 427:setup.c       **** 		}
 428:setup.c       **** 		else {
 429:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 429 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 430:setup.c       **** 		}
 431:setup.c       **** 		
 432:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 432 0
 639 0174 9698      		cbi 0x12,6
 433:setup.c       **** 		asm ("nop");
 640               		.loc 1 433 0
 641               	/* #APP */
 642               	 ;  433 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 434:setup.c       **** 		asm ("nop");
 645               		.loc 1 434 0
 646               	 ;  434 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 435:setup.c       **** 		wrPin_high; 
 649               		.loc 1 435 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 436:setup.c       **** 		asm ("nop");
 652               		.loc 1 436 0
 653               	/* #APP */
 654               	 ;  436 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 437:setup.c       **** 		asm ("nop");
 657               		.loc 1 437 0
 658               	 ;  437 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 424:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 424 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 425:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 425 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 426:setup.c       **** 		}
 682               		.loc 1 426 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 438:setup.c       **** 		
 439:setup.c       **** 		x--;
 440:setup.c       **** 	}
 441:setup.c       **** 	
 442:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 443:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 443 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 444:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 444 0
 690 01a4 C098      		cbi 0x18,0
 445:setup.c       **** 		asm ("nop");
 691               		.loc 1 445 0
 692               	/* #APP */
 693               	 ;  445 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 446:setup.c       **** 		wrPin_low;
 696               		.loc 1 446 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 447:setup.c       **** 		asm ("nop");
 699               		.loc 1 447 0
 700               	/* #APP */
 701               	 ;  447 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 448:setup.c       **** 		asm ("nop");
 704               		.loc 1 448 0
 705               	 ;  448 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 449:setup.c       **** 		
 450:setup.c       **** 		wrPin_high;
 708               		.loc 1 450 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 451:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 451 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 452:setup.c       **** 	}
 453:setup.c       **** }
 454:setup.c       **** 
 455:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 456:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 456 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 457:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 457 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 458:setup.c       **** 	
 459:setup.c       **** 	// Set AD0 pin as input
 460:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 460 0
 734 01b8 C098      		cbi 0x18,0
 461:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 461 0
 736 01ba B898      		cbi 0x17,0
 462:setup.c       **** 	
 463:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 463 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB124:
 464:setup.c       **** 	
 465:setup.c       **** 	// Ignore first 4 bits
 466:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 467:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 467 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 468:setup.c       **** 		asm ("nop");
 746               		.loc 1 468 0 discriminator 3
 747               	/* #APP */
 748               	 ;  468 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 469:setup.c       **** 		asm ("nop");
 751               		.loc 1 469 0 discriminator 3
 752               	 ;  469 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 470:setup.c       **** 		rdPin_high; 
 755               		.loc 1 470 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 471:setup.c       **** 		asm ("nop");
 758               		.loc 1 471 0 discriminator 3
 759               	/* #APP */
 760               	 ;  471 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 472:setup.c       **** 		asm ("nop");
 763               		.loc 1 472 0 discriminator 3
 764               	 ;  472 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 466:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 466 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE124:
 776               	.LBB125:
 777               	.LBB126:
 778               	.LBB127:
 473:setup.c       **** 	}
 474:setup.c       **** 	
 475:setup.c       **** 	// Read out 64 bits
 476:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 477:setup.c       **** 		uint8_t data = 0;
 478:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 479:setup.c       **** 			rdPin_low; // CLK
 480:setup.c       **** 			asm ("nop");
 481:setup.c       **** 			asm ("nop");
 482:setup.c       **** 			rdPin_high;
 483:setup.c       **** 			
 484:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 485:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 485 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE127:
 785               	.LBE126:
 786               	.LBE125:
 463:setup.c       **** 	
 787               		.loc 1 463 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB130:
 794               	.LBB129:
 795               	.LBB128:
 479:setup.c       **** 			asm ("nop");
 796               		.loc 1 479 0
 797 01de 9598      		cbi 0x12,5
 480:setup.c       **** 			asm ("nop");
 798               		.loc 1 480 0
 799               	/* #APP */
 800               	 ;  480 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 481:setup.c       **** 			rdPin_high;
 803               		.loc 1 481 0
 804               	 ;  481 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 482:setup.c       **** 			
 807               		.loc 1 482 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 484:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 484 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 485 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE128:
 486:setup.c       **** 			}
 487:setup.c       **** 		}
 488:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 488 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE129:
 476:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 476 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE130:
 489:setup.c       **** 	}
 490:setup.c       **** 	
 491:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 491 0
 841 0206 949A      		sbi 0x12,4
 492:setup.c       **** 	
 493:setup.c       **** 	// Set AD0 pin as output
 494:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 494 0
 843 0208 C09A      		sbi 0x18,0
 495:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 495 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 496:setup.c       **** }
 497:setup.c       **** 
 498:setup.c       **** // Write 8 bytes to the EEPROM address
 499:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 499 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 500:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 500 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 499:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 499 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB131:
 876               	.LBB132:
 501:setup.c       **** 	
 502:setup.c       **** 	// Write 64 bits
 503:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 504:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 505:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 505 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 506:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 506 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 507:setup.c       **** 			}
 508:setup.c       **** 			else {
 509:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 509 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 510:setup.c       **** 			}
 511:setup.c       **** 			
 512:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 512 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 513:setup.c       **** 			asm ("nop");
 899               		.loc 1 513 0 discriminator 2
 900               	/* #APP */
 901               	 ;  513 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 514:setup.c       **** 			asm ("nop");
 904               		.loc 1 514 0 discriminator 2
 905               	 ;  514 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 515:setup.c       **** 			wrPin_high; 
 908               		.loc 1 515 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 516:setup.c       **** 			asm ("nop");
 911               		.loc 1 516 0 discriminator 2
 912               	/* #APP */
 913               	 ;  516 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 517:setup.c       **** 			asm ("nop");
 916               		.loc 1 517 0 discriminator 2
 917               	 ;  517 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE132:
 503:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 503 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE131:
 518:setup.c       **** 		}
 519:setup.c       **** 	}
 520:setup.c       **** 	
 521:setup.c       **** 	// Last bit low
 522:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 522 0
 935 0250 C098      		cbi 0x18,0
 523:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 523 0
 937 0252 9698      		cbi 0x12,6
 524:setup.c       **** 	asm ("nop");
 938               		.loc 1 524 0
 939               	/* #APP */
 940               	 ;  524 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 525:setup.c       **** 	asm ("nop");
 943               		.loc 1 525 0
 944               	 ;  525 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 526:setup.c       **** 	wrPin_high; 
 947               		.loc 1 526 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 527:setup.c       **** 	asm ("nop");
 950               		.loc 1 527 0
 951               	/* #APP */
 952               	 ;  527 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 528:setup.c       **** 	asm ("nop");
 955               		.loc 1 528 0
 956               	 ;  528 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 529:setup.c       **** 	
 530:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 530 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 531:setup.c       **** }
 532:setup.c       **** 
 533:setup.c       **** 
 534:setup.c       **** 
 535:setup.c       **** // ---------- FLASH ----------
 536:setup.c       **** 
 537:setup.c       **** // Set the address and data for the write byte cycle to the flash
 538:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 538 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 539:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 539 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 540:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 540 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 541:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 541 0
 989 026c C5BB      		out 0x15,r28
 542:setup.c       **** 	
 543:setup.c       **** 	wrPin_low;
 990               		.loc 1 543 0
 991 026e 9698      		cbi 0x12,6
 544:setup.c       **** 	cs2Pin_low;
 992               		.loc 1 544 0
 993 0270 3A98      		cbi 0x7,2
 545:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 545 0
 995               	/* #APP */
 996               	 ;  545 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 546:setup.c       **** 	wrPin_high;
 999               		.loc 1 546 0
 1000               	/* #NOAPP */
 1001 0274 969A      		sbi 0x12,6
 547:setup.c       **** 	cs2Pin_high;
 1002               		.loc 1 547 0
 1003 0276 3A9A      		sbi 0x7,2
 1004               	/* epilogue start */
 548:setup.c       **** }
 1005               		.loc 1 548 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 549:setup.c       **** 
 550:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 551:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 551 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 552:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 552 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 553:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 553 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 554:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 554 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB133:
 1049               	.LBB134:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE134:
 1060               	.LBE133:
 555:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 556:setup.c       **** 	
 557:setup.c       **** 	// Set data as inputs
 558:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 558 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 559:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 559 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 560:setup.c       **** 	
 561:setup.c       **** 	// Read and transmit the 2 bytes
 562:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 562 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 563:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 563 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 564:setup.c       **** 	
 565:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 565 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 566:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 566 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 567:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 567 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB135:
 1098               	.LBB136:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE136:
 1109               	.LBE135:
 568:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 569:setup.c       **** }
 1110               		.loc 1 569 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 570:setup.c       **** 
 571:setup.c       **** // Switch banks on the Flash
 572:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 572 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 573:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 573 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 574:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 574 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 575:setup.c       **** 	
 576:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 576 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 577:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 577 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 578:setup.c       **** }
 1157               		.loc 1 578 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 577:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 577 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 579:setup.c       **** 
 580:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 581:setup.c       **** // Takes 25ms after last command to erase sector
 582:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 582 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 583:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 583 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 584:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 584 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 585:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 585 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 586:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 586 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 587:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 587 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 588:setup.c       **** 	
 589:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 589 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB137:
 1222               	.LBB138:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE138:
 1233               	.LBE137:
 590:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 591:setup.c       **** }
 1234               		.loc 1 591 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 592:setup.c       **** 
 593:setup.c       **** // Write a single byte to the Flash address
 594:setup.c       **** // Takes 20us to program Flash
 595:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 595 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 596:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 596 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 597:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 597 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 598:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 598 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 599:setup.c       **** 	
 600:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 600 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB139:
 1292               	.LBB140:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE140:
 1301               	.LBE139:
 601:setup.c       **** 	_delay_us(20); // Wait byte program time
 602:setup.c       **** }
 1302               		.loc 1 602 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 603:setup.c       **** 
 604:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 605:setup.c       **** // Takes 20ms for write cycle
 606:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 606 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 607:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 607 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 608:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 608 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 609:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 609 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB141:
 610:setup.c       **** 	
 611:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 612:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 613:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 613 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 613 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 612:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 612 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE141:
 1400               	.LBB142:
 1401               	.LBB143:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE143:
 1412               	.LBE142:
 614:setup.c       **** 	}
 615:setup.c       **** 	_delay_ms(20); // Wait sector program time
 616:setup.c       **** }
 1413               		.loc 1 616 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 617:setup.c       **** 
 618:setup.c       **** 
 619:setup.c       **** 
 620:setup.c       **** // ---------- GB FLASH CARTS ----------
 621:setup.c       **** 
 622:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 623:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 623 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 624:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 624 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 625:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 625 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 626:setup.c       **** 	
 627:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 627 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 628:setup.c       **** 	
 629:setup.c       **** 	rdPin_low;
 1443               		.loc 1 629 0
 1444 03fe 9598      		cbi 0x12,5
 630:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 630 0
 1446               	/* #APP */
 1447               	 ;  630 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 631:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 631 0
 1451               	 ;  631 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 632:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 632 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 633:setup.c       **** 	rdPin_high;
 1458               		.loc 1 633 0
 1459 0406 959A      		sbi 0x12,5
 634:setup.c       **** 	
 635:setup.c       **** 	return data;
 636:setup.c       **** }
 1460               		.loc 1 636 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_write_bus_cycle
 1467               	gb_flash_write_bus_cycle:
 1468               	.LFB37:
 637:setup.c       **** 
 638:setup.c       **** // Set the address and data for the write byte cycle to the flash
 639:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 639 0
 1470               		.cfi_startproc
 1471               	.LVL116:
 1472 040a CF93      		push r28
 1473               	.LCFI25:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 1 */
 1479               	.L__stack_usage = 1
 1480 040c C62F      		mov r28,r22
 640:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1481               		.loc 1 640 0
 1482 040e 2FEF      		ldi r18,lo8(-1)
 1483 0410 24BB      		out 0x14,r18
 641:setup.c       **** 	set_16bit_address(address);
 1484               		.loc 1 641 0
 1485 0412 00D0      		rcall set_16bit_address
 1486               	.LVL117:
 642:setup.c       **** 	PORT_DATA7_0 = data;
 1487               		.loc 1 642 0
 1488 0414 C5BB      		out 0x15,r28
 643:setup.c       **** 	
 644:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1489               		.loc 1 644 0
 1490 0416 8091 0000 		lds r24,flashWriteWePin
 1491 041a 8134      		cpi r24,lo8(65)
 1492 041c 01F4      		brne .L70
 645:setup.c       **** 		audioPin_low; // WE low
 1493               		.loc 1 645 0
 1494 041e 3998      		cbi 0x7,1
 646:setup.c       **** 		asm volatile("nop");
 1495               		.loc 1 646 0
 1496               	/* #APP */
 1497               	 ;  646 "setup.c" 1
 1498 0420 0000      		nop
 1499               	 ;  0 "" 2
 647:setup.c       **** 		asm volatile("nop");
 1500               		.loc 1 647 0
 1501               	 ;  647 "setup.c" 1
 1502 0422 0000      		nop
 1503               	 ;  0 "" 2
 648:setup.c       **** 		asm volatile("nop");
 1504               		.loc 1 648 0
 1505               	 ;  648 "setup.c" 1
 1506 0424 0000      		nop
 1507               	 ;  0 "" 2
 649:setup.c       **** 		audioPin_high; // WE high
 1508               		.loc 1 649 0
 1509               	/* #NOAPP */
 1510 0426 399A      		sbi 0x7,1
 1511 0428 00C0      		rjmp .L71
 1512               	.L70:
 650:setup.c       **** 	}
 651:setup.c       **** 	else { // WR pin
 652:setup.c       **** 		wrPin_low; // WE low
 1513               		.loc 1 652 0
 1514 042a 9698      		cbi 0x12,6
 653:setup.c       **** 		asm volatile("nop");
 1515               		.loc 1 653 0
 1516               	/* #APP */
 1517               	 ;  653 "setup.c" 1
 1518 042c 0000      		nop
 1519               	 ;  0 "" 2
 654:setup.c       **** 		asm volatile("nop");
 1520               		.loc 1 654 0
 1521               	 ;  654 "setup.c" 1
 1522 042e 0000      		nop
 1523               	 ;  0 "" 2
 655:setup.c       **** 		asm volatile("nop");
 1524               		.loc 1 655 0
 1525               	 ;  655 "setup.c" 1
 1526 0430 0000      		nop
 1527               	 ;  0 "" 2
 656:setup.c       **** 		wrPin_high; // WE high
 1528               		.loc 1 656 0
 1529               	/* #NOAPP */
 1530 0432 969A      		sbi 0x12,6
 1531               	.L71:
 657:setup.c       **** 	}
 658:setup.c       **** 	
 659:setup.c       **** 	// Clear data outputs and set data pins as inputs
 660:setup.c       **** 	PORT_DATA7_0 = 0;
 1532               		.loc 1 660 0
 1533 0434 15BA      		out 0x15,__zero_reg__
 661:setup.c       **** 	DDR_DATA7_0 = 0;
 1534               		.loc 1 661 0
 1535 0436 14BA      		out 0x14,__zero_reg__
 1536               	/* epilogue start */
 662:setup.c       **** }
 1537               		.loc 1 662 0
 1538 0438 CF91      		pop r28
 1539               	.LVL118:
 1540 043a 0895      		ret
 1541               		.cfi_endproc
 1542               	.LFE37:
 1544               	.global	gb_flash_write_byte
 1546               	gb_flash_write_byte:
 1547               	.LFB38:
 663:setup.c       **** 
 664:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 665:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1548               		.loc 1 665 0
 1549               		.cfi_startproc
 1550               	.LVL119:
 1551 043c 1F93      		push r17
 1552               	.LCFI26:
 1553               		.cfi_def_cfa_offset 3
 1554               		.cfi_offset 17, -2
 1555 043e CF93      		push r28
 1556               	.LCFI27:
 1557               		.cfi_def_cfa_offset 4
 1558               		.cfi_offset 28, -3
 1559 0440 DF93      		push r29
 1560               	.LCFI28:
 1561               		.cfi_def_cfa_offset 5
 1562               		.cfi_offset 29, -4
 1563               	/* prologue: function */
 1564               	/* frame size = 0 */
 1565               	/* stack size = 3 */
 1566               	.L__stack_usage = 3
 1567 0442 EC01      		movw r28,r24
 1568 0444 162F      		mov r17,r22
 666:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1569               		.loc 1 666 0
 1570 0446 6091 0000 		lds r22,flashWriteCycle+2
 1571               	.LVL120:
 1572 044a 8091 0000 		lds r24,flashWriteCycle
 1573 044e 9091 0000 		lds r25,flashWriteCycle+1
 1574               	.LVL121:
 1575 0452 00D0      		rcall gb_flash_write_bus_cycle
 1576               	.LVL122:
 667:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1577               		.loc 1 667 0
 1578 0454 6091 0000 		lds r22,flashWriteCycle+6
 1579 0458 8091 0000 		lds r24,flashWriteCycle+4
 1580 045c 9091 0000 		lds r25,flashWriteCycle+4+1
 1581 0460 00D0      		rcall gb_flash_write_bus_cycle
 1582               	.LVL123:
 668:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1583               		.loc 1 668 0
 1584 0462 6091 0000 		lds r22,flashWriteCycle+10
 1585 0466 8091 0000 		lds r24,flashWriteCycle+8
 1586 046a 9091 0000 		lds r25,flashWriteCycle+8+1
 1587 046e 00D0      		rcall gb_flash_write_bus_cycle
 1588               	.LVL124:
 669:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1589               		.loc 1 669 0
 1590 0470 612F      		mov r22,r17
 1591 0472 CE01      		movw r24,r28
 1592 0474 00D0      		rcall gb_flash_write_bus_cycle
 1593               	.LVL125:
 1594               	.LBB144:
 1595               	.LBB145:
 1596               		.loc 2 276 0
 1597 0476 8AE1      		ldi r24,lo8(26)
 1598 0478 8A95      	1:	dec r24
 1599 047a 01F4      		brne 1b
 1600 047c 00C0      		rjmp .
 1601               	.LVL126:
 1602               	.LBE145:
 1603               	.LBE144:
 670:setup.c       **** 	_delay_us(10); // Wait byte program time
 671:setup.c       **** 	
 672:setup.c       **** 	// Set data pins inputs
 673:setup.c       **** 	PORT_DATA7_0 = 0;
 1604               		.loc 1 673 0
 1605 047e 15BA      		out 0x15,__zero_reg__
 674:setup.c       **** 	DDR_DATA7_0 = 0;
 1606               		.loc 1 674 0
 1607 0480 14BA      		out 0x14,__zero_reg__
 675:setup.c       **** 	
 676:setup.c       **** 	// Verify data
 677:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1608               		.loc 1 677 0
 1609 0482 CE01      		movw r24,r28
 1610 0484 00D0      		rcall gb_flash_read_byte
 1611               	.LVL127:
 1612               	.L73:
 678:setup.c       **** 	while (data != dataVerify) {
 1613               		.loc 1 678 0
 1614 0486 8117      		cp r24,r17
 1615 0488 01F0      		breq .L75
 679:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1616               		.loc 1 679 0
 1617 048a CE01      		movw r24,r28
 1618               	.LVL128:
 1619 048c 00D0      		rcall gb_flash_read_byte
 1620               	.LVL129:
 1621               	.LBB146:
 1622               	.LBB147:
 1623               		.loc 2 276 0
 1624 048e 9DE0      		ldi r25,lo8(13)
 1625 0490 9A95      	1:	dec r25
 1626 0492 01F4      		brne 1b
 1627 0494 0000      		nop
 1628 0496 00C0      		rjmp .L73
 1629               	.LVL130:
 1630               	.L75:
 1631               	/* epilogue start */
 1632               	.LBE147:
 1633               	.LBE146:
 680:setup.c       **** 		_delay_us(5);
 681:setup.c       **** 	}
 682:setup.c       **** }
 1634               		.loc 1 682 0
 1635 0498 DF91      		pop r29
 1636 049a CF91      		pop r28
 1637               	.LVL131:
 1638 049c 1F91      		pop r17
 1639               	.LVL132:
 1640 049e 0895      		ret
 1641               		.cfi_endproc
 1642               	.LFE38:
 1644               	.global	gb_flash_write_byte_bank1_commands
 1646               	gb_flash_write_byte_bank1_commands:
 1647               	.LFB39:
 683:setup.c       **** 
 684:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 685:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 686:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1648               		.loc 1 686 0
 1649               		.cfi_startproc
 1650               	.LVL133:
 1651 04a0 FF92      		push r15
 1652               	.LCFI29:
 1653               		.cfi_def_cfa_offset 3
 1654               		.cfi_offset 15, -2
 1655 04a2 0F93      		push r16
 1656               	.LCFI30:
 1657               		.cfi_def_cfa_offset 4
 1658               		.cfi_offset 16, -3
 1659 04a4 1F93      		push r17
 1660               	.LCFI31:
 1661               		.cfi_def_cfa_offset 5
 1662               		.cfi_offset 17, -4
 1663 04a6 CF93      		push r28
 1664               	.LCFI32:
 1665               		.cfi_def_cfa_offset 6
 1666               		.cfi_offset 28, -5
 1667 04a8 DF93      		push r29
 1668               	.LCFI33:
 1669               		.cfi_def_cfa_offset 7
 1670               		.cfi_offset 29, -6
 1671               	/* prologue: function */
 1672               	/* frame size = 0 */
 1673               	/* stack size = 5 */
 1674               	.L__stack_usage = 5
 1675 04aa EC01      		movw r28,r24
 1676 04ac 162F      		mov r17,r22
 687:setup.c       **** 	// Set bank 1
 688:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1677               		.loc 1 688 0
 1678 04ae FF24      		clr r15
 1679 04b0 FA94      		dec r15
 1680 04b2 F4BA      		out 0x14,r15
 1681               	.LVL134:
 1682               	.LBB148:
 1683               	.LBB149:
 244:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1684               		.loc 1 244 0
 1685 04b4 01E2      		ldi r16,lo8(33)
 1686 04b6 0BBB      		out 0x1b,r16
 245:setup.c       **** }
 1687               		.loc 1 245 0
 1688 04b8 18BA      		out 0x18,__zero_reg__
 1689               	.LVL135:
 1690               	.LBE149:
 1691               	.LBE148:
 689:setup.c       **** 	set_16bit_address(0x2100);
 690:setup.c       **** 	PORT_DATA7_0 = 1;
 1692               		.loc 1 690 0
 1693 04ba 81E0      		ldi r24,lo8(1)
 1694               	.LVL136:
 1695 04bc 85BB      		out 0x15,r24
 691:setup.c       **** 	wrPin_low; // Pulse WR
 1696               		.loc 1 691 0
 1697 04be 9698      		cbi 0x12,6
 692:setup.c       **** 	asm volatile("nop");
 1698               		.loc 1 692 0
 1699               	/* #APP */
 1700               	 ;  692 "setup.c" 1
 1701 04c0 0000      		nop
 1702               	 ;  0 "" 2
 693:setup.c       **** 	wrPin_high;
 1703               		.loc 1 693 0
 1704               	/* #NOAPP */
 1705 04c2 969A      		sbi 0x12,6
 694:setup.c       **** 	
 695:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1706               		.loc 1 695 0
 1707 04c4 6091 0000 		lds r22,flashWriteCycle+2
 1708               	.LVL137:
 1709 04c8 8091 0000 		lds r24,flashWriteCycle
 1710 04cc 9091 0000 		lds r25,flashWriteCycle+1
 1711 04d0 00D0      		rcall gb_flash_write_bus_cycle
 1712               	.LVL138:
 696:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1713               		.loc 1 696 0
 1714 04d2 6091 0000 		lds r22,flashWriteCycle+6
 1715 04d6 8091 0000 		lds r24,flashWriteCycle+4
 1716 04da 9091 0000 		lds r25,flashWriteCycle+4+1
 1717 04de 00D0      		rcall gb_flash_write_bus_cycle
 1718               	.LVL139:
 697:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1719               		.loc 1 697 0
 1720 04e0 6091 0000 		lds r22,flashWriteCycle+10
 1721 04e4 8091 0000 		lds r24,flashWriteCycle+8
 1722 04e8 9091 0000 		lds r25,flashWriteCycle+8+1
 1723 04ec 00D0      		rcall gb_flash_write_bus_cycle
 1724               	.LVL140:
 698:setup.c       **** 	
 699:setup.c       **** 	
 700:setup.c       **** 	// Set bank back
 701:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1725               		.loc 1 701 0
 1726 04ee F4BA      		out 0x14,r15
 1727               	.LVL141:
 1728               	.LBB150:
 1729               	.LBB151:
 244:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1730               		.loc 1 244 0
 1731 04f0 0BBB      		out 0x1b,r16
 245:setup.c       **** }
 1732               		.loc 1 245 0
 1733 04f2 18BA      		out 0x18,__zero_reg__
 1734               	.LVL142:
 1735               	.LBE151:
 1736               	.LBE150:
 702:setup.c       **** 	set_16bit_address(0x2100);
 703:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1737               		.loc 1 703 0
 1738 04f4 8091 0000 		lds r24,lastBankAccessed
 1739 04f8 85BB      		out 0x15,r24
 704:setup.c       **** 	wrPin_low; // Pulse WR
 1740               		.loc 1 704 0
 1741 04fa 9698      		cbi 0x12,6
 705:setup.c       **** 	asm volatile("nop");
 1742               		.loc 1 705 0
 1743               	/* #APP */
 1744               	 ;  705 "setup.c" 1
 1745 04fc 0000      		nop
 1746               	 ;  0 "" 2
 706:setup.c       **** 	wrPin_high;
 1747               		.loc 1 706 0
 1748               	/* #NOAPP */
 1749 04fe 969A      		sbi 0x12,6
 707:setup.c       **** 	
 708:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1750               		.loc 1 708 0
 1751 0500 612F      		mov r22,r17
 1752 0502 CE01      		movw r24,r28
 1753 0504 00D0      		rcall gb_flash_write_bus_cycle
 1754               	.LVL143:
 1755               	.LBB152:
 1756               	.LBB153:
 1757               		.loc 2 276 0
 1758 0506 8AE1      		ldi r24,lo8(26)
 1759 0508 8A95      	1:	dec r24
 1760 050a 01F4      		brne 1b
 1761 050c 00C0      		rjmp .
 1762               	.LVL144:
 1763               	.LBE153:
 1764               	.LBE152:
 709:setup.c       **** 	_delay_us(10); // Wait byte program time
 710:setup.c       **** 	
 711:setup.c       **** 	// Set data pins inputs
 712:setup.c       **** 	PORT_DATA7_0 = 0;
 1765               		.loc 1 712 0
 1766 050e 15BA      		out 0x15,__zero_reg__
 713:setup.c       **** 	DDR_DATA7_0 = 0;
 1767               		.loc 1 713 0
 1768 0510 14BA      		out 0x14,__zero_reg__
 714:setup.c       **** 	
 715:setup.c       **** 	// Verify data
 716:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1769               		.loc 1 716 0
 1770 0512 CE01      		movw r24,r28
 1771 0514 00D0      		rcall gb_flash_read_byte
 1772               	.LVL145:
 1773               	.L77:
 717:setup.c       **** 	while (data != dataVerify) {
 1774               		.loc 1 717 0
 1775 0516 8117      		cp r24,r17
 1776 0518 01F0      		breq .L79
 718:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1777               		.loc 1 718 0
 1778 051a CE01      		movw r24,r28
 1779               	.LVL146:
 1780 051c 00D0      		rcall gb_flash_read_byte
 1781               	.LVL147:
 1782               	.LBB154:
 1783               	.LBB155:
 1784               		.loc 2 276 0
 1785 051e 9DE0      		ldi r25,lo8(13)
 1786 0520 9A95      	1:	dec r25
 1787 0522 01F4      		brne 1b
 1788 0524 0000      		nop
 1789 0526 00C0      		rjmp .L77
 1790               	.LVL148:
 1791               	.L79:
 1792               	/* epilogue start */
 1793               	.LBE155:
 1794               	.LBE154:
 719:setup.c       **** 		_delay_us(5);
 720:setup.c       **** 	}
 721:setup.c       **** }
 1795               		.loc 1 721 0
 1796 0528 DF91      		pop r29
 1797 052a CF91      		pop r28
 1798               	.LVL149:
 1799 052c 1F91      		pop r17
 1800               	.LVL150:
 1801 052e 0F91      		pop r16
 1802 0530 FF90      		pop r15
 1803 0532 0895      		ret
 1804               		.cfi_endproc
 1805               	.LFE39:
 1807               	.global	gba_flash_write_bus_cycle
 1809               	gba_flash_write_bus_cycle:
 1810               	.LFB40:
 722:setup.c       **** 
 723:setup.c       **** 
 724:setup.c       **** 
 725:setup.c       **** // ---------- GBA FLASH CARTS ----------
 726:setup.c       **** 
 727:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 728:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1811               		.loc 1 728 0
 1812               		.cfi_startproc
 1813               	.LVL151:
 1814 0534 0F93      		push r16
 1815               	.LCFI34:
 1816               		.cfi_def_cfa_offset 3
 1817               		.cfi_offset 16, -2
 1818 0536 1F93      		push r17
 1819               	.LCFI35:
 1820               		.cfi_def_cfa_offset 4
 1821               		.cfi_offset 17, -3
 1822               	/* prologue: function */
 1823               	/* frame size = 0 */
 1824               	/* stack size = 2 */
 1825               	.L__stack_usage = 2
 729:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 1826               		.loc 1 729 0
 1827 0538 8C01      		movw r16,r24
 1828 053a 2227      		clr r18
 1829 053c 3327      		clr r19
 1830 053e 05BB      		out 0x15,r16
 730:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 1831               		.loc 1 730 0
 1832 0540 072F      		mov r16,r23
 1833 0542 182F      		mov r17,r24
 1834 0544 292F      		mov r18,r25
 1835 0546 3327      		clr r19
 1836 0548 0BBB      		out 0x1b,r16
 731:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 1837               		.loc 1 731 0
 1838 054a 68BB      		out 0x18,r22
 732:setup.c       **** 	
 733:setup.c       **** 	cs_mreqPin_low;
 1839               		.loc 1 733 0
 1840 054c 9498      		cbi 0x12,4
 734:setup.c       **** 	
 735:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1841               		.loc 1 735 0
 1842 054e 5BBB      		out 0x1b,r21
 736:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1843               		.loc 1 736 0
 1844 0550 48BB      		out 0x18,r20
 737:setup.c       **** 	
 738:setup.c       **** 	wrPin_low;
 1845               		.loc 1 738 0
 1846 0552 9698      		cbi 0x12,6
 739:setup.c       **** 	asm volatile("nop");
 1847               		.loc 1 739 0
 1848               	/* #APP */
 1849               	 ;  739 "setup.c" 1
 1850 0554 0000      		nop
 1851               	 ;  0 "" 2
 740:setup.c       **** 	asm volatile("nop");
 1852               		.loc 1 740 0
 1853               	 ;  740 "setup.c" 1
 1854 0556 0000      		nop
 1855               	 ;  0 "" 2
 741:setup.c       **** 	asm volatile("nop");
 1856               		.loc 1 741 0
 1857               	 ;  741 "setup.c" 1
 1858 0558 0000      		nop
 1859               	 ;  0 "" 2
 742:setup.c       **** 	wrPin_high;
 1860               		.loc 1 742 0
 1861               	/* #NOAPP */
 1862 055a 969A      		sbi 0x12,6
 743:setup.c       **** 	cs_mreqPin_high;
 1863               		.loc 1 743 0
 1864 055c 949A      		sbi 0x12,4
 1865               	/* epilogue start */
 744:setup.c       **** }
 1866               		.loc 1 744 0
 1867 055e 1F91      		pop r17
 1868 0560 0F91      		pop r16
 1869 0562 0895      		ret
 1870               		.cfi_endproc
 1871               	.LFE40:
 1873               	.global	gba_flash_write_cycle_start_swapped
 1875               	gba_flash_write_cycle_start_swapped:
 1876               	.LFB41:
 745:setup.c       **** 
 746:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 747:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 1877               		.loc 1 747 0
 1878               		.cfi_startproc
 1879               	/* prologue: function */
 1880               	/* frame size = 0 */
 1881               	/* stack size = 0 */
 1882               	.L__stack_usage = 0
 748:setup.c       **** 	// Set outputs
 749:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 1883               		.loc 1 749 0
 1884 0564 8FEF      		ldi r24,lo8(-1)
 1885 0566 84BB      		out 0x14,r24
 750:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 1886               		.loc 1 750 0
 1887 0568 8ABB      		out 0x1a,r24
 751:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 1888               		.loc 1 751 0
 1889 056a 87BB      		out 0x17,r24
 752:setup.c       **** 	
 753:setup.c       **** 	// 0x555, 0xA9
 754:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1890               		.loc 1 754 0
 1891 056c 15BA      		out 0x15,__zero_reg__
 755:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1892               		.loc 1 755 0
 1893 056e 95E0      		ldi r25,lo8(5)
 1894 0570 9BBB      		out 0x1b,r25
 756:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1895               		.loc 1 756 0
 1896 0572 85E5      		ldi r24,lo8(85)
 1897 0574 88BB      		out 0x18,r24
 757:setup.c       **** 	cs_mreqPin_low;
 1898               		.loc 1 757 0
 1899 0576 9498      		cbi 0x12,4
 758:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1900               		.loc 1 758 0
 1901 0578 1BBA      		out 0x1b,__zero_reg__
 759:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 1902               		.loc 1 759 0
 1903 057a 29EA      		ldi r18,lo8(-87)
 1904 057c 28BB      		out 0x18,r18
 760:setup.c       **** 	wrPin_low;
 1905               		.loc 1 760 0
 1906 057e 9698      		cbi 0x12,6
 761:setup.c       **** 	asm volatile("nop");
 1907               		.loc 1 761 0
 1908               	/* #APP */
 1909               	 ;  761 "setup.c" 1
 1910 0580 0000      		nop
 1911               	 ;  0 "" 2
 762:setup.c       **** 	asm volatile("nop");
 1912               		.loc 1 762 0
 1913               	 ;  762 "setup.c" 1
 1914 0582 0000      		nop
 1915               	 ;  0 "" 2
 763:setup.c       **** 	asm volatile("nop");
 1916               		.loc 1 763 0
 1917               	 ;  763 "setup.c" 1
 1918 0584 0000      		nop
 1919               	 ;  0 "" 2
 764:setup.c       **** 	wrPin_high;
 1920               		.loc 1 764 0
 1921               	/* #NOAPP */
 1922 0586 969A      		sbi 0x12,6
 765:setup.c       **** 	cs_mreqPin_high;
 1923               		.loc 1 765 0
 1924 0588 949A      		sbi 0x12,4
 766:setup.c       **** 	
 767:setup.c       **** 	// 0x2AA, 0x56
 768:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1925               		.loc 1 768 0
 1926 058a 15BA      		out 0x15,__zero_reg__
 769:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 1927               		.loc 1 769 0
 1928 058c 22E0      		ldi r18,lo8(2)
 1929 058e 2BBB      		out 0x1b,r18
 770:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 1930               		.loc 1 770 0
 1931 0590 2AEA      		ldi r18,lo8(-86)
 1932 0592 28BB      		out 0x18,r18
 771:setup.c       **** 	cs_mreqPin_low;
 1933               		.loc 1 771 0
 1934 0594 9498      		cbi 0x12,4
 772:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1935               		.loc 1 772 0
 1936 0596 1BBA      		out 0x1b,__zero_reg__
 773:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 1937               		.loc 1 773 0
 1938 0598 26E5      		ldi r18,lo8(86)
 1939 059a 28BB      		out 0x18,r18
 774:setup.c       **** 	wrPin_low;
 1940               		.loc 1 774 0
 1941 059c 9698      		cbi 0x12,6
 775:setup.c       **** 	asm volatile("nop");
 1942               		.loc 1 775 0
 1943               	/* #APP */
 1944               	 ;  775 "setup.c" 1
 1945 059e 0000      		nop
 1946               	 ;  0 "" 2
 776:setup.c       **** 	asm volatile("nop");
 1947               		.loc 1 776 0
 1948               	 ;  776 "setup.c" 1
 1949 05a0 0000      		nop
 1950               	 ;  0 "" 2
 777:setup.c       **** 	asm volatile("nop");
 1951               		.loc 1 777 0
 1952               	 ;  777 "setup.c" 1
 1953 05a2 0000      		nop
 1954               	 ;  0 "" 2
 778:setup.c       **** 	wrPin_high;
 1955               		.loc 1 778 0
 1956               	/* #NOAPP */
 1957 05a4 969A      		sbi 0x12,6
 779:setup.c       **** 	cs_mreqPin_high;
 1958               		.loc 1 779 0
 1959 05a6 949A      		sbi 0x12,4
 780:setup.c       **** 	
 781:setup.c       **** 	// 0x555, 0xA0;
 782:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1960               		.loc 1 782 0
 1961 05a8 15BA      		out 0x15,__zero_reg__
 783:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1962               		.loc 1 783 0
 1963 05aa 9BBB      		out 0x1b,r25
 784:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1964               		.loc 1 784 0
 1965 05ac 88BB      		out 0x18,r24
 785:setup.c       **** 	cs_mreqPin_low;
 1966               		.loc 1 785 0
 1967 05ae 9498      		cbi 0x12,4
 786:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1968               		.loc 1 786 0
 1969 05b0 1BBA      		out 0x1b,__zero_reg__
 787:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 1970               		.loc 1 787 0
 1971 05b2 80EA      		ldi r24,lo8(-96)
 1972 05b4 88BB      		out 0x18,r24
 788:setup.c       **** 	wrPin_low;
 1973               		.loc 1 788 0
 1974 05b6 9698      		cbi 0x12,6
 789:setup.c       **** 	asm volatile("nop");
 1975               		.loc 1 789 0
 1976               	/* #APP */
 1977               	 ;  789 "setup.c" 1
 1978 05b8 0000      		nop
 1979               	 ;  0 "" 2
 790:setup.c       **** 	asm volatile("nop");
 1980               		.loc 1 790 0
 1981               	 ;  790 "setup.c" 1
 1982 05ba 0000      		nop
 1983               	 ;  0 "" 2
 791:setup.c       **** 	asm volatile("nop");
 1984               		.loc 1 791 0
 1985               	 ;  791 "setup.c" 1
 1986 05bc 0000      		nop
 1987               	 ;  0 "" 2
 792:setup.c       **** 	wrPin_high;
 1988               		.loc 1 792 0
 1989               	/* #NOAPP */
 1990 05be 969A      		sbi 0x12,6
 793:setup.c       **** 	cs_mreqPin_high;
 1991               		.loc 1 793 0
 1992 05c0 949A      		sbi 0x12,4
 1993 05c2 0895      		ret
 1994               		.cfi_endproc
 1995               	.LFE41:
 1997               	.global	gba_flash_write_cycle_start
 1999               	gba_flash_write_cycle_start:
 2000               	.LFB42:
 794:setup.c       **** }
 795:setup.c       **** 
 796:setup.c       **** 
 797:setup.c       **** // Send the first 3 write cycles to the flash
 798:setup.c       **** void gba_flash_write_cycle_start(void) {
 2001               		.loc 1 798 0
 2002               		.cfi_startproc
 2003               	/* prologue: function */
 2004               	/* frame size = 0 */
 2005               	/* stack size = 0 */
 2006               	.L__stack_usage = 0
 799:setup.c       **** 	// Set outputs
 800:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2007               		.loc 1 800 0
 2008 05c4 8FEF      		ldi r24,lo8(-1)
 2009 05c6 84BB      		out 0x14,r24
 801:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2010               		.loc 1 801 0
 2011 05c8 8ABB      		out 0x1a,r24
 802:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2012               		.loc 1 802 0
 2013 05ca 87BB      		out 0x17,r24
 803:setup.c       **** 	
 804:setup.c       **** 	// 0x555, 0xAA
 805:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2014               		.loc 1 805 0
 2015 05cc 15BA      		out 0x15,__zero_reg__
 806:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2016               		.loc 1 806 0
 2017 05ce 95E0      		ldi r25,lo8(5)
 2018 05d0 9BBB      		out 0x1b,r25
 807:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2019               		.loc 1 807 0
 2020 05d2 85E5      		ldi r24,lo8(85)
 2021 05d4 88BB      		out 0x18,r24
 808:setup.c       **** 	cs_mreqPin_low;
 2022               		.loc 1 808 0
 2023 05d6 9498      		cbi 0x12,4
 809:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2024               		.loc 1 809 0
 2025 05d8 1BBA      		out 0x1b,__zero_reg__
 810:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2026               		.loc 1 810 0
 2027 05da 2AEA      		ldi r18,lo8(-86)
 2028 05dc 28BB      		out 0x18,r18
 811:setup.c       **** 	wrPin_low;
 2029               		.loc 1 811 0
 2030 05de 9698      		cbi 0x12,6
 812:setup.c       **** 	asm volatile("nop");
 2031               		.loc 1 812 0
 2032               	/* #APP */
 2033               	 ;  812 "setup.c" 1
 2034 05e0 0000      		nop
 2035               	 ;  0 "" 2
 813:setup.c       **** 	asm volatile("nop");
 2036               		.loc 1 813 0
 2037               	 ;  813 "setup.c" 1
 2038 05e2 0000      		nop
 2039               	 ;  0 "" 2
 814:setup.c       **** 	asm volatile("nop");
 2040               		.loc 1 814 0
 2041               	 ;  814 "setup.c" 1
 2042 05e4 0000      		nop
 2043               	 ;  0 "" 2
 815:setup.c       **** 	wrPin_high;
 2044               		.loc 1 815 0
 2045               	/* #NOAPP */
 2046 05e6 969A      		sbi 0x12,6
 816:setup.c       **** 	cs_mreqPin_high;
 2047               		.loc 1 816 0
 2048 05e8 949A      		sbi 0x12,4
 817:setup.c       **** 	
 818:setup.c       **** 	// 0x2AA, 0x55
 819:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2049               		.loc 1 819 0
 2050 05ea 15BA      		out 0x15,__zero_reg__
 820:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2051               		.loc 1 820 0
 2052 05ec 32E0      		ldi r19,lo8(2)
 2053 05ee 3BBB      		out 0x1b,r19
 821:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2054               		.loc 1 821 0
 2055 05f0 28BB      		out 0x18,r18
 822:setup.c       **** 	cs_mreqPin_low;
 2056               		.loc 1 822 0
 2057 05f2 9498      		cbi 0x12,4
 823:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2058               		.loc 1 823 0
 2059 05f4 1BBA      		out 0x1b,__zero_reg__
 824:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2060               		.loc 1 824 0
 2061 05f6 88BB      		out 0x18,r24
 825:setup.c       **** 	wrPin_low;
 2062               		.loc 1 825 0
 2063 05f8 9698      		cbi 0x12,6
 826:setup.c       **** 	asm volatile("nop");
 2064               		.loc 1 826 0
 2065               	/* #APP */
 2066               	 ;  826 "setup.c" 1
 2067 05fa 0000      		nop
 2068               	 ;  0 "" 2
 827:setup.c       **** 	asm volatile("nop");
 2069               		.loc 1 827 0
 2070               	 ;  827 "setup.c" 1
 2071 05fc 0000      		nop
 2072               	 ;  0 "" 2
 828:setup.c       **** 	asm volatile("nop");
 2073               		.loc 1 828 0
 2074               	 ;  828 "setup.c" 1
 2075 05fe 0000      		nop
 2076               	 ;  0 "" 2
 829:setup.c       **** 	wrPin_high;
 2077               		.loc 1 829 0
 2078               	/* #NOAPP */
 2079 0600 969A      		sbi 0x12,6
 830:setup.c       **** 	cs_mreqPin_high;
 2080               		.loc 1 830 0
 2081 0602 949A      		sbi 0x12,4
 831:setup.c       **** 	
 832:setup.c       **** 	// 0x555, 0xA0;
 833:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2082               		.loc 1 833 0
 2083 0604 15BA      		out 0x15,__zero_reg__
 834:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2084               		.loc 1 834 0
 2085 0606 9BBB      		out 0x1b,r25
 835:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2086               		.loc 1 835 0
 2087 0608 88BB      		out 0x18,r24
 836:setup.c       **** 	cs_mreqPin_low;
 2088               		.loc 1 836 0
 2089 060a 9498      		cbi 0x12,4
 837:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2090               		.loc 1 837 0
 2091 060c 1BBA      		out 0x1b,__zero_reg__
 838:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2092               		.loc 1 838 0
 2093 060e 80EA      		ldi r24,lo8(-96)
 2094 0610 88BB      		out 0x18,r24
 839:setup.c       **** 	wrPin_low;
 2095               		.loc 1 839 0
 2096 0612 9698      		cbi 0x12,6
 840:setup.c       **** 	asm volatile("nop");
 2097               		.loc 1 840 0
 2098               	/* #APP */
 2099               	 ;  840 "setup.c" 1
 2100 0614 0000      		nop
 2101               	 ;  0 "" 2
 841:setup.c       **** 	asm volatile("nop");
 2102               		.loc 1 841 0
 2103               	 ;  841 "setup.c" 1
 2104 0616 0000      		nop
 2105               	 ;  0 "" 2
 842:setup.c       **** 	asm volatile("nop");
 2106               		.loc 1 842 0
 2107               	 ;  842 "setup.c" 1
 2108 0618 0000      		nop
 2109               	 ;  0 "" 2
 843:setup.c       **** 	wrPin_high;
 2110               		.loc 1 843 0
 2111               	/* #NOAPP */
 2112 061a 969A      		sbi 0x12,6
 844:setup.c       **** 	cs_mreqPin_high;
 2113               		.loc 1 844 0
 2114 061c 949A      		sbi 0x12,4
 2115 061e 0895      		ret
 2116               		.cfi_endproc
 2117               	.LFE42:
 2119               	.global	gba_flash_write_byte
 2121               	gba_flash_write_byte:
 2122               	.LFB43:
 845:setup.c       **** }	
 846:setup.c       **** 
 847:setup.c       **** 
 848:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 849:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 850:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2123               		.loc 1 850 0
 2124               		.cfi_startproc
 2125               	.LVL152:
 2126 0620 CF92      		push r12
 2127               	.LCFI36:
 2128               		.cfi_def_cfa_offset 3
 2129               		.cfi_offset 12, -2
 2130 0622 DF92      		push r13
 2131               	.LCFI37:
 2132               		.cfi_def_cfa_offset 4
 2133               		.cfi_offset 13, -3
 2134 0624 EF92      		push r14
 2135               	.LCFI38:
 2136               		.cfi_def_cfa_offset 5
 2137               		.cfi_offset 14, -4
 2138 0626 FF92      		push r15
 2139               	.LCFI39:
 2140               		.cfi_def_cfa_offset 6
 2141               		.cfi_offset 15, -5
 2142 0628 CF93      		push r28
 2143               	.LCFI40:
 2144               		.cfi_def_cfa_offset 7
 2145               		.cfi_offset 28, -6
 2146 062a DF93      		push r29
 2147               	.LCFI41:
 2148               		.cfi_def_cfa_offset 8
 2149               		.cfi_offset 29, -7
 2150               	/* prologue: function */
 2151               	/* frame size = 0 */
 2152               	/* stack size = 6 */
 2153               	.L__stack_usage = 6
 2154 062c 6B01      		movw r12,r22
 2155 062e 7C01      		movw r14,r24
 2156 0630 EA01      		movw r28,r20
 851:setup.c       **** 	if (isD0D1Swapped == 0) {
 2157               		.loc 1 851 0
 2158 0632 2111      		cpse r18,__zero_reg__
 2159 0634 00C0      		rjmp .L84
 852:setup.c       **** 		gba_flash_write_cycle_start();
 2160               		.loc 1 852 0
 2161 0636 00D0      		rcall gba_flash_write_cycle_start
 2162               	.LVL153:
 2163 0638 00C0      		rjmp .L85
 2164               	.LVL154:
 2165               	.L84:
 853:setup.c       **** 	}
 854:setup.c       **** 	else {
 855:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2166               		.loc 1 855 0
 2167 063a 00D0      		rcall gba_flash_write_cycle_start_swapped
 2168               	.LVL155:
 2169               	.L85:
 856:setup.c       **** 	}
 857:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2170               		.loc 1 857 0
 2171 063c AE01      		movw r20,r28
 2172 063e C701      		movw r24,r14
 2173 0640 B601      		movw r22,r12
 2174 0642 00D0      		rcall gba_flash_write_bus_cycle
 2175               	.LVL156:
 2176               	.LBB156:
 2177               	.LBB157:
 2178               		.loc 2 276 0
 2179 0644 25E0      		ldi r18,lo8(5)
 2180 0646 2A95      	1:	dec r18
 2181 0648 01F4      		brne 1b
 2182 064a 0000      		nop
 2183               	.LVL157:
 2184               	.LBE157:
 2185               	.LBE156:
 858:setup.c       **** 	_delay_us(2); // Wait byte program time
 859:setup.c       **** 	
 860:setup.c       **** 	// Verify data
 861:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2186               		.loc 1 861 0
 2187 064c C701      		movw r24,r14
 2188 064e B601      		movw r22,r12
 2189 0650 00D0      		rcall gba_read_16bit_data
 2190               	.LVL158:
 2191               	.L86:
 862:setup.c       **** 	while (data != dataVerify) {
 2192               		.loc 1 862 0
 2193 0652 8C17      		cp r24,r28
 2194 0654 9D07      		cpc r25,r29
 2195 0656 01F0      		breq .L88
 863:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2196               		.loc 1 863 0
 2197 0658 C701      		movw r24,r14
 2198 065a B601      		movw r22,r12
 2199 065c 00D0      		rcall gba_read_16bit_data
 2200               	.LVL159:
 2201               	.LBB158:
 2202               	.LBB159:
 2203               		.loc 2 276 0
 2204 065e 25E0      		ldi r18,lo8(5)
 2205 0660 2A95      	1:	dec r18
 2206 0662 01F4      		brne 1b
 2207 0664 0000      		nop
 2208 0666 00C0      		rjmp .L86
 2209               	.LVL160:
 2210               	.L88:
 2211               	/* epilogue start */
 2212               	.LBE159:
 2213               	.LBE158:
 864:setup.c       **** 		_delay_us(2);
 865:setup.c       **** 	}
 866:setup.c       **** }
 2214               		.loc 1 866 0
 2215 0668 DF91      		pop r29
 2216 066a CF91      		pop r28
 2217               	.LVL161:
 2218 066c FF90      		pop r15
 2219 066e EF90      		pop r14
 2220 0670 DF90      		pop r13
 2221 0672 CF90      		pop r12
 2222               	.LVL162:
 2223 0674 0895      		ret
 2224               		.cfi_endproc
 2225               	.LFE43:
 2227               	.global	setup
 2229               	setup:
 2230               	.LFB44:
 867:setup.c       **** 
 868:setup.c       **** 
 869:setup.c       **** // Setup
 870:setup.c       **** void setup(void) {
 2231               		.loc 1 870 0
 2232               		.cfi_startproc
 2233               	/* prologue: function */
 2234               	/* frame size = 0 */
 2235               	/* stack size = 0 */
 2236               	.L__stack_usage = 0
 871:setup.c       **** 	// Turn off watchdog
 872:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2237               		.loc 1 872 0
 2238 0676 84B7      		in r24,0x34
 2239 0678 877F      		andi r24,lo8(-9)
 2240 067a 84BF      		out 0x34,r24
 873:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2241               		.loc 1 873 0
 2242 067c 88E1      		ldi r24,lo8(24)
 2243 067e 81BD      		out 0x21,r24
 874:setup.c       **** 	WDTCR = 0;
 2244               		.loc 1 874 0
 2245 0680 11BC      		out 0x21,__zero_reg__
 875:setup.c       **** 	
 876:setup.c       **** 	// Reset common lines
 877:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2246               		.loc 1 877 0
 2247 0682 00D0      		rcall rd_wr_csmreq_cs2_reset
 2248               	.LVL163:
 878:setup.c       **** 	
 879:setup.c       **** 	// Set outputs
 880:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 2249               		.loc 1 880 0
 2250 0684 81B3      		in r24,0x11
 2251 0686 886F      		ori r24,lo8(-8)
 2252 0688 81BB      		out 0x11,r24
 881:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2253               		.loc 1 881 0
 2254 068a 86B1      		in r24,0x6
 2255 068c 8560      		ori r24,lo8(5)
 2256 068e 86B9      		out 0x6,r24
 882:setup.c       **** 	
 883:setup.c       **** 	// Set all pins as inputs
 884:setup.c       **** 	PORT_DATA7_0 = 0;
 2257               		.loc 1 884 0
 2258 0690 15BA      		out 0x15,__zero_reg__
 885:setup.c       **** 	DDR_DATA7_0 = 0;
 2259               		.loc 1 885 0
 2260 0692 14BA      		out 0x14,__zero_reg__
 886:setup.c       **** 	PORT_ADDR7_0 = 0;
 2261               		.loc 1 886 0
 2262 0694 18BA      		out 0x18,__zero_reg__
 887:setup.c       **** 	DDR_ADDR7_0 = 0;
 2263               		.loc 1 887 0
 2264 0696 17BA      		out 0x17,__zero_reg__
 888:setup.c       **** 	PORT_ADDR15_8 = 0;
 2265               		.loc 1 888 0
 2266 0698 1BBA      		out 0x1b,__zero_reg__
 889:setup.c       **** 	DDR_ADDR15_8 = 0;
 2267               		.loc 1 889 0
 2268 069a 1ABA      		out 0x1a,__zero_reg__
 890:setup.c       **** 	
 891:setup.c       **** 	// Light up 3.3V or 5V
 892:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 2269               		.loc 1 892 0
 2270 069c 829B      		sbis 0x10,2
 2271 069e 00C0      		rjmp .L90
 893:setup.c       **** 		PORTD |= (1<<LED_5V);
 2272               		.loc 1 893 0
 2273 06a0 979A      		sbi 0x12,7
 894:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2274               		.loc 1 894 0
 2275 06a2 3898      		cbi 0x7,0
 895:setup.c       **** 		
 896:setup.c       **** 		// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 897:setup.c       **** 		cs2Pin_low;
 2276               		.loc 1 897 0
 2277 06a4 3A98      		cbi 0x7,2
 2278               	.LVL164:
 2279               	.LBB160:
 2280               	.LBB161:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2281               		.loc 2 187 0
 2282 06a6 2FE7      		ldi r18,lo8(79999)
 2283 06a8 88E3      		ldi r24,hi8(79999)
 2284 06aa 91E0      		ldi r25,hlo8(79999)
 2285 06ac 2150      	1:	subi r18,1
 2286 06ae 8040      		sbci r24,0
 2287 06b0 9040      		sbci r25,0
 2288 06b2 01F4      		brne 1b
 2289 06b4 00C0      		rjmp .
 2290 06b6 0000      		nop
 2291               	.LVL165:
 2292               	.LBE161:
 2293               	.LBE160:
 898:setup.c       **** 		_delay_ms(50);
 899:setup.c       **** 		cs2Pin_high;
 2294               		.loc 1 899 0
 2295 06b8 3A9A      		sbi 0x7,2
 2296 06ba 00C0      		rjmp .L91
 2297               	.L90:
 900:setup.c       **** 	}
 901:setup.c       **** 	else {
 902:setup.c       **** 		PORTE |= (1<<LED_3V);
 2298               		.loc 1 902 0
 2299 06bc 389A      		sbi 0x7,0
 903:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2300               		.loc 1 903 0
 2301 06be 9798      		cbi 0x12,7
 2302               	.L91:
 904:setup.c       **** 	}
 905:setup.c       **** 	
 906:setup.c       **** 	// Light LED
 907:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2303               		.loc 1 907 0
 2304 06c0 939A      		sbi 0x12,3
 2305               	.LVL166:
 2306               	.LBB162:
 2307               	.LBB163:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2308               		.loc 2 187 0
 2309 06c2 2FEF      		ldi r18,lo8(799999)
 2310 06c4 84E3      		ldi r24,hi8(799999)
 2311 06c6 9CE0      		ldi r25,hlo8(799999)
 2312 06c8 2150      	1:	subi r18,1
 2313 06ca 8040      		sbci r24,0
 2314 06cc 9040      		sbci r25,0
 2315 06ce 01F4      		brne 1b
 2316 06d0 00C0      		rjmp .
 2317 06d2 0000      		nop
 2318               	.LVL167:
 2319               	.LBE163:
 2320               	.LBE162:
 908:setup.c       **** 	_delay_ms(500);
 909:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2321               		.loc 1 909 0
 2322 06d4 9398      		cbi 0x12,3
 910:setup.c       **** 	
 911:setup.c       **** 	// Setup USART
 912:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2323               		.loc 1 912 0
 2324 06d6 19B8      		out 0x9,__zero_reg__
 913:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2325               		.loc 1 913 0
 2326 06d8 599A      		sbi 0xb,1
 914:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2327               		.loc 1 914 0
 2328 06da 539A      		sbi 0xa,3
 915:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2329               		.loc 1 915 0
 2330 06dc 549A      		sbi 0xa,4
 916:setup.c       **** 	
 917:setup.c       **** 	// Turn on interrupts
 918:setup.c       **** 	sei();
 2331               		.loc 1 918 0
 2332               	/* #APP */
 2333               	 ;  918 "setup.c" 1
 2334 06de 7894      		sei
 2335               	 ;  0 "" 2
 2336               	/* #NOAPP */
 2337 06e0 0895      		ret
 2338               		.cfi_endproc
 2339               	.LFE44:
 2341               		.section	.text.startup,"ax",@progbits
 2342               	.global	main
 2344               	main:
 2345               	.LFB45:
 2346               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R14
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 15/05/2019
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 2
  53:main.c        **** #define FIRMWARE_VERSION 14
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2347               		.loc 3 66 0
 2348               		.cfi_startproc
 2349 0000 CF93      		push r28
 2350               	.LCFI42:
 2351               		.cfi_def_cfa_offset 3
 2352               		.cfi_offset 28, -2
 2353 0002 DF93      		push r29
 2354               	.LCFI43:
 2355               		.cfi_def_cfa_offset 4
 2356               		.cfi_offset 29, -3
 2357 0004 00D0      		rcall .
 2358               	.LCFI44:
 2359               		.cfi_def_cfa_offset 6
 2360 0006 CDB7      		in r28,__SP_L__
 2361 0008 DEB7      		in r29,__SP_H__
 2362               	.LCFI45:
 2363               		.cfi_def_cfa_register 28
 2364               	/* prologue: function */
 2365               	/* frame size = 2 */
 2366               	/* stack size = 4 */
 2367               	.L__stack_usage = 4
  67:main.c        **** 	setup();
 2368               		.loc 3 67 0
 2369 000a 00D0      		rcall setup
 2370               	.LVL168:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t cartMode = GB_MODE;
  72:main.c        **** 	uint8_t resetCommonLines = 1;
 2371               		.loc 3 72 0
 2372 000c 21E0      		ldi r18,lo8(1)
 2373 000e 2983      		std Y+1,r18
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
 2374               		.loc 3 70 0
 2375 0010 81E0      		ldi r24,lo8(1)
 2376 0012 8A83      		std Y+2,r24
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2377               		.loc 3 69 0
 2378 0014 C12C      		mov r12,__zero_reg__
 2379 0016 D12C      		mov r13,__zero_reg__
 2380 0018 7601      		movw r14,r12
 2381 001a B0E0      		ldi r27,lo8(eepromBuffer+8)
 2382 001c 6B2E      		mov r6,r27
 2383 001e B0E0      		ldi r27,hi8(eepromBuffer+8)
 2384 0020 7B2E      		mov r7,r27
 2385               	.LVL169:
 2386               	.L93:
  73:main.c        **** 	
  74:main.c        **** 	while(1) {
  75:main.c        **** 		if (resetCommonLines == 1) {
 2387               		.loc 3 75 0
 2388 0022 E981      		ldd r30,Y+1
 2389 0024 E130      		cpi r30,lo8(1)
 2390 0026 01F4      		brne .L94
 2391               	.LVL170:
 2392               	.L230:
  76:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2393               		.loc 3 76 0
 2394 0028 00D0      		rcall rd_wr_csmreq_cs2_reset
 2395               	.LVL171:
 2396               	.L94:
  77:main.c        **** 		}
  78:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 2397               		.loc 3 78 0
 2398 002a 00D0      		rcall USART_Receive
 2399               	.LVL172:
 2400 002c 8093 0000 		sts receivedChar,r24
  79:main.c        **** 		
  80:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  81:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 2401               		.loc 3 81 0
 2402 0030 829B      		sbis 0x10,2
 2403 0032 00C0      		rjmp .L95
 2404               	.LVL173:
  82:main.c        **** 			cartMode = GB_MODE;
  83:main.c        **** 			PORTD |= (1<<LED_5V);
 2405               		.loc 3 83 0
 2406 0034 979A      		sbi 0x12,7
  84:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2407               		.loc 3 84 0
 2408 0036 3898      		cbi 0x7,0
  82:main.c        **** 			cartMode = GB_MODE;
 2409               		.loc 3 82 0
 2410 0038 81E0      		ldi r24,lo8(1)
 2411 003a 00C0      		rjmp .L96
 2412               	.LVL174:
 2413               	.L95:
  85:main.c        **** 		}
  86:main.c        **** 		else {
  87:main.c        **** 			cartMode = GBA_MODE;
  88:main.c        **** 			PORTE |= (1<<LED_3V);
 2414               		.loc 3 88 0
 2415 003c 389A      		sbi 0x7,0
  89:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2416               		.loc 3 89 0
 2417 003e 9798      		cbi 0x12,7
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 2418               		.loc 3 87 0
 2419 0040 82E0      		ldi r24,lo8(2)
 2420               	.LVL175:
 2421               	.L96:
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Return the cart mode in use
  93:main.c        **** 		if (receivedChar == CART_MODE) {
 2422               		.loc 3 93 0
 2423 0042 9091 0000 		lds r25,receivedChar
 2424 0046 9334      		cpi r25,lo8(67)
 2425 0048 01F4      		brne .+2
 2426 004a 00C0      		rjmp .L231
  94:main.c        **** 			USART_Transmit(cartMode);
  95:main.c        **** 		}
  96:main.c        **** 		
  97:main.c        **** 		// Change to GB mode or GBA mode if requested
  98:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2427               		.loc 3 98 0
 2428 004c 9734      		cpi r25,lo8(71)
 2429 004e 01F4      		brne .L99
  99:main.c        **** 			gb_mode();
 2430               		.loc 3 99 0
 2431 0050 00D0      		rcall gb_mode
 2432               	.LVL176:
 2433 0052 00C0      		rjmp .L93
 2434               	.LVL177:
 2435               	.L99:
 100:main.c        **** 		}
 101:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2436               		.loc 3 101 0
 2437 0054 9736      		cpi r25,lo8(103)
 2438 0056 01F4      		brne .+2
 2439 0058 00C0      		rjmp .L233
 102:main.c        **** 			gba_mode();
 103:main.c        **** 		}
 104:main.c        **** 		
 105:main.c        **** 		// Set address
 106:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2440               		.loc 3 106 0
 2441 005a 9134      		cpi r25,lo8(65)
 2442 005c 01F4      		brne .L101
 107:main.c        **** 			usart_read_chars(); // Read start address
 2443               		.loc 3 107 0
 2444 005e 00D0      		rcall usart_read_chars
 2445               	.LVL178:
 108:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2446               		.loc 3 108 0
 2447 0060 40E1      		ldi r20,lo8(16)
 2448 0062 50E0      		ldi r21,0
 2449 0064 60E0      		ldi r22,0
 2450 0066 70E0      		ldi r23,0
 2451 0068 80E0      		ldi r24,lo8(receivedBuffer)
 2452 006a 90E0      		ldi r25,hi8(receivedBuffer)
 2453 006c 00D0      		rcall strtol
 2454               	.LVL179:
 2455 006e 6B01      		movw r12,r22
 2456 0070 7C01      		movw r14,r24
 2457               	.LVL180:
 2458 0072 00C0      		rjmp .L93
 2459               	.LVL181:
 2460               	.L101:
 109:main.c        **** 		}
 110:main.c        **** 		
 111:main.c        **** 		
 112:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 113:main.c        **** 		
 114:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 115:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2461               		.loc 3 115 0
 2462 0074 9235      		cpi r25,lo8(82)
 2463 0076 01F4      		brne .L102
 116:main.c        **** 			gb_mode();
 2464               		.loc 3 116 0
 2465 0078 00D0      		rcall gb_mode
 2466               	.LVL182:
 117:main.c        **** 			receivedChar = '1';
 2467               		.loc 3 117 0
 2468 007a F1E3      		ldi r31,lo8(49)
 2469 007c F093 0000 		sts receivedChar,r31
 2470               	.LVL183:
 2471               	.L103:
 118:main.c        **** 			while (receivedChar == '1') {
 2472               		.loc 3 118 0
 2473 0080 8091 0000 		lds r24,receivedChar
 2474 0084 8133      		cpi r24,lo8(49)
 2475 0086 01F4      		brne .L93
 119:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2476               		.loc 3 119 0
 2477 0088 939A      		sbi 0x12,3
 2478               	.LVL184:
 2479 008a 00E0      		ldi r16,0
 2480 008c 10E0      		ldi r17,0
 2481               	.LVL185:
 2482               	.L104:
 2483               	.LBB164:
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 121:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2484               		.loc 3 121 0 discriminator 3
 2485 008e C801      		movw r24,r16
 2486 0090 8C0D      		add r24,r12
 2487 0092 9D1D      		adc r25,r13
 2488 0094 00D0      		rcall read_8bit_data
 2489               	.LVL186:
 2490 0096 00D0      		rcall USART_Transmit
 2491               	.LVL187:
 2492 0098 0F5F      		subi r16,-1
 2493 009a 1F4F      		sbci r17,-1
 2494               	.LVL188:
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2495               		.loc 3 120 0 discriminator 3
 2496 009c 0034      		cpi r16,64
 2497 009e 1105      		cpc r17,__zero_reg__
 2498 00a0 01F4      		brne .L104
 2499 00a2 20E4      		ldi r18,64
 2500 00a4 C20E      		add r12,r18
 2501 00a6 D11C      		adc r13,__zero_reg__
 2502 00a8 E11C      		adc r14,__zero_reg__
 2503 00aa F11C      		adc r15,__zero_reg__
 2504               	.LBE164:
 122:main.c        **** 					address++;
 123:main.c        **** 				}
 124:main.c        **** 				
 125:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2505               		.loc 3 125 0
 2506 00ac 9398      		cbi 0x12,3
 126:main.c        **** 				receivedChar = USART_Receive();
 2507               		.loc 3 126 0
 2508 00ae 00D0      		rcall USART_Receive
 2509               	.LVL189:
 2510 00b0 8093 0000 		sts receivedChar,r24
 2511 00b4 00C0      		rjmp .L103
 2512               	.LVL190:
 2513               	.L102:
 127:main.c        **** 			}
 128:main.c        **** 		}
 129:main.c        **** 		
 130:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 131:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2514               		.loc 3 131 0
 2515 00b6 9735      		cpi r25,lo8(87)
 2516 00b8 01F4      		brne .L106
 132:main.c        **** 			gb_mode();
 2517               		.loc 3 132 0
 2518 00ba 00D0      		rcall gb_mode
 2519               	.LVL191:
 133:main.c        **** 			
 134:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 135:main.c        **** 			usart_read_bytes(64);
 2520               		.loc 3 135 0
 2521 00bc 80E4      		ldi r24,lo8(64)
 2522 00be 90E0      		ldi r25,0
 2523 00c0 00D0      		rcall usart_read_bytes
 2524               	.LVL192:
 136:main.c        **** 			
 137:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2525               		.loc 3 137 0
 2526 00c2 939A      		sbi 0x12,3
 2527               	.LVL193:
 2528 00c4 A0E0      		ldi r26,lo8(receivedBuffer)
 2529 00c6 AA2E      		mov r10,r26
 2530 00c8 A0E0      		ldi r26,hi8(receivedBuffer)
 2531 00ca BA2E      		mov r11,r26
 2532 00cc 00E0      		ldi r16,0
 2533 00ce 10E0      		ldi r17,0
 2534               	.LVL194:
 2535               	.L107:
 2536               	.LBB165:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 139:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2537               		.loc 3 139 0 discriminator 3
 2538 00d0 F501      		movw r30,r10
 2539 00d2 6191      		ld r22,Z+
 2540 00d4 5F01      		movw r10,r30
 2541 00d6 C801      		movw r24,r16
 2542 00d8 8C0D      		add r24,r12
 2543 00da 9D1D      		adc r25,r13
 2544 00dc 41E0      		ldi r20,lo8(1)
 2545 00de 00D0      		rcall write_8bit_data
 2546               	.LVL195:
 2547 00e0 0F5F      		subi r16,-1
 2548 00e2 1F4F      		sbci r17,-1
 2549               	.LVL196:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2550               		.loc 3 138 0 discriminator 3
 2551 00e4 0034      		cpi r16,64
 2552 00e6 1105      		cpc r17,__zero_reg__
 2553 00e8 01F4      		brne .L107
 2554 00ea F0E4      		ldi r31,64
 2555 00ec CF0E      		add r12,r31
 2556 00ee D11C      		adc r13,__zero_reg__
 2557 00f0 E11C      		adc r14,__zero_reg__
 2558 00f2 F11C      		adc r15,__zero_reg__
 2559 00f4 00C0      		rjmp .L251
 2560               	.LVL197:
 2561               	.L106:
 2562               	.LBE165:
 140:main.c        **** 				address++;
 141:main.c        **** 			}
 142:main.c        **** 			
 143:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 144:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 145:main.c        **** 		}
 146:main.c        **** 		
 147:main.c        **** 		// Set bank address and write a byte
 148:main.c        **** 		else if (receivedChar == SET_BANK) {
 2563               		.loc 3 148 0
 2564 00f6 9234      		cpi r25,lo8(66)
 2565 00f8 01F4      		brne .L108
 2566               	.LBB166:
 149:main.c        **** 			gb_mode();
 2567               		.loc 3 149 0
 2568 00fa 00D0      		rcall gb_mode
 2569               	.LVL198:
 150:main.c        **** 			
 151:main.c        **** 			usart_read_chars(); // Read start address
 2570               		.loc 3 151 0
 2571 00fc 00D0      		rcall usart_read_chars
 2572               	.LVL199:
 152:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2573               		.loc 3 152 0
 2574 00fe 40E1      		ldi r20,lo8(16)
 2575 0100 50E0      		ldi r21,0
 2576 0102 60E0      		ldi r22,0
 2577 0104 70E0      		ldi r23,0
 2578 0106 80E0      		ldi r24,lo8(receivedBuffer)
 2579 0108 90E0      		ldi r25,hi8(receivedBuffer)
 2580 010a 00D0      		rcall strtol
 2581               	.LVL200:
 2582 010c 4B01      		movw r8,r22
 2583 010e 5C01      		movw r10,r24
 2584               	.LVL201:
 153:main.c        **** 			
 154:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2585               		.loc 3 154 0
 2586 0110 00D0      		rcall USART_Receive
 2587               	.LVL202:
 2588 0112 8093 0000 		sts receivedChar,r24
 155:main.c        **** 			if (receivedChar == 'B') {
 2589               		.loc 3 155 0
 2590 0116 8234      		cpi r24,lo8(66)
 2591 0118 01F0      		breq .+2
 2592 011a 00C0      		rjmp .L93
 2593               	.LBB167:
 156:main.c        **** 				usart_read_chars(); // Read data
 2594               		.loc 3 156 0
 2595 011c 00D0      		rcall usart_read_chars
 2596               	.LVL203:
 157:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2597               		.loc 3 157 0
 2598 011e 80E0      		ldi r24,lo8(receivedBuffer)
 2599 0120 90E0      		ldi r25,hi8(receivedBuffer)
 2600 0122 00D0      		rcall atoi
 2601               	.LVL204:
 158:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2602               		.loc 3 158 0
 2603 0124 8093 0000 		sts lastBankAccessed,r24
 159:main.c        **** 				
 160:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2604               		.loc 3 160 0
 2605 0128 40E0      		ldi r20,0
 2606 012a 682F      		mov r22,r24
 2607 012c C401      		movw r24,r8
 2608               	.LVL205:
 2609 012e 00D0      		rcall write_8bit_data
 2610               	.LVL206:
 2611 0130 00C0      		rjmp .L93
 2612               	.LVL207:
 2613               	.L108:
 2614               	.LBE167:
 2615               	.LBE166:
 161:main.c        **** 			}
 162:main.c        **** 		}
 163:main.c        **** 		
 164:main.c        **** 		
 165:main.c        **** 		// ****** Gameboy Advance ******
 166:main.c        **** 		
 167:main.c        **** 		// ---------- ROM ----------
 168:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 169:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 2616               		.loc 3 169 0
 2617 0132 9237      		cpi r25,lo8(114)
 2618 0134 01F0      		breq .L109
 2619               		.loc 3 169 0 is_stmt 0 discriminator 1
 2620 0136 9A36      		cpi r25,lo8(106)
 2621 0138 01F4      		brne .L110
 2622               	.L109:
 2623               	.LBB168:
 170:main.c        **** 			gba_mode();
 2624               		.loc 3 170 0 is_stmt 1
 2625 013a 00D0      		rcall gba_mode
 2626               	.LVL208:
 171:main.c        **** 			
 172:main.c        **** 			uint8_t readEnd = 32;
 173:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2627               		.loc 3 173 0
 2628 013c 8091 0000 		lds r24,receivedChar
 2629 0140 8A36      		cpi r24,lo8(106)
 2630 0142 01F4      		brne .L202
 174:main.c        **** 				readEnd = 128;
 2631               		.loc 3 174 0
 2632 0144 10E8      		ldi r17,lo8(-128)
 2633 0146 00C0      		rjmp .L111
 2634               	.L202:
 172:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2635               		.loc 3 172 0
 2636 0148 10E2      		ldi r17,lo8(32)
 2637               	.L111:
 2638               	.LVL209:
 175:main.c        **** 			}
 176:main.c        **** 			
 177:main.c        **** 			receivedChar = '1';
 2639               		.loc 3 177 0
 2640 014a 21E3      		ldi r18,lo8(49)
 2641 014c 2093 0000 		sts receivedChar,r18
 2642 0150 8824      		clr r8
 2643 0152 8A94      		dec r8
 2644 0154 810E      		add r8,r17
 2645 0156 912C      		mov r9,__zero_reg__
 2646 0158 A12C      		mov r10,__zero_reg__
 2647 015a B12C      		mov r11,__zero_reg__
 2648 015c 8FEF      		ldi r24,-1
 2649 015e 881A      		sub r8,r24
 2650 0160 980A      		sbc r9,r24
 2651 0162 A80A      		sbc r10,r24
 2652 0164 B80A      		sbc r11,r24
 2653               	.LVL210:
 2654               	.L112:
 178:main.c        **** 			while (receivedChar == '1') {
 2655               		.loc 3 178 0
 2656 0166 8091 0000 		lds r24,receivedChar
 2657 016a 8133      		cpi r24,lo8(49)
 2658 016c 01F0      		breq .+2
 2659 016e 00C0      		rjmp .L93
 179:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2660               		.loc 3 179 0
 2661 0170 939A      		sbi 0x12,3
 2662               	.LVL211:
 2663 0172 1601      		movw r2,r12
 2664 0174 2701      		movw r4,r14
 2665               	.LVL212:
 2666               	.L113:
 2667               	.LBB169:
 2668               	.LBB170:
 180:main.c        **** 				
 181:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 182:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2669               		.loc 3 182 0 discriminator 3
 2670 0176 C201      		movw r24,r4
 2671 0178 B101      		movw r22,r2
 2672 017a 00D0      		rcall gba_read_16bit_data
 2673               	.LVL213:
 2674 017c 092F      		mov r16,r25
 2675               	.LVL214:
 183:main.c        **** 					
 184:main.c        **** 					// Low byte & High byte
 185:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 2676               		.loc 3 185 0 discriminator 3
 2677 017e 00D0      		rcall USART_Transmit
 2678               	.LVL215:
 186:main.c        **** 					USART_Transmit(dataRead >> 8);
 2679               		.loc 3 186 0 discriminator 3
 2680 0180 802F      		mov r24,r16
 2681 0182 00D0      		rcall USART_Transmit
 2682               	.LVL216:
 187:main.c        **** 					
 188:main.c        **** 					address++;
 2683               		.loc 3 188 0 discriminator 3
 2684 0184 9FEF      		ldi r25,-1
 2685 0186 291A      		sub r2,r25
 2686 0188 390A      		sbc r3,r25
 2687 018a 490A      		sbc r4,r25
 2688 018c 590A      		sbc r5,r25
 2689               	.LVL217:
 2690               	.LBE170:
 181:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2691               		.loc 3 181 0 discriminator 3
 2692 018e 822D      		mov r24,r2
 2693 0190 8C19      		sub r24,r12
 2694 0192 8117      		cp r24,r17
 2695 0194 00F0      		brlo .L113
 2696 0196 C80C      		add r12,r8
 2697 0198 D91C      		adc r13,r9
 2698 019a EA1C      		adc r14,r10
 2699 019c FB1C      		adc r15,r11
 2700               	.LVL218:
 2701               	.LBE169:
 189:main.c        **** 				}
 190:main.c        **** 				
 191:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2702               		.loc 3 191 0
 2703 019e 9398      		cbi 0x12,3
 192:main.c        **** 				receivedChar = USART_Receive();
 2704               		.loc 3 192 0
 2705 01a0 00D0      		rcall USART_Receive
 2706               	.LVL219:
 2707 01a2 8093 0000 		sts receivedChar,r24
 2708 01a6 00C0      		rjmp .L112
 2709               	.LVL220:
 2710               	.L110:
 2711               	.LBE168:
 193:main.c        **** 			}
 194:main.c        **** 		}
 195:main.c        **** 		
 196:main.c        **** 		// ---------- SRAM ----------
 197:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 198:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2712               		.loc 3 198 0
 2713 01a8 9D36      		cpi r25,lo8(109)
 2714 01aa 01F4      		brne .L115
 199:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2715               		.loc 3 199 0
 2716 01ac 00D0      		rcall gb_mode
 2717               	.LVL221:
 200:main.c        **** 			
 201:main.c        **** 			receivedChar = '1';
 2718               		.loc 3 201 0
 2719 01ae E1E3      		ldi r30,lo8(49)
 2720 01b0 E093 0000 		sts receivedChar,r30
 2721               	.LVL222:
 2722               	.L116:
 202:main.c        **** 			while (receivedChar == '1') {
 2723               		.loc 3 202 0
 2724 01b4 8091 0000 		lds r24,receivedChar
 2725 01b8 8133      		cpi r24,lo8(49)
 2726 01ba 01F4      		brne .L233
 203:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2727               		.loc 3 203 0
 2728 01bc 939A      		sbi 0x12,3
 2729               	.LVL223:
 2730 01be 00E0      		ldi r16,0
 2731 01c0 10E0      		ldi r17,0
 2732               	.LVL224:
 2733               	.L117:
 2734               	.LBB171:
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 205:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2735               		.loc 3 205 0 discriminator 3
 2736 01c2 C801      		movw r24,r16
 2737 01c4 8C0D      		add r24,r12
 2738 01c6 9D1D      		adc r25,r13
 2739 01c8 00D0      		rcall gba_read_ram_8bit_data
 2740               	.LVL225:
 2741 01ca 00D0      		rcall USART_Transmit
 2742               	.LVL226:
 2743 01cc 0F5F      		subi r16,-1
 2744 01ce 1F4F      		sbci r17,-1
 2745               	.LVL227:
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2746               		.loc 3 204 0 discriminator 3
 2747 01d0 0034      		cpi r16,64
 2748 01d2 1105      		cpc r17,__zero_reg__
 2749 01d4 01F4      		brne .L117
 2750 01d6 F0E4      		ldi r31,64
 2751 01d8 CF0E      		add r12,r31
 2752 01da D11C      		adc r13,__zero_reg__
 2753 01dc E11C      		adc r14,__zero_reg__
 2754 01de F11C      		adc r15,__zero_reg__
 2755               	.LBE171:
 206:main.c        **** 					address++;
 207:main.c        **** 				}
 208:main.c        **** 				
 209:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2756               		.loc 3 209 0
 2757 01e0 9398      		cbi 0x12,3
 210:main.c        **** 				receivedChar = USART_Receive();
 2758               		.loc 3 210 0
 2759 01e2 00D0      		rcall USART_Receive
 2760               	.LVL228:
 2761 01e4 8093 0000 		sts receivedChar,r24
 2762 01e8 00C0      		rjmp .L116
 2763               	.LVL229:
 2764               	.L115:
 211:main.c        **** 			}
 212:main.c        **** 			
 213:main.c        **** 			gba_mode(); // Set back
 214:main.c        **** 		}
 215:main.c        **** 		
 216:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 217:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2765               		.loc 3 217 0
 2766 01ea 9737      		cpi r25,lo8(119)
 2767 01ec 01F4      		brne .L119
 218:main.c        **** 			gb_mode();
 2768               		.loc 3 218 0
 2769 01ee 00D0      		rcall gb_mode
 2770               	.LVL230:
 219:main.c        **** 			
 220:main.c        **** 			usart_read_bytes(64);
 2771               		.loc 3 220 0
 2772 01f0 80E4      		ldi r24,lo8(64)
 2773 01f2 90E0      		ldi r25,0
 2774 01f4 00D0      		rcall usart_read_bytes
 2775               	.LVL231:
 221:main.c        **** 			
 222:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2776               		.loc 3 222 0
 2777 01f6 939A      		sbi 0x12,3
 2778               	.LVL232:
 2779 01f8 F0E0      		ldi r31,lo8(receivedBuffer)
 2780 01fa AF2E      		mov r10,r31
 2781 01fc F0E0      		ldi r31,hi8(receivedBuffer)
 2782 01fe BF2E      		mov r11,r31
 2783 0200 00E0      		ldi r16,0
 2784 0202 10E0      		ldi r17,0
 2785               	.LVL233:
 2786               	.L120:
 2787               	.LBB172:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 224:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2788               		.loc 3 224 0 discriminator 3
 2789 0204 F501      		movw r30,r10
 2790 0206 6191      		ld r22,Z+
 2791 0208 5F01      		movw r10,r30
 2792 020a C801      		movw r24,r16
 2793 020c 8C0D      		add r24,r12
 2794 020e 9D1D      		adc r25,r13
 2795 0210 00D0      		rcall gba_write_ram_8bit_data
 2796               	.LVL234:
 2797 0212 0F5F      		subi r16,-1
 2798 0214 1F4F      		sbci r17,-1
 2799               	.LVL235:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2800               		.loc 3 223 0 discriminator 3
 2801 0216 0034      		cpi r16,64
 2802 0218 1105      		cpc r17,__zero_reg__
 2803 021a 01F4      		brne .L120
 2804               	.LVL236:
 2805               	.L236:
 2806 021c F0E4      		ldi r31,64
 2807 021e CF0E      		add r12,r31
 2808 0220 D11C      		adc r13,__zero_reg__
 2809 0222 E11C      		adc r14,__zero_reg__
 2810 0224 F11C      		adc r15,__zero_reg__
 2811               	.L235:
 2812               	.LBE172:
 225:main.c        **** 				address++;
 226:main.c        **** 			}
 227:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2813               		.loc 3 227 0
 2814 0226 81E3      		ldi r24,lo8(49)
 2815 0228 00D0      		rcall USART_Transmit
 2816               	.LVL237:
 228:main.c        **** 			
 229:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2817               		.loc 3 229 0
 2818 022a 9398      		cbi 0x12,3
 2819               	.L233:
 230:main.c        **** 			gba_mode(); // Set back
 2820               		.loc 3 230 0
 2821 022c 00D0      		rcall gba_mode
 2822               	.LVL238:
 2823 022e 00C0      		rjmp .L93
 2824               	.LVL239:
 2825               	.L119:
 231:main.c        **** 		}
 232:main.c        **** 		
 233:main.c        **** 		// Write 1 byte to SRAM address
 234:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2826               		.loc 3 234 0
 2827 0230 9F36      		cpi r25,lo8(111)
 2828 0232 01F4      		brne .L121
 2829               	.LBB173:
 235:main.c        **** 			gb_mode();
 2830               		.loc 3 235 0
 2831 0234 00D0      		rcall gb_mode
 2832               	.LVL240:
 236:main.c        **** 			
 237:main.c        **** 			uint8_t data = USART_Receive();
 2833               		.loc 3 237 0
 2834 0236 00D0      		rcall USART_Receive
 2835               	.LVL241:
 238:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2836               		.loc 3 238 0
 2837 0238 682F      		mov r22,r24
 2838 023a C601      		movw r24,r12
 2839               	.LVL242:
 2840 023c 00D0      		rcall gba_write_ram_8bit_data
 2841               	.LVL243:
 2842 023e 00C0      		rjmp .L238
 2843               	.LVL244:
 2844               	.L121:
 2845               	.LBE173:
 239:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 240:main.c        **** 			
 241:main.c        **** 			gba_mode(); // Set back
 242:main.c        **** 		}
 243:main.c        **** 		
 244:main.c        **** 		
 245:main.c        **** 		// ---------- FLASH ----------
 246:main.c        **** 		// Read the Flash Manufacturer and Device ID
 247:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2846               		.loc 3 247 0
 2847 0240 9936      		cpi r25,lo8(105)
 2848 0242 01F4      		brne .L122
 248:main.c        **** 			gb_mode();
 2849               		.loc 3 248 0
 2850 0244 00D0      		rcall gb_mode
 2851               	.LVL245:
 249:main.c        **** 			
 250:main.c        **** 			flash_read_chip_id();
 2852               		.loc 3 250 0
 2853 0246 00D0      		rcall flash_read_chip_id
 2854               	.LVL246:
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2855               		.loc 3 251 0
 2856 0248 8091 0000 		lds r24,flashChipIdBuffer
 2857 024c 00D0      		rcall USART_Transmit
 2858               	.LVL247:
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2859               		.loc 3 252 0
 2860 024e 8091 0000 		lds r24,flashChipIdBuffer+1
 2861               	.L237:
 2862 0252 00D0      		rcall USART_Transmit
 2863               	.LVL248:
 2864 0254 00C0      		rjmp .L233
 2865               	.LVL249:
 2866               	.L122:
 253:main.c        **** 			
 254:main.c        **** 			gba_mode(); // Set back
 255:main.c        **** 		}
 256:main.c        **** 		
 257:main.c        **** 		// Change bank
 258:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2867               		.loc 3 258 0
 2868 0256 9B36      		cpi r25,lo8(107)
 2869 0258 01F4      		brne .L123
 2870               	.LBB174:
 259:main.c        **** 			usart_read_chars(); // Read data
 2871               		.loc 3 259 0
 2872 025a 00D0      		rcall usart_read_chars
 2873               	.LVL250:
 260:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2874               		.loc 3 260 0
 2875 025c 80E0      		ldi r24,lo8(receivedBuffer)
 2876 025e 90E0      		ldi r25,hi8(receivedBuffer)
 2877 0260 00D0      		rcall atoi
 2878               	.LVL251:
 2879 0262 182F      		mov r17,r24
 2880               	.LVL252:
 261:main.c        **** 			
 262:main.c        **** 			gb_mode();
 2881               		.loc 3 262 0
 2882 0264 00D0      		rcall gb_mode
 2883               	.LVL253:
 263:main.c        **** 			flash_switch_bank(bank);
 2884               		.loc 3 263 0
 2885 0266 812F      		mov r24,r17
 2886 0268 00D0      		rcall flash_switch_bank
 2887               	.LVL254:
 2888 026a 00C0      		rjmp .L233
 2889               	.LVL255:
 2890               	.L123:
 2891               	.LBE174:
 264:main.c        **** 			
 265:main.c        **** 			gba_mode(); // Set back
 266:main.c        **** 		}
 267:main.c        **** 		
 268:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 269:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2892               		.loc 3 269 0
 2893 026c 9337      		cpi r25,lo8(115)
 2894 026e 01F4      		brne .L124
 2895               	.LBB175:
 270:main.c        **** 			gb_mode();
 2896               		.loc 3 270 0
 2897 0270 00D0      		rcall gb_mode
 2898               	.LVL256:
 271:main.c        **** 			
 272:main.c        **** 			usart_read_chars(); // Read sector
 2899               		.loc 3 272 0
 2900 0272 00D0      		rcall usart_read_chars
 2901               	.LVL257:
 273:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2902               		.loc 3 273 0
 2903 0274 40E1      		ldi r20,lo8(16)
 2904 0276 50E0      		ldi r21,0
 2905 0278 60E0      		ldi r22,0
 2906 027a 70E0      		ldi r23,0
 2907 027c 80E0      		ldi r24,lo8(receivedBuffer)
 2908 027e 90E0      		ldi r25,hi8(receivedBuffer)
 2909 0280 00D0      		rcall strtol
 2910               	.LVL258:
 2911 0282 862F      		mov r24,r22
 2912               	.LVL259:
 274:main.c        **** 			
 275:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2913               		.loc 3 275 0
 2914 0284 00D0      		rcall flash_erase_4k_sector
 2915               	.LVL260:
 2916               	.L238:
 276:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2917               		.loc 3 276 0
 2918 0286 81E3      		ldi r24,lo8(49)
 2919 0288 00C0      		rjmp .L237
 2920               	.LVL261:
 2921               	.L124:
 2922               	.LBE175:
 277:main.c        **** 			
 278:main.c        **** 			gba_mode(); // Set back
 279:main.c        **** 		}
 280:main.c        **** 		
 281:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 282:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2923               		.loc 3 282 0
 2924 028a 9236      		cpi r25,lo8(98)
 2925 028c 01F4      		brne .L125
 283:main.c        **** 			gb_mode();
 2926               		.loc 3 283 0
 2927 028e 00D0      		rcall gb_mode
 2928               	.LVL262:
 284:main.c        **** 			
 285:main.c        **** 			usart_read_bytes(64);
 2929               		.loc 3 285 0
 2930 0290 80E4      		ldi r24,lo8(64)
 2931 0292 90E0      		ldi r25,0
 2932 0294 00D0      		rcall usart_read_bytes
 2933               	.LVL263:
 286:main.c        **** 			
 287:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2934               		.loc 3 287 0
 2935 0296 939A      		sbi 0x12,3
 2936               	.LVL264:
 2937 0298 E0E0      		ldi r30,lo8(receivedBuffer)
 2938 029a AE2E      		mov r10,r30
 2939 029c E0E0      		ldi r30,hi8(receivedBuffer)
 2940 029e BE2E      		mov r11,r30
 2941 02a0 00E0      		ldi r16,0
 2942 02a2 10E0      		ldi r17,0
 2943               	.LVL265:
 2944               	.L126:
 2945               	.LBB176:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 289:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2946               		.loc 3 289 0 discriminator 3
 2947 02a4 F501      		movw r30,r10
 2948 02a6 6191      		ld r22,Z+
 2949 02a8 5F01      		movw r10,r30
 2950 02aa C801      		movw r24,r16
 2951 02ac 8C0D      		add r24,r12
 2952 02ae 9D1D      		adc r25,r13
 2953 02b0 00D0      		rcall flash_write_byte
 2954               	.LVL266:
 2955 02b2 0F5F      		subi r16,-1
 2956 02b4 1F4F      		sbci r17,-1
 2957               	.LVL267:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2958               		.loc 3 288 0 discriminator 3
 2959 02b6 0034      		cpi r16,64
 2960 02b8 1105      		cpc r17,__zero_reg__
 2961 02ba 01F4      		brne .L126
 2962 02bc 00C0      		rjmp .L236
 2963               	.LVL268:
 2964               	.L125:
 2965               	.LBE176:
 290:main.c        **** 				address++;
 291:main.c        **** 			}
 292:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 293:main.c        **** 			
 294:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 295:main.c        **** 			gba_mode(); // Set back
 296:main.c        **** 		}
 297:main.c        **** 		
 298:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 299:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2966               		.loc 3 299 0
 2967 02be 9136      		cpi r25,lo8(97)
 2968 02c0 01F4      		brne .L127
 300:main.c        **** 			gb_mode();
 2969               		.loc 3 300 0
 2970 02c2 00D0      		rcall gb_mode
 2971               	.LVL269:
 301:main.c        **** 			
 302:main.c        **** 			usart_read_bytes(128);
 2972               		.loc 3 302 0
 2973 02c4 80E8      		ldi r24,lo8(-128)
 2974 02c6 90E0      		ldi r25,0
 2975 02c8 00D0      		rcall usart_read_bytes
 2976               	.LVL270:
 303:main.c        **** 			
 304:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2977               		.loc 3 304 0
 2978 02ca 939A      		sbi 0x12,3
 305:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2979               		.loc 3 305 0
 2980 02cc C601      		movw r24,r12
 2981 02ce 00D0      		rcall flash_write_sector
 2982               	.LVL271:
 306:main.c        **** 			address++;
 2983               		.loc 3 306 0
 2984 02d0 2FEF      		ldi r18,-1
 2985 02d2 C21A      		sub r12,r18
 2986 02d4 D20A      		sbc r13,r18
 2987 02d6 E20A      		sbc r14,r18
 2988 02d8 F20A      		sbc r15,r18
 2989               	.LVL272:
 2990 02da 00C0      		rjmp .L235
 2991               	.LVL273:
 2992               	.L127:
 307:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 308:main.c        **** 			
 309:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 310:main.c        **** 			gba_mode(); // Set back
 311:main.c        **** 		}
 312:main.c        **** 		
 313:main.c        **** 		
 314:main.c        **** 		// ---------- EEPROM ----------
 315:main.c        **** 		// Set EEPROM size
 316:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2993               		.loc 3 316 0
 2994 02dc 9335      		cpi r25,lo8(83)
 2995 02de 01F4      		brne .L128
 317:main.c        **** 			usart_read_chars(); // Read size
 2996               		.loc 3 317 0
 2997 02e0 00D0      		rcall usart_read_chars
 2998               	.LVL274:
 318:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2999               		.loc 3 318 0
 3000 02e2 40E1      		ldi r20,lo8(16)
 3001 02e4 50E0      		ldi r21,0
 3002 02e6 60E0      		ldi r22,0
 3003 02e8 70E0      		ldi r23,0
 3004 02ea 80E0      		ldi r24,lo8(receivedBuffer)
 3005 02ec 90E0      		ldi r25,hi8(receivedBuffer)
 3006 02ee 00D0      		rcall strtol
 3007               	.LVL275:
 3008 02f0 6A83      		std Y+2,r22
 3009               	.LVL276:
 3010 02f2 00C0      		rjmp .L93
 3011               	.LVL277:
 3012               	.L128:
 319:main.c        **** 		}
 320:main.c        **** 		
 321:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 322:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 3013               		.loc 3 322 0
 3014 02f4 9536      		cpi r25,lo8(101)
 3015 02f6 01F4      		brne .L129
 323:main.c        **** 			gba_eeprom_mode();
 3016               		.loc 3 323 0
 3017 02f8 00D0      		rcall gba_eeprom_mode
 3018               	.LVL278:
 324:main.c        **** 			
 325:main.c        **** 			receivedChar = '1';
 3019               		.loc 3 325 0
 3020 02fa 81E3      		ldi r24,lo8(49)
 3021               	.L239:
 326:main.c        **** 			while (receivedChar == '1') {
 327:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 328:main.c        **** 				gba_eeprom_read(address, eepromSize);
 329:main.c        **** 				
 330:main.c        **** 				// Send back the 8 bytes of data
 331:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 332:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 333:main.c        **** 				}
 334:main.c        **** 				address++; // Increment to next 8 bytes
 335:main.c        **** 				
 336:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 337:main.c        **** 				receivedChar = USART_Receive();
 3022               		.loc 3 337 0
 3023 02fc 8093 0000 		sts receivedChar,r24
 326:main.c        **** 			while (receivedChar == '1') {
 3024               		.loc 3 326 0
 3025 0300 8091 0000 		lds r24,receivedChar
 3026 0304 8133      		cpi r24,lo8(49)
 3027 0306 01F0      		breq .+2
 3028 0308 00C0      		rjmp .L233
 327:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3029               		.loc 3 327 0
 3030 030a 939A      		sbi 0x12,3
 328:main.c        **** 				
 3031               		.loc 3 328 0
 3032 030c 6A81      		ldd r22,Y+2
 3033 030e C601      		movw r24,r12
 3034 0310 00D0      		rcall gba_eeprom_read
 3035               	.LVL279:
 3036 0312 00E0      		ldi r16,lo8(eepromBuffer)
 3037 0314 10E0      		ldi r17,hi8(eepromBuffer)
 3038               	.LVL280:
 3039               	.L131:
 3040               	.LBB177:
 332:main.c        **** 				}
 3041               		.loc 3 332 0 discriminator 3
 3042 0316 F801      		movw r30,r16
 3043 0318 8191      		ld r24,Z+
 3044 031a 8F01      		movw r16,r30
 3045               	.LVL281:
 3046 031c 00D0      		rcall USART_Transmit
 3047               	.LVL282:
 331:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3048               		.loc 3 331 0 discriminator 3
 3049 031e 6016      		cp r6,r16
 3050 0320 7106      		cpc r7,r17
 3051 0322 01F4      		brne .L131
 3052               	.LBE177:
 334:main.c        **** 				
 3053               		.loc 3 334 0
 3054 0324 FFEF      		ldi r31,-1
 3055 0326 CF1A      		sub r12,r31
 3056 0328 DF0A      		sbc r13,r31
 3057 032a EF0A      		sbc r14,r31
 3058 032c FF0A      		sbc r15,r31
 3059               	.LVL283:
 336:main.c        **** 				receivedChar = USART_Receive();
 3060               		.loc 3 336 0
 3061 032e 9398      		cbi 0x12,3
 3062               		.loc 3 337 0
 3063 0330 00D0      		rcall USART_Receive
 3064               	.LVL284:
 3065 0332 00C0      		rjmp .L239
 3066               	.LVL285:
 3067               	.L129:
 338:main.c        **** 			}
 339:main.c        **** 			
 340:main.c        **** 			gba_mode(); // Set back
 341:main.c        **** 		}
 342:main.c        **** 		
 343:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 344:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 3068               		.loc 3 344 0
 3069 0334 9037      		cpi r25,lo8(112)
 3070 0336 01F4      		brne .L133
 345:main.c        **** 			gba_eeprom_mode();
 3071               		.loc 3 345 0
 3072 0338 00D0      		rcall gba_eeprom_mode
 3073               	.LVL286:
 3074 033a 00E0      		ldi r16,lo8(eepromBuffer)
 3075 033c 10E0      		ldi r17,hi8(eepromBuffer)
 3076               	.LVL287:
 3077               	.L134:
 3078               	.LBB178:
 346:main.c        **** 			
 347:main.c        **** 			// Read 8 bytes from USART and place in buffer
 348:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 349:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3079               		.loc 3 349 0 discriminator 3
 3080 033e 00D0      		rcall USART_Receive
 3081               	.LVL288:
 3082 0340 F801      		movw r30,r16
 3083 0342 8193      		st Z+,r24
 3084 0344 8F01      		movw r16,r30
 3085               	.LVL289:
 348:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3086               		.loc 3 348 0 discriminator 3
 3087 0346 6E16      		cp r6,r30
 3088 0348 7F06      		cpc r7,r31
 3089 034a 01F4      		brne .L134
 3090               	.LBE178:
 350:main.c        **** 			}
 351:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3091               		.loc 3 351 0
 3092 034c 939A      		sbi 0x12,3
 352:main.c        **** 			
 353:main.c        **** 			gba_eeprom_write(address, eepromSize);
 3093               		.loc 3 353 0
 3094 034e 6A81      		ldd r22,Y+2
 3095 0350 C601      		movw r24,r12
 3096 0352 00D0      		rcall gba_eeprom_write
 3097               	.LVL290:
 354:main.c        **** 			address++;
 3098               		.loc 3 354 0
 3099 0354 FFEF      		ldi r31,-1
 3100 0356 CF1A      		sub r12,r31
 3101 0358 DF0A      		sbc r13,r31
 3102 035a EF0A      		sbc r14,r31
 3103 035c FF0A      		sbc r15,r31
 3104               	.LVL291:
 3105               	.LBB179:
 3106               	.LBB180:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3107               		.loc 2 187 0
 3108 035e 8FE7      		ldi r24,lo8(15999)
 3109 0360 9EE3      		ldi r25,hi8(15999)
 3110 0362 0197      	1:	sbiw r24,1
 3111 0364 01F4      		brne 1b
 3112 0366 00C0      		rjmp .
 3113 0368 0000      		nop
 3114               	.LVL292:
 3115 036a 00C0      		rjmp .L235
 3116               	.LVL293:
 3117               	.L133:
 3118               	.LBE180:
 3119               	.LBE179:
 355:main.c        **** 			
 356:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 357:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 358:main.c        **** 			
 359:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 360:main.c        **** 			gba_mode(); // Set back
 361:main.c        **** 		}
 362:main.c        **** 		
 363:main.c        **** 		
 364:main.c        **** 		// ---------- GB FLASH CARTS ----------
 365:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 366:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 3120               		.loc 3 366 0
 3121 036c 9035      		cpi r25,lo8(80)
 3122 036e 01F4      		brne .L135
 367:main.c        **** 			flashWriteWePin = USART_Receive();
 3123               		.loc 3 367 0
 3124 0370 00D0      		rcall USART_Receive
 3125               	.LVL294:
 3126 0372 8093 0000 		sts flashWriteWePin,r24
 368:main.c        **** 			
 369:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 3127               		.loc 3 369 0
 3128 0376 8134      		cpi r24,lo8(65)
 3129 0378 01F0      		breq .+2
 3130 037a 00C0      		rjmp .L93
 370:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3131               		.loc 3 370 0
 3132 037c 319A      		sbi 0x6,1
 371:main.c        **** 				audioPin_high;
 3133               		.loc 3 371 0
 3134 037e 399A      		sbi 0x7,1
 3135 0380 00C0      		rjmp .L93
 3136               	.LVL295:
 3137               	.L135:
 372:main.c        **** 			}
 373:main.c        **** 		}
 374:main.c        **** 		
 375:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 376:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 3138               		.loc 3 376 0
 3139 0382 9E34      		cpi r25,lo8(78)
 3140 0384 01F4      		brne .L136
 377:main.c        **** 			flashBank1CommandWrites = 1;
 3141               		.loc 3 377 0
 3142 0386 91E0      		ldi r25,lo8(1)
 3143 0388 9093 0000 		sts flashBank1CommandWrites,r25
 3144 038c 00C0      		rjmp .L93
 3145               	.L136:
 378:main.c        **** 		}
 379:main.c        **** 		
 380:main.c        **** 		// Load the program method to use
 381:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 3146               		.loc 3 381 0
 3147 038e 9534      		cpi r25,lo8(69)
 3148 0390 01F4      		brne .L137
 3149 0392 00E0      		ldi r16,lo8(flashWriteCycle)
 3150 0394 10E0      		ldi r17,hi8(flashWriteCycle)
 3151               	.LVL296:
 3152               	.L138:
 3153               	.LBB181:
 382:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 383:main.c        **** 				usart_read_chars(); // Address
 3154               		.loc 3 383 0 discriminator 3
 3155 0396 00D0      		rcall usart_read_chars
 3156               	.LVL297:
 384:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3157               		.loc 3 384 0 discriminator 3
 3158 0398 40E1      		ldi r20,lo8(16)
 3159 039a 50E0      		ldi r21,0
 3160 039c 60E0      		ldi r22,0
 3161 039e 70E0      		ldi r23,0
 3162 03a0 80E0      		ldi r24,lo8(receivedBuffer)
 3163 03a2 90E0      		ldi r25,hi8(receivedBuffer)
 3164 03a4 00D0      		rcall strtol
 3165               	.LVL298:
 3166 03a6 F801      		movw r30,r16
 3167 03a8 7183      		std Z+1,r23
 3168 03aa 6083      		st Z,r22
 385:main.c        **** 				USART_Transmit(SEND_ACK);
 3169               		.loc 3 385 0 discriminator 3
 3170 03ac 81E3      		ldi r24,lo8(49)
 3171 03ae 00D0      		rcall USART_Transmit
 3172               	.LVL299:
 386:main.c        **** 				
 387:main.c        **** 				usart_read_chars(); // Data
 3173               		.loc 3 387 0 discriminator 3
 3174 03b0 00D0      		rcall usart_read_chars
 3175               	.LVL300:
 388:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3176               		.loc 3 388 0 discriminator 3
 3177 03b2 40E1      		ldi r20,lo8(16)
 3178 03b4 50E0      		ldi r21,0
 3179 03b6 60E0      		ldi r22,0
 3180 03b8 70E0      		ldi r23,0
 3181 03ba 80E0      		ldi r24,lo8(receivedBuffer)
 3182 03bc 90E0      		ldi r25,hi8(receivedBuffer)
 3183 03be 00D0      		rcall strtol
 3184               	.LVL301:
 3185 03c0 F801      		movw r30,r16
 3186 03c2 7383      		std Z+3,r23
 3187 03c4 6283      		std Z+2,r22
 389:main.c        **** 				USART_Transmit(SEND_ACK);
 3188               		.loc 3 389 0 discriminator 3
 3189 03c6 81E3      		ldi r24,lo8(49)
 3190 03c8 00D0      		rcall USART_Transmit
 3191               	.LVL302:
 3192 03ca 0C5F      		subi r16,-4
 3193 03cc 1F4F      		sbci r17,-1
 382:main.c        **** 				usart_read_chars(); // Address
 3194               		.loc 3 382 0 discriminator 3
 3195 03ce 80E0      		ldi r24,lo8(flashWriteCycle+12)
 3196 03d0 90E0      		ldi r25,hi8(flashWriteCycle+12)
 3197 03d2 8017      		cp r24,r16
 3198 03d4 9107      		cpc r25,r17
 3199 03d6 01F4      		brne .L138
 3200 03d8 00C0      		rjmp .L93
 3201               	.LVL303:
 3202               	.L137:
 3203               	.LBE181:
 390:main.c        **** 			}
 391:main.c        **** 		}
 392:main.c        **** 		
 393:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 394:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 3204               		.loc 3 394 0
 3205 03da 9634      		cpi r25,lo8(70)
 3206 03dc 01F4      		brne .L139
 3207               	.LBB182:
 395:main.c        **** 			usart_read_chars(); // Read address
 3208               		.loc 3 395 0
 3209 03de 00D0      		rcall usart_read_chars
 3210               	.LVL304:
 396:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3211               		.loc 3 396 0
 3212 03e0 40E1      		ldi r20,lo8(16)
 3213 03e2 50E0      		ldi r21,0
 3214 03e4 60E0      		ldi r22,0
 3215 03e6 70E0      		ldi r23,0
 3216 03e8 80E0      		ldi r24,lo8(receivedBuffer)
 3217 03ea 90E0      		ldi r25,hi8(receivedBuffer)
 3218 03ec 00D0      		rcall strtol
 3219               	.LVL305:
 3220 03ee 4B01      		movw r8,r22
 3221 03f0 5C01      		movw r10,r24
 3222               	.LVL306:
 397:main.c        **** 			
 398:main.c        **** 			usart_read_chars(); // Read data byte
 3223               		.loc 3 398 0
 3224 03f2 00D0      		rcall usart_read_chars
 3225               	.LVL307:
 399:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3226               		.loc 3 399 0
 3227 03f4 40E1      		ldi r20,lo8(16)
 3228 03f6 50E0      		ldi r21,0
 3229 03f8 60E0      		ldi r22,0
 3230 03fa 70E0      		ldi r23,0
 3231 03fc 80E0      		ldi r24,lo8(receivedBuffer)
 3232 03fe 90E0      		ldi r25,hi8(receivedBuffer)
 3233 0400 00D0      		rcall strtol
 3234               	.LVL308:
 400:main.c        **** 			
 401:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3235               		.loc 3 401 0
 3236 0402 939A      		sbi 0x12,3
 402:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3237               		.loc 3 402 0
 3238 0404 C401      		movw r24,r8
 3239 0406 00D0      		rcall gb_flash_write_bus_cycle
 3240               	.LVL309:
 3241 0408 00C0      		rjmp .L251
 3242               	.LVL310:
 3243               	.L139:
 3244               	.LBE182:
 403:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 404:main.c        **** 			
 405:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 406:main.c        **** 		}
 407:main.c        **** 		
 408:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 409:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 3245               		.loc 3 409 0
 3246 040a 9435      		cpi r25,lo8(84)
 3247 040c 01F4      		brne .L140
 410:main.c        **** 			usart_read_bytes(64);
 3248               		.loc 3 410 0
 3249 040e 80E4      		ldi r24,lo8(64)
 3250 0410 90E0      		ldi r25,0
 3251               	.LVL311:
 3252 0412 00D0      		rcall usart_read_bytes
 3253               	.LVL312:
 411:main.c        **** 			
 412:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3254               		.loc 3 412 0
 3255 0414 939A      		sbi 0x12,3
 3256               	.LVL313:
 3257 0416 60E0      		ldi r22,lo8(receivedBuffer)
 3258 0418 A62E      		mov r10,r22
 3259 041a 60E0      		ldi r22,hi8(receivedBuffer)
 3260 041c B62E      		mov r11,r22
 3261 041e 70E4      		ldi r23,lo8(64)
 3262 0420 972E      		mov r9,r23
 3263 0422 8601      		movw r16,r12
 3264 0424 0050      		subi r16,lo8(receivedBuffer)
 3265 0426 1040      		sbci r17,hi8(receivedBuffer)
 3266               	.LVL314:
 3267               	.L143:
 3268               	.LBB183:
 413:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 414:main.c        **** 				if (flashBank1CommandWrites == 0) {
 3269               		.loc 3 414 0
 3270 0428 8091 0000 		lds r24,flashBank1CommandWrites
 415:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3271               		.loc 3 415 0
 3272 042c F501      		movw r30,r10
 3273 042e 6081      		ld r22,Z
 414:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3274               		.loc 3 414 0
 3275 0430 8111      		cpse r24,__zero_reg__
 3276 0432 00C0      		rjmp .L141
 3277               		.loc 3 415 0
 3278 0434 C801      		movw r24,r16
 3279 0436 8A0D      		add r24,r10
 3280 0438 9B1D      		adc r25,r11
 3281 043a 00D0      		rcall gb_flash_write_byte
 3282               	.LVL315:
 3283 043c 00C0      		rjmp .L142
 3284               	.L141:
 416:main.c        **** 				}
 417:main.c        **** 				else { // Some flash carts need to change to bank 1 to issue flash commands
 418:main.c        **** 					gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3285               		.loc 3 418 0
 3286 043e C801      		movw r24,r16
 3287 0440 8A0D      		add r24,r10
 3288 0442 9B1D      		adc r25,r11
 3289 0444 00D0      		rcall gb_flash_write_byte_bank1_commands
 3290               	.LVL316:
 3291               	.L142:
 3292 0446 9A94      		dec r9
 3293 0448 FFEF      		ldi r31,-1
 3294 044a AF1A      		sub r10,r31
 3295 044c BF0A      		sbc r11,r31
 3296               	.LVL317:
 413:main.c        **** 				if (flashBank1CommandWrites == 0) {
 3297               		.loc 3 413 0 discriminator 2
 3298 044e 9110      		cpse r9,__zero_reg__
 3299 0450 00C0      		rjmp .L143
 3300 0452 20E4      		ldi r18,64
 3301 0454 C20E      		add r12,r18
 3302 0456 D11C      		adc r13,__zero_reg__
 3303 0458 E11C      		adc r14,__zero_reg__
 3304 045a F11C      		adc r15,__zero_reg__
 3305 045c 00C0      		rjmp .L240
 3306               	.LVL318:
 3307               	.L140:
 3308               	.LBE183:
 419:main.c        **** 				}
 420:main.c        **** 				address++;
 421:main.c        **** 			}
 422:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 423:main.c        **** 			
 424:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 425:main.c        **** 		}
 426:main.c        **** 		
 427:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 428:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 3309               		.loc 3 428 0
 3310 045e 9935      		cpi r25,lo8(89)
 3311 0460 01F0      		breq .+2
 3312 0462 00C0      		rjmp .L144
 3313               	.LBB184:
 429:main.c        **** 			usart_read_bytes(32);
 3314               		.loc 3 429 0
 3315 0464 80E2      		ldi r24,lo8(32)
 3316 0466 90E0      		ldi r25,0
 3317               	.LVL319:
 3318 0468 00D0      		rcall usart_read_bytes
 3319               	.LVL320:
 430:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3320               		.loc 3 430 0
 3321 046a 939A      		sbi 0x12,3
 431:main.c        **** 			
 432:main.c        **** 			// Setup buffered write
 433:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 3322               		.loc 3 433 0
 3323 046c 6AEA      		ldi r22,lo8(-86)
 3324 046e 8AEA      		ldi r24,lo8(-86)
 3325 0470 9AE0      		ldi r25,lo8(10)
 3326 0472 00D0      		rcall gb_flash_write_bus_cycle
 3327               	.LVL321:
 434:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3328               		.loc 3 434 0
 3329 0474 65E5      		ldi r22,lo8(85)
 3330 0476 85E5      		ldi r24,lo8(85)
 3331 0478 95E0      		ldi r25,lo8(5)
 3332 047a 00D0      		rcall gb_flash_write_bus_cycle
 3333               	.LVL322:
 435:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3334               		.loc 3 435 0
 3335 047c 5601      		movw r10,r12
 3336 047e 65E2      		ldi r22,lo8(37)
 3337 0480 C601      		movw r24,r12
 3338 0482 00D0      		rcall gb_flash_write_bus_cycle
 3339               	.LVL323:
 436:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3340               		.loc 3 436 0
 3341 0484 6FE1      		ldi r22,lo8(31)
 3342 0486 C601      		movw r24,r12
 3343 0488 00D0      		rcall gb_flash_write_bus_cycle
 3344               	.LVL324:
 3345               	.LBB185:
 3346               	.LBB186:
 3347               		.loc 2 276 0
 3348 048a 82E0      		ldi r24,lo8(2)
 3349 048c 8A95      	1:	dec r24
 3350 048e 01F4      		brne 1b
 3351 0490 00C0      		rjmp .
 3352               	.LVL325:
 3353 0492 00E0      		ldi r16,lo8(receivedBuffer)
 3354 0494 10E0      		ldi r17,hi8(receivedBuffer)
 3355 0496 812C      		mov r8,__zero_reg__
 3356 0498 912C      		mov r9,__zero_reg__
 3357               	.LVL326:
 3358               	.L145:
 3359               	.LBE186:
 3360               	.LBE185:
 3361               	.LBB187:
 437:main.c        **** 			_delay_us(1);
 438:main.c        **** 			
 439:main.c        **** 			// Write data
 440:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 441:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3362               		.loc 3 441 0 discriminator 3
 3363 049a F801      		movw r30,r16
 3364 049c 6191      		ld r22,Z+
 3365 049e 8F01      		movw r16,r30
 3366 04a0 C401      		movw r24,r8
 3367 04a2 8A0D      		add r24,r10
 3368 04a4 9B1D      		adc r25,r11
 3369 04a6 00D0      		rcall gb_flash_write_bus_cycle
 3370               	.LVL327:
 3371 04a8 FFEF      		ldi r31,-1
 3372 04aa 8F1A      		sub r8,r31
 3373 04ac 9F0A      		sbc r9,r31
 3374               	.LVL328:
 440:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3375               		.loc 3 440 0 discriminator 3
 3376 04ae 20E2      		ldi r18,32
 3377 04b0 8216      		cp r8,r18
 3378 04b2 9104      		cpc r9,__zero_reg__
 3379 04b4 01F4      		brne .L145
 3380 04b6 80E2      		ldi r24,32
 3381 04b8 C80E      		add r12,r24
 3382 04ba D11C      		adc r13,__zero_reg__
 3383 04bc E11C      		adc r14,__zero_reg__
 3384 04be F11C      		adc r15,__zero_reg__
 3385               	.LBE187:
 442:main.c        **** 				address++;
 443:main.c        **** 			}
 444:main.c        **** 			
 445:main.c        **** 			// Write buffer to flash
 446:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 3386               		.loc 3 446 0
 3387 04c0 C601      		movw r24,r12
 3388 04c2 8097      		sbiw r24,32
 3389 04c4 69E2      		ldi r22,lo8(41)
 3390 04c6 00D0      		rcall gb_flash_write_bus_cycle
 3391               	.LVL329:
 3392               	.LBB188:
 3393               	.LBB189:
 3394               		.loc 2 276 0
 3395 04c8 EFE8      		ldi r30,lo8(399)
 3396 04ca F1E0      		ldi r31,hi8(399)
 3397 04cc 3197      	1:	sbiw r30,1
 3398 04ce 01F4      		brne 1b
 3399 04d0 00C0      		rjmp .
 3400 04d2 0000      		nop
 3401               	.LVL330:
 3402               	.LBE189:
 3403               	.LBE188:
 447:main.c        **** 			_delay_us(200);
 448:main.c        **** 			
 449:main.c        **** 			// Verify last byte written
 450:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3404               		.loc 3 450 0
 3405 04d4 8601      		movw r16,r12
 3406 04d6 0150      		subi r16,1
 3407 04d8 1109      		sbc r17,__zero_reg__
 3408 04da C801      		movw r24,r16
 3409 04dc 00D0      		rcall gb_flash_read_byte
 3410               	.LVL331:
 451:main.c        **** 			uint8_t verifyCount = 0;
 452:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 3411               		.loc 3 452 0
 3412 04de 58EC      		ldi r21,lo8(-56)
 3413 04e0 B52E      		mov r11,r21
 3414               	.LVL332:
 3415               	.L146:
 3416 04e2 9091 0000 		lds r25,receivedBuffer+31
 3417 04e6 8917      		cp r24,r25
 3418 04e8 01F4      		brne .+2
 3419 04ea 00C0      		rjmp .L240
 453:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3420               		.loc 3 453 0
 3421 04ec C801      		movw r24,r16
 3422               	.LVL333:
 3423 04ee 00D0      		rcall gb_flash_read_byte
 3424               	.LVL334:
 3425               	.LBB190:
 3426               	.LBB191:
 3427               		.loc 2 276 0
 3428 04f0 FDE0      		ldi r31,lo8(13)
 3429 04f2 FA95      	1:	dec r31
 3430 04f4 01F4      		brne 1b
 3431 04f6 0000      		nop
 3432               	.LVL335:
 3433 04f8 BA94      		dec r11
 3434               	.LVL336:
 3435               	.LBE191:
 3436               	.LBE190:
 454:main.c        **** 				_delay_us(5);
 455:main.c        **** 				verifyCount++;
 456:main.c        **** 				
 457:main.c        **** 				if (verifyCount >= 200) {
 3437               		.loc 3 457 0
 3438 04fa B110      		cpse r11,__zero_reg__
 3439 04fc 00C0      		rjmp .L146
 3440               	.LVL337:
 3441               	.LBB192:
 3442               	.LBB193:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3443               		.loc 2 187 0
 3444 04fe 2FEF      		ldi r18,lo8(799999)
 3445 0500 84E3      		ldi r24,hi8(799999)
 3446 0502 9CE0      		ldi r25,hlo8(799999)
 3447 0504 2150      	1:	subi r18,1
 3448 0506 8040      		sbci r24,0
 3449 0508 9040      		sbci r25,0
 3450 050a 01F4      		brne 1b
 3451               	.LVL338:
 3452 050c 00C0      		rjmp .L252
 3453               	.LVL339:
 3454               	.L144:
 3455               	.LBE193:
 3456               	.LBE192:
 3457               	.LBE184:
 458:main.c        **** 					_delay_ms(500);
 459:main.c        **** 					break;
 460:main.c        **** 				}
 461:main.c        **** 			}
 462:main.c        **** 			
 463:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 464:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 465:main.c        **** 		}
 466:main.c        **** 		
 467:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 468:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 3458               		.loc 3 468 0
 3459 050e 9835      		cpi r25,lo8(88)
 3460 0510 01F0      		breq .+2
 3461 0512 00C0      		rjmp .L149
 3462               	.LBB194:
 469:main.c        **** 			usart_read_bytes(256);
 3463               		.loc 3 469 0
 3464 0514 80E0      		ldi r24,0
 3465 0516 91E0      		ldi r25,lo8(1)
 3466               	.LVL340:
 3467 0518 00D0      		rcall usart_read_bytes
 3468               	.LVL341:
 470:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3469               		.loc 3 470 0
 3470 051a 939A      		sbi 0x12,3
 471:main.c        **** 			
 472:main.c        **** 			// Setup buffered write
 473:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 3471               		.loc 3 473 0
 3472 051c 69EA      		ldi r22,lo8(-87)
 3473 051e 8AEA      		ldi r24,lo8(-86)
 3474 0520 9AE0      		ldi r25,lo8(10)
 3475 0522 00D0      		rcall gb_flash_write_bus_cycle
 3476               	.LVL342:
 474:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3477               		.loc 3 474 0
 3478 0524 66E5      		ldi r22,lo8(86)
 3479 0526 85E5      		ldi r24,lo8(85)
 3480 0528 95E0      		ldi r25,lo8(5)
 3481 052a 00D0      		rcall gb_flash_write_bus_cycle
 3482               	.LVL343:
 475:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3483               		.loc 3 475 0
 3484 052c 5601      		movw r10,r12
 3485 052e 66E2      		ldi r22,lo8(38)
 3486 0530 C601      		movw r24,r12
 3487 0532 00D0      		rcall gb_flash_write_bus_cycle
 3488               	.LVL344:
 476:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3489               		.loc 3 476 0
 3490 0534 6FEF      		ldi r22,lo8(-1)
 3491 0536 C601      		movw r24,r12
 3492 0538 00D0      		rcall gb_flash_write_bus_cycle
 3493               	.LVL345:
 3494               	.LBB195:
 3495               	.LBB196:
 3496               		.loc 2 276 0
 3497 053a E5E8      		ldi r30,lo8(-123)
 3498 053c EA95      	1:	dec r30
 3499 053e 01F4      		brne 1b
 3500 0540 0000      		nop
 3501               	.LVL346:
 3502 0542 00E0      		ldi r16,lo8(receivedBuffer)
 3503 0544 10E0      		ldi r17,hi8(receivedBuffer)
 3504               	.LBE196:
 3505               	.LBE195:
 3506               	.LBB197:
 477:main.c        **** 			_delay_us(50);
 478:main.c        **** 			
 479:main.c        **** 			// Write data
 480:main.c        **** 			for (int x = 0; x < 256; x++) {
 3507               		.loc 3 480 0
 3508 0546 812C      		mov r8,__zero_reg__
 3509 0548 912C      		mov r9,__zero_reg__
 3510               	.LVL347:
 3511               	.L150:
 481:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3512               		.loc 3 481 0 discriminator 3
 3513 054a F801      		movw r30,r16
 3514 054c 6191      		ld r22,Z+
 3515 054e 8F01      		movw r16,r30
 3516 0550 C401      		movw r24,r8
 3517 0552 8A0D      		add r24,r10
 3518 0554 9B1D      		adc r25,r11
 3519 0556 00D0      		rcall gb_flash_write_bus_cycle
 3520               	.LVL348:
 480:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3521               		.loc 3 480 0 discriminator 3
 3522 0558 FFEF      		ldi r31,-1
 3523 055a 8F1A      		sub r8,r31
 3524 055c 9F0A      		sbc r9,r31
 3525               	.LVL349:
 3526 055e 8114      		cp r8,__zero_reg__
 3527 0560 21E0      		ldi r18,1
 3528 0562 9206      		cpc r9,r18
 3529 0564 01F4      		brne .L150
 3530 0566 8FEF      		ldi r24,-1
 3531 0568 D81A      		sub r13,r24
 3532 056a E80A      		sbc r14,r24
 3533 056c F80A      		sbc r15,r24
 3534               	.LBE197:
 482:main.c        **** 				address++;
 483:main.c        **** 			}
 484:main.c        **** 			
 485:main.c        **** 			// Write buffer to flash
 486:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 3535               		.loc 3 486 0
 3536 056e C601      		movw r24,r12
 3537 0570 9A95      		dec r25
 3538 0572 6AE2      		ldi r22,lo8(42)
 3539 0574 00D0      		rcall gb_flash_write_bus_cycle
 3540               	.LVL350:
 487:main.c        **** 			
 488:main.c        **** 			// Verify last byte written
 489:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3541               		.loc 3 489 0
 3542 0576 8601      		movw r16,r12
 3543 0578 0150      		subi r16,1
 3544 057a 1109      		sbc r17,__zero_reg__
 3545 057c C801      		movw r24,r16
 3546 057e 00D0      		rcall gb_flash_read_byte
 3547               	.LVL351:
 3548               	.L151:
 490:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 3549               		.loc 3 490 0
 3550 0580 9091 0000 		lds r25,receivedBuffer+255
 3551 0584 8917      		cp r24,r25
 3552 0586 01F4      		brne .+2
 3553 0588 00C0      		rjmp .L240
 491:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3554               		.loc 3 491 0
 3555 058a C801      		movw r24,r16
 3556               	.LVL352:
 3557 058c 00D0      		rcall gb_flash_read_byte
 3558               	.LVL353:
 3559               	.LBB198:
 3560               	.LBB199:
 3561               		.loc 2 276 0
 3562 058e 9DE0      		ldi r25,lo8(13)
 3563 0590 9A95      	1:	dec r25
 3564 0592 01F4      		brne 1b
 3565 0594 0000      		nop
 3566 0596 00C0      		rjmp .L151
 3567               	.LVL354:
 3568               	.L149:
 3569               	.LBE199:
 3570               	.LBE198:
 3571               	.LBE194:
 492:main.c        **** 				_delay_us(5);
 493:main.c        **** 			}
 494:main.c        **** 			
 495:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 496:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 497:main.c        **** 		}
 498:main.c        **** 		
 499:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 500:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 3572               		.loc 3 500 0
 3573 0598 9A35      		cpi r25,lo8(90)
 3574 059a 01F0      		breq .+2
 3575 059c 00C0      		rjmp .L153
 501:main.c        **** 			usart_read_bytes(128);
 3576               		.loc 3 501 0
 3577 059e 80E8      		ldi r24,lo8(-128)
 3578 05a0 90E0      		ldi r25,0
 3579               	.LVL355:
 3580 05a2 00D0      		rcall usart_read_bytes
 3581               	.LVL356:
 502:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3582               		.loc 3 502 0
 3583 05a4 939A      		sbi 0x12,3
 503:main.c        **** 			
 504:main.c        **** 			// Enable flash chip access
 505:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 3584               		.loc 3 505 0
 3585 05a6 69E0      		ldi r22,lo8(9)
 3586 05a8 80E2      		ldi r24,lo8(32)
 3587 05aa 91E0      		ldi r25,lo8(1)
 3588 05ac 00D0      		rcall gb_flash_write_bus_cycle
 3589               	.LVL357:
 506:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 3590               		.loc 3 506 0
 3591 05ae 6AEA      		ldi r22,lo8(-86)
 3592 05b0 81E2      		ldi r24,lo8(33)
 3593 05b2 91E0      		ldi r25,lo8(1)
 3594 05b4 00D0      		rcall gb_flash_write_bus_cycle
 3595               	.LVL358:
 507:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 3596               		.loc 3 507 0
 3597 05b6 65E5      		ldi r22,lo8(85)
 3598 05b8 82E2      		ldi r24,lo8(34)
 3599 05ba 91E0      		ldi r25,lo8(1)
 3600 05bc 00D0      		rcall gb_flash_write_bus_cycle
 3601               	.LVL359:
 508:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3602               		.loc 3 508 0
 3603 05be 65EA      		ldi r22,lo8(-91)
 3604 05c0 8FE3      		ldi r24,lo8(63)
 3605 05c2 91E0      		ldi r25,lo8(1)
 3606 05c4 00D0      		rcall gb_flash_write_bus_cycle
 3607               	.LVL360:
 3608               	.LBB200:
 3609               	.LBB201:
 3610               		.loc 2 276 0
 3611 05c6 EDE0      		ldi r30,lo8(13)
 3612 05c8 EA95      	1:	dec r30
 3613 05ca 01F4      		brne 1b
 3614 05cc 0000      		nop
 3615               	.LVL361:
 3616               	.LBE201:
 3617               	.LBE200:
 509:main.c        **** 			_delay_us(5);
 510:main.c        **** 			
 511:main.c        **** 			// Re-Enable writes to MBC registers
 512:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 3618               		.loc 3 512 0
 3619 05ce 61E1      		ldi r22,lo8(17)
 3620 05d0 80E2      		ldi r24,lo8(32)
 3621 05d2 91E0      		ldi r25,lo8(1)
 3622 05d4 00D0      		rcall gb_flash_write_bus_cycle
 3623               	.LVL362:
 513:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3624               		.loc 3 513 0
 3625 05d6 65EA      		ldi r22,lo8(-91)
 3626 05d8 8FE3      		ldi r24,lo8(63)
 3627 05da 91E0      		ldi r25,lo8(1)
 3628 05dc 00D0      		rcall gb_flash_write_bus_cycle
 3629               	.LVL363:
 3630               	.LBB202:
 3631               	.LBB203:
 3632               		.loc 2 276 0
 3633 05de FDE0      		ldi r31,lo8(13)
 3634 05e0 FA95      	1:	dec r31
 3635 05e2 01F4      		brne 1b
 3636 05e4 0000      		nop
 3637               	.LVL364:
 3638               	.LBE203:
 3639               	.LBE202:
 514:main.c        **** 			_delay_us(5);
 515:main.c        **** 			
 516:main.c        **** 			// Bank 1 for commands
 517:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 3640               		.loc 3 517 0
 3641 05e6 61E0      		ldi r22,lo8(1)
 3642 05e8 80E0      		ldi r24,0
 3643 05ea 91E2      		ldi r25,lo8(33)
 3644 05ec 00D0      		rcall gb_flash_write_bus_cycle
 3645               	.LVL365:
 3646               	.LBB204:
 3647               	.LBB205:
 3648               		.loc 2 276 0
 3649 05ee 2DE0      		ldi r18,lo8(13)
 3650 05f0 2A95      	1:	dec r18
 3651 05f2 01F4      		brne 1b
 3652 05f4 0000      		nop
 3653               	.LVL366:
 3654               	.LBE205:
 3655               	.LBE204:
 518:main.c        **** 			_delay_us(5);
 519:main.c        **** 			
 520:main.c        **** 			
 521:main.c        **** 			// Write setup
 522:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 3656               		.loc 3 522 0
 3657 05f6 6FE0      		ldi r22,lo8(15)
 3658 05f8 80E2      		ldi r24,lo8(32)
 3659 05fa 91E0      		ldi r25,lo8(1)
 3660 05fc 00D0      		rcall gb_flash_write_bus_cycle
 3661               	.LVL367:
 523:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3662               		.loc 3 523 0
 3663 05fe 65E5      		ldi r22,lo8(85)
 3664 0600 85E2      		ldi r24,lo8(37)
 3665 0602 91E0      		ldi r25,lo8(1)
 3666 0604 00D0      		rcall gb_flash_write_bus_cycle
 3667               	.LVL368:
 524:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3668               		.loc 3 524 0
 3669 0606 65E5      		ldi r22,lo8(85)
 3670 0608 86E2      		ldi r24,lo8(38)
 3671 060a 91E0      		ldi r25,lo8(1)
 3672 060c 00D0      		rcall gb_flash_write_bus_cycle
 3673               	.LVL369:
 525:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 3674               		.loc 3 525 0
 3675 060e 6AEA      		ldi r22,lo8(-86)
 3676 0610 87E2      		ldi r24,lo8(39)
 3677 0612 91E0      		ldi r25,lo8(1)
 3678 0614 00D0      		rcall gb_flash_write_bus_cycle
 3679               	.LVL370:
 526:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3680               		.loc 3 526 0
 3681 0616 65EA      		ldi r22,lo8(-91)
 3682 0618 8FE3      		ldi r24,lo8(63)
 3683 061a 91E0      		ldi r25,lo8(1)
 3684 061c 00D0      		rcall gb_flash_write_bus_cycle
 3685               	.LVL371:
 3686               	.LBB206:
 3687               	.LBB207:
 3688               		.loc 2 276 0
 3689 061e 8DE0      		ldi r24,lo8(13)
 3690 0620 8A95      	1:	dec r24
 3691 0622 01F4      		brne 1b
 3692 0624 0000      		nop
 3693               	.LVL372:
 3694               	.LBE207:
 3695               	.LBE206:
 527:main.c        **** 			_delay_us(5);
 528:main.c        **** 			
 529:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 3696               		.loc 3 529 0
 3697 0626 6FE0      		ldi r22,lo8(15)
 3698 0628 80E2      		ldi r24,lo8(32)
 3699 062a 91E0      		ldi r25,lo8(1)
 3700 062c 00D0      		rcall gb_flash_write_bus_cycle
 3701               	.LVL373:
 530:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 3702               		.loc 3 530 0
 3703 062e 6AE2      		ldi r22,lo8(42)
 3704 0630 85E2      		ldi r24,lo8(37)
 3705 0632 91E0      		ldi r25,lo8(1)
 3706 0634 00D0      		rcall gb_flash_write_bus_cycle
 3707               	.LVL374:
 531:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 3708               		.loc 3 531 0
 3709 0636 6AEA      		ldi r22,lo8(-86)
 3710 0638 86E2      		ldi r24,lo8(38)
 3711 063a 91E0      		ldi r25,lo8(1)
 3712 063c 00D0      		rcall gb_flash_write_bus_cycle
 3713               	.LVL375:
 532:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 3714               		.loc 3 532 0
 3715 063e 65E5      		ldi r22,lo8(85)
 3716 0640 87E2      		ldi r24,lo8(39)
 3717 0642 91E0      		ldi r25,lo8(1)
 3718 0644 00D0      		rcall gb_flash_write_bus_cycle
 3719               	.LVL376:
 533:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3720               		.loc 3 533 0
 3721 0646 65EA      		ldi r22,lo8(-91)
 3722 0648 8FE3      		ldi r24,lo8(63)
 3723 064a 91E0      		ldi r25,lo8(1)
 3724 064c 00D0      		rcall gb_flash_write_bus_cycle
 3725               	.LVL377:
 3726               	.LBB208:
 3727               	.LBB209:
 3728               		.loc 2 276 0
 3729 064e 9DE0      		ldi r25,lo8(13)
 3730 0650 9A95      	1:	dec r25
 3731 0652 01F4      		brne 1b
 3732 0654 0000      		nop
 3733               	.LVL378:
 3734               	.LBE209:
 3735               	.LBE208:
 534:main.c        **** 			_delay_us(5);
 535:main.c        **** 			
 536:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 3736               		.loc 3 536 0
 3737 0656 6FE0      		ldi r22,lo8(15)
 3738 0658 80E2      		ldi r24,lo8(32)
 3739 065a 91E0      		ldi r25,lo8(1)
 3740 065c 00D0      		rcall gb_flash_write_bus_cycle
 3741               	.LVL379:
 537:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3742               		.loc 3 537 0
 3743 065e 65E5      		ldi r22,lo8(85)
 3744 0660 85E2      		ldi r24,lo8(37)
 3745 0662 91E0      		ldi r25,lo8(1)
 3746 0664 00D0      		rcall gb_flash_write_bus_cycle
 3747               	.LVL380:
 538:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3748               		.loc 3 538 0
 3749 0666 65E5      		ldi r22,lo8(85)
 3750 0668 86E2      		ldi r24,lo8(38)
 3751 066a 91E0      		ldi r25,lo8(1)
 3752 066c 00D0      		rcall gb_flash_write_bus_cycle
 3753               	.LVL381:
 539:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 3754               		.loc 3 539 0
 3755 066e 60EA      		ldi r22,lo8(-96)
 3756 0670 87E2      		ldi r24,lo8(39)
 3757 0672 91E0      		ldi r25,lo8(1)
 3758 0674 00D0      		rcall gb_flash_write_bus_cycle
 3759               	.LVL382:
 540:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3760               		.loc 3 540 0
 3761 0676 65EA      		ldi r22,lo8(-91)
 3762 0678 8FE3      		ldi r24,lo8(63)
 3763 067a 91E0      		ldi r25,lo8(1)
 3764 067c 00D0      		rcall gb_flash_write_bus_cycle
 3765               	.LVL383:
 3766               	.LBB210:
 3767               	.LBB211:
 3768               		.loc 2 276 0
 3769 067e EDE0      		ldi r30,lo8(13)
 3770 0680 EA95      	1:	dec r30
 3771 0682 01F4      		brne 1b
 3772 0684 0000      		nop
 3773               	.LVL384:
 3774               	.LBE211:
 3775               	.LBE210:
 541:main.c        **** 			_delay_us(5);
 542:main.c        **** 			
 543:main.c        **** 			// Set bank back
 544:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 3776               		.loc 3 544 0
 3777 0686 40E0      		ldi r20,0
 3778 0688 6091 0000 		lds r22,lastBankAccessed
 3779 068c 80E0      		ldi r24,0
 3780 068e 91E2      		ldi r25,lo8(33)
 3781 0690 00D0      		rcall write_8bit_data
 3782               	.LVL385:
 3783               	.LBB212:
 3784               	.LBB213:
 3785               		.loc 2 276 0
 3786 0692 FDE0      		ldi r31,lo8(13)
 3787 0694 FA95      	1:	dec r31
 3788 0696 01F4      		brne 1b
 3789 0698 0000      		nop
 3790               	.LVL386:
 3791               	.LBE213:
 3792               	.LBE212:
 545:main.c        **** 			_delay_us(5);
 546:main.c        **** 			
 547:main.c        **** 			// Disable writes to MBC registers
 548:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 3793               		.loc 3 548 0
 3794 069a 60E1      		ldi r22,lo8(16)
 3795 069c 80E2      		ldi r24,lo8(32)
 3796 069e 91E0      		ldi r25,lo8(1)
 3797 06a0 00D0      		rcall gb_flash_write_bus_cycle
 3798               	.LVL387:
 549:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3799               		.loc 3 549 0
 3800 06a2 65EA      		ldi r22,lo8(-91)
 3801 06a4 8FE3      		ldi r24,lo8(63)
 3802 06a6 91E0      		ldi r25,lo8(1)
 3803 06a8 00D0      		rcall gb_flash_write_bus_cycle
 3804               	.LVL388:
 3805               	.LBB214:
 3806               	.LBB215:
 3807               		.loc 2 276 0
 3808 06aa 2DE0      		ldi r18,lo8(13)
 3809 06ac 2A95      	1:	dec r18
 3810 06ae 01F4      		brne 1b
 3811 06b0 0000      		nop
 3812               	.LVL389:
 3813               	.LBE215:
 3814               	.LBE214:
 550:main.c        **** 			_delay_us(5);
 551:main.c        **** 			
 552:main.c        **** 			// Undo Wakeup
 553:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 3815               		.loc 3 553 0
 3816 06b2 68E0      		ldi r22,lo8(8)
 3817 06b4 80E2      		ldi r24,lo8(32)
 3818 06b6 91E0      		ldi r25,lo8(1)
 3819 06b8 00D0      		rcall gb_flash_write_bus_cycle
 3820               	.LVL390:
 554:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3821               		.loc 3 554 0
 3822 06ba 65EA      		ldi r22,lo8(-91)
 3823 06bc 8FE3      		ldi r24,lo8(63)
 3824 06be 91E0      		ldi r25,lo8(1)
 3825 06c0 00D0      		rcall gb_flash_write_bus_cycle
 3826               	.LVL391:
 3827               	.LBB216:
 3828               	.LBB217:
 3829               		.loc 2 276 0
 3830 06c2 8DE0      		ldi r24,lo8(13)
 3831 06c4 8A95      	1:	dec r24
 3832 06c6 01F4      		brne 1b
 3833 06c8 0000      		nop
 3834               	.LVL392:
 3835 06ca 00E0      		ldi r16,lo8(receivedBuffer)
 3836 06cc 10E0      		ldi r17,hi8(receivedBuffer)
 3837               	.L154:
 3838               	.LBE217:
 3839               	.LBE216:
 3840               	.LBB218:
 555:main.c        **** 			_delay_us(5);
 556:main.c        **** 			
 557:main.c        **** 			
 558:main.c        **** 			// Write data
 559:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 3841               		.loc 3 559 0 discriminator 1
 3842 06ce 80E0      		ldi r24,hi8(receivedBuffer+128)
 3843 06d0 0030      		cpi r16,lo8(receivedBuffer+128)
 3844 06d2 1807      		cpc r17,r24
 3845 06d4 01F0      		breq .L253
 560:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3846               		.loc 3 560 0 discriminator 3
 3847 06d6 F801      		movw r30,r16
 3848 06d8 6191      		ld r22,Z+
 3849 06da 8F01      		movw r16,r30
 3850 06dc C601      		movw r24,r12
 3851 06de 00D0      		rcall gb_flash_write_bus_cycle
 3852               	.LVL393:
 3853               	.LBB219:
 3854               	.LBB220:
 3855               		.loc 2 276 0 discriminator 3
 3856 06e0 FDE0      		ldi r31,lo8(13)
 3857 06e2 FA95      	1:	dec r31
 3858 06e4 01F4      		brne 1b
 3859 06e6 0000      		nop
 3860               	.LVL394:
 3861               	.LBE220:
 3862               	.LBE219:
 561:main.c        **** 				_delay_us(5);
 562:main.c        **** 				address++;
 3863               		.loc 3 562 0 discriminator 3
 3864 06e8 2FEF      		ldi r18,-1
 3865 06ea C21A      		sub r12,r18
 3866 06ec D20A      		sbc r13,r18
 3867 06ee E20A      		sbc r14,r18
 3868 06f0 F20A      		sbc r15,r18
 3869               	.LVL395:
 3870 06f2 00C0      		rjmp .L154
 3871               	.L253:
 3872               	.LVL396:
 3873               	.LBE218:
 563:main.c        **** 			}
 564:main.c        **** 			
 565:main.c        **** 			// Write buffer to flash
 566:main.c        **** 			address--;
 567:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 3874               		.loc 3 567 0
 3875 06f4 6FEF      		ldi r22,lo8(-1)
 3876 06f6 D701      		movw r26,r14
 3877 06f8 C601      		movw r24,r12
 3878 06fa 0197      		sbiw r24,1
 3879 06fc A109      		sbc r26,__zero_reg__
 3880 06fe B109      		sbc r27,__zero_reg__
 3881               	.LVL397:
 3882 0700 00D0      		rcall gb_flash_write_bus_cycle
 3883               	.LVL398:
 3884               	.LBB221:
 3885               	.LBB222:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3886               		.loc 2 187 0
 3887 0702 EFE1      		ldi r30,lo8(19999)
 3888 0704 FEE4      		ldi r31,hi8(19999)
 3889 0706 3197      	1:	sbiw r30,1
 3890 0708 01F4      		brne 1b
 3891               	.LVL399:
 3892               	.L252:
 3893 070a 00C0      		rjmp .
 3894 070c 0000      		nop
 3895 070e 00C0      		rjmp .L240
 3896               	.LVL400:
 3897               	.L153:
 3898               	.LBE222:
 3899               	.LBE221:
 568:main.c        **** 			address++;
 569:main.c        **** 			_delay_ms(10);
 570:main.c        **** 			
 571:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 572:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 573:main.c        **** 		}
 574:main.c        **** 		
 575:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 576:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 577:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3900               		.loc 3 577 0
 3901 0710 9E36      		cpi r25,lo8(110)
 3902 0712 01F4      		brne .L156
 3903               	.LBB223:
 578:main.c        **** 			usart_read_chars(); // Read address
 3904               		.loc 3 578 0
 3905 0714 00D0      		rcall usart_read_chars
 3906               	.LVL401:
 579:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3907               		.loc 3 579 0
 3908 0716 40E1      		ldi r20,lo8(16)
 3909 0718 50E0      		ldi r21,0
 3910 071a 60E0      		ldi r22,0
 3911 071c 70E0      		ldi r23,0
 3912 071e 80E0      		ldi r24,lo8(receivedBuffer)
 3913 0720 90E0      		ldi r25,hi8(receivedBuffer)
 3914 0722 00D0      		rcall strtol
 3915               	.LVL402:
 3916 0724 4B01      		movw r8,r22
 3917 0726 5C01      		movw r10,r24
 3918               	.LVL403:
 580:main.c        **** 			
 581:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 3919               		.loc 3 581 0
 3920 0728 00D0      		rcall USART_Receive
 3921               	.LVL404:
 3922 072a 8093 0000 		sts receivedChar,r24
 582:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3923               		.loc 3 582 0
 3924 072e 8E36      		cpi r24,lo8(110)
 3925 0730 01F0      		breq .+2
 3926 0732 00C0      		rjmp .L93
 3927               	.LBB224:
 583:main.c        **** 				usart_read_chars(); // Read data
 3928               		.loc 3 583 0
 3929 0734 00D0      		rcall usart_read_chars
 3930               	.LVL405:
 584:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 3931               		.loc 3 584 0
 3932 0736 40E1      		ldi r20,lo8(16)
 3933 0738 50E0      		ldi r21,0
 3934 073a 60E0      		ldi r22,0
 3935 073c 70E0      		ldi r23,0
 3936 073e 80E0      		ldi r24,lo8(receivedBuffer)
 3937 0740 90E0      		ldi r25,hi8(receivedBuffer)
 3938 0742 00D0      		rcall strtol
 3939               	.LVL406:
 585:main.c        **** 				
 586:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3940               		.loc 3 586 0
 3941 0744 939A      		sbi 0x12,3
 587:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3942               		.loc 3 587 0
 3943 0746 2FEF      		ldi r18,lo8(-1)
 3944 0748 24BB      		out 0x14,r18
 588:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3945               		.loc 3 588 0
 3946 074a 2ABB      		out 0x1a,r18
 589:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3947               		.loc 3 589 0
 3948 074c 27BB      		out 0x17,r18
 590:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 3949               		.loc 3 590 0
 3950 074e AB01      		movw r20,r22
 3951 0750 C501      		movw r24,r10
 3952 0752 B401      		movw r22,r8
 3953               	.LVL407:
 3954 0754 00D0      		rcall gba_flash_write_bus_cycle
 3955               	.LVL408:
 3956               	.L251:
 591:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3957               		.loc 3 591 0
 3958 0756 9398      		cbi 0x12,3
 592:main.c        **** 				
 593:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 3959               		.loc 3 593 0
 3960 0758 81E3      		ldi r24,lo8(49)
 3961 075a 00C0      		rjmp .L231
 3962               	.LVL409:
 3963               	.L156:
 3964               	.LBE224:
 3965               	.LBE223:
 594:main.c        **** 			}
 595:main.c        **** 		}
 596:main.c        **** 		
 597:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 598:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 3966               		.loc 3 598 0
 3967 075c 9137      		cpi r25,lo8(113)
 3968 075e 01F0      		breq .L157
 3969               		.loc 3 598 0 is_stmt 0 discriminator 1
 3970 0760 9437      		cpi r25,lo8(116)
 3971 0762 01F4      		brne .L158
 3972               	.L157:
 3973               	.LBB225:
 599:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3974               		.loc 3 599 0 is_stmt 1
 3975 0764 939A      		sbi 0x12,3
 3976               	.LVL410:
 600:main.c        **** 			
 601:main.c        **** 			int readLength = 64;
 602:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 3977               		.loc 3 602 0
 3978 0766 8091 0000 		lds r24,receivedChar
 3979               	.LVL411:
 3980 076a 8437      		cpi r24,lo8(116)
 3981 076c 01F4      		brne .L203
 603:main.c        **** 				readLength = 256;
 3982               		.loc 3 603 0
 3983 076e 00E0      		ldi r16,0
 3984 0770 11E0      		ldi r17,lo8(1)
 3985 0772 00C0      		rjmp .L159
 3986               	.L203:
 601:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 3987               		.loc 3 601 0
 3988 0774 00E4      		ldi r16,lo8(64)
 3989 0776 10E0      		ldi r17,0
 3990               	.L159:
 3991               	.LVL412:
 604:main.c        **** 			}
 605:main.c        **** 			usart_read_bytes(readLength);
 3992               		.loc 3 605 0
 3993 0778 C801      		movw r24,r16
 3994 077a 00D0      		rcall usart_read_bytes
 3995               	.LVL413:
 3996 077c 40E0      		ldi r20,lo8(receivedBuffer)
 3997 077e A42E      		mov r10,r20
 3998 0780 40E0      		ldi r20,hi8(receivedBuffer)
 3999 0782 B42E      		mov r11,r20
 4000 0784 1601      		movw r2,r12
 4001 0786 2701      		movw r4,r14
 4002               	.LVL414:
 4003               	.L160:
 4004               	.LBB226:
 4005               	.LBB227:
 606:main.c        **** 			
 607:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 608:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 609:main.c        **** 				gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 4006               		.loc 3 609 0 discriminator 3
 4007 0788 F501      		movw r30,r10
 4008 078a 4181      		ldd r20,Z+1
 4009 078c 50E0      		ldi r21,0
 4010 078e 542F      		mov r21,r20
 4011 0790 4427      		clr r20
 4012 0792 8081      		ld r24,Z
 4013 0794 482B      		or r20,r24
 4014 0796 21E0      		ldi r18,lo8(1)
 4015 0798 C201      		movw r24,r4
 4016 079a B101      		movw r22,r2
 4017 079c 00D0      		rcall gba_flash_write_byte
 4018               	.LVL415:
 610:main.c        **** 				address++;
 4019               		.loc 3 610 0 discriminator 3
 4020 079e FFEF      		ldi r31,-1
 4021 07a0 2F1A      		sub r2,r31
 4022 07a2 3F0A      		sbc r3,r31
 4023 07a4 4F0A      		sbc r4,r31
 4024 07a6 5F0A      		sbc r5,r31
 4025               	.LVL416:
 4026 07a8 22E0      		ldi r18,2
 4027 07aa A20E      		add r10,r18
 4028 07ac B11C      		adc r11,__zero_reg__
 4029               	.LVL417:
 4030               	.LBE227:
 607:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4031               		.loc 3 607 0 discriminator 3
 4032 07ae C501      		movw r24,r10
 4033 07b0 8050      		subi r24,lo8(receivedBuffer)
 4034 07b2 9040      		sbci r25,hi8(receivedBuffer)
 4035 07b4 8017      		cp r24,r16
 4036 07b6 9107      		cpc r25,r17
 4037 07b8 04F0      		brlt .L160
 4038 07ba 8FEF      		ldi r24,-1
 4039 07bc C81A      		sub r12,r24
 4040 07be D80A      		sbc r13,r24
 4041 07c0 E80A      		sbc r14,r24
 4042 07c2 F80A      		sbc r15,r24
 4043 07c4 0150      		subi r16,1
 4044 07c6 1109      		sbc r17,__zero_reg__
 4045               	.LVL418:
 4046 07c8 1695      		lsr r17
 4047 07ca 0795      		ror r16
 4048               	.LVL419:
 4049 07cc C00E      		add r12,r16
 4050 07ce D11E      		adc r13,r17
 4051 07d0 E11C      		adc r14,__zero_reg__
 4052 07d2 F11C      		adc r15,__zero_reg__
 4053 07d4 00C0      		rjmp .L240
 4054               	.LVL420:
 4055               	.L158:
 4056               	.LBE226:
 4057               	.LBE225:
 611:main.c        **** 			}
 612:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 613:main.c        **** 			
 614:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 615:main.c        **** 		}
 616:main.c        **** 		
 617:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 618:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 4058               		.loc 3 618 0
 4059 07d6 9636      		cpi r25,lo8(102)
 4060 07d8 01F4      		brne .L161
 4061               	.LBB228:
 619:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4062               		.loc 3 619 0
 4063 07da 939A      		sbi 0x12,3
 4064               	.LVL421:
 620:main.c        **** 			
 621:main.c        **** 			int readLength = 256;
 622:main.c        **** 			usart_read_bytes(readLength);
 4065               		.loc 3 622 0
 4066 07dc 80E0      		ldi r24,0
 4067 07de 91E0      		ldi r25,lo8(1)
 4068               	.LVL422:
 4069 07e0 00D0      		rcall usart_read_bytes
 4070               	.LVL423:
 4071 07e2 00E0      		ldi r16,lo8(receivedBuffer)
 4072 07e4 10E0      		ldi r17,hi8(receivedBuffer)
 4073 07e6 4601      		movw r8,r12
 4074 07e8 5701      		movw r10,r14
 4075               	.LVL424:
 4076               	.L162:
 4077               	.LBB229:
 4078               	.LBB230:
 623:main.c        **** 			
 624:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 625:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 626:main.c        **** 				gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 4079               		.loc 3 626 0 discriminator 3
 4080 07ea F801      		movw r30,r16
 4081 07ec 4181      		ldd r20,Z+1
 4082 07ee 50E0      		ldi r21,0
 4083 07f0 542F      		mov r21,r20
 4084 07f2 4427      		clr r20
 4085 07f4 8081      		ld r24,Z
 4086 07f6 482B      		or r20,r24
 4087 07f8 20E0      		ldi r18,0
 4088 07fa C501      		movw r24,r10
 4089 07fc B401      		movw r22,r8
 4090 07fe 00D0      		rcall gba_flash_write_byte
 4091               	.LVL425:
 627:main.c        **** 				address++;
 4092               		.loc 3 627 0 discriminator 3
 4093 0800 FFEF      		ldi r31,-1
 4094 0802 8F1A      		sub r8,r31
 4095 0804 9F0A      		sbc r9,r31
 4096 0806 AF0A      		sbc r10,r31
 4097 0808 BF0A      		sbc r11,r31
 4098               	.LVL426:
 4099 080a 0E5F      		subi r16,-2
 4100 080c 1F4F      		sbci r17,-1
 4101               	.LVL427:
 4102               	.LBE230:
 624:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4103               		.loc 3 624 0 discriminator 3
 4104 080e 20E0      		ldi r18,hi8(receivedBuffer+256)
 4105 0810 0030      		cpi r16,lo8(receivedBuffer+256)
 4106 0812 1207      		cpc r17,r18
 4107 0814 01F4      		brne .L162
 4108 0816 80E8      		ldi r24,-128
 4109 0818 C80E      		add r12,r24
 4110 081a D11C      		adc r13,__zero_reg__
 4111 081c E11C      		adc r14,__zero_reg__
 4112 081e F11C      		adc r15,__zero_reg__
 4113 0820 00C0      		rjmp .L240
 4114               	.LVL428:
 4115               	.L161:
 4116               	.LBE229:
 4117               	.LBE228:
 628:main.c        **** 			}
 629:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 630:main.c        **** 			
 631:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 632:main.c        **** 		}
 633:main.c        **** 		
 634:main.c        **** 		// Intel flash command based chips
 635:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 636:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 4118               		.loc 3 636 0
 4119 0822 9C36      		cpi r25,lo8(108)
 4120 0824 01F0      		breq .+2
 4121 0826 00C0      		rjmp .L163
 4122               	.LBB231:
 637:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4123               		.loc 3 637 0
 4124 0828 939A      		sbi 0x12,3
 638:main.c        **** 			usart_read_bytes(64);
 4125               		.loc 3 638 0
 4126 082a 80E4      		ldi r24,lo8(64)
 4127 082c 90E0      		ldi r25,0
 4128               	.LVL429:
 4129 082e 00D0      		rcall usart_read_bytes
 4130               	.LVL430:
 639:main.c        **** 			
 640:main.c        **** 			// Set address lines as outputs
 641:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4131               		.loc 3 641 0
 4132 0830 8FEF      		ldi r24,lo8(-1)
 4133 0832 84BB      		out 0x14,r24
 642:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4134               		.loc 3 642 0
 4135 0834 8ABB      		out 0x1a,r24
 643:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4136               		.loc 3 643 0
 4137 0836 87BB      		out 0x17,r24
 644:main.c        **** 			
 645:main.c        **** 			// Unlock
 646:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 4138               		.loc 3 646 0
 4139 0838 40E6      		ldi r20,lo8(96)
 4140 083a 50E0      		ldi r21,0
 4141 083c C701      		movw r24,r14
 4142 083e B601      		movw r22,r12
 4143 0840 00D0      		rcall gba_flash_write_bus_cycle
 4144               	.LVL431:
 647:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4145               		.loc 3 647 0
 4146 0842 40ED      		ldi r20,lo8(-48)
 4147 0844 50E0      		ldi r21,0
 4148 0846 C701      		movw r24,r14
 4149 0848 B601      		movw r22,r12
 4150 084a 00D0      		rcall gba_flash_write_bus_cycle
 4151               	.LVL432:
 648:main.c        **** 			
 649:main.c        **** 			// Buffered write command
 650:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 4152               		.loc 3 650 0
 4153 084c 48EE      		ldi r20,lo8(-24)
 4154 084e 50E0      		ldi r21,0
 4155 0850 C701      		movw r24,r14
 4156 0852 B601      		movw r22,r12
 4157 0854 00D0      		rcall gba_flash_write_bus_cycle
 4158               	.LVL433:
 4159               	.LBB232:
 4160               	.LBB233:
 4161               		.loc 2 276 0
 4162 0856 95E8      		ldi r25,lo8(-123)
 4163 0858 9A95      	1:	dec r25
 4164 085a 01F4      		brne 1b
 4165 085c 0000      		nop
 4166               	.LVL434:
 4167               	.LBE233:
 4168               	.LBE232:
 651:main.c        **** 			_delay_us(50);
 652:main.c        **** 			
 653:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 654:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 4169               		.loc 3 654 0
 4170 085e C701      		movw r24,r14
 4171 0860 B601      		movw r22,r12
 4172 0862 00D0      		rcall gba_read_16bit_data
 4173               	.LVL435:
 4174               	.L164:
 655:main.c        **** 			while (dataVerify != 0x0080) {
 4175               		.loc 3 655 0
 4176 0864 8038      		cpi r24,-128
 4177 0866 9105      		cpc r25,__zero_reg__
 4178 0868 01F0      		breq .L254
 656:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4179               		.loc 3 656 0
 4180 086a C701      		movw r24,r14
 4181 086c B601      		movw r22,r12
 4182 086e 00D0      		rcall gba_read_16bit_data
 4183               	.LVL436:
 4184               	.LBB234:
 4185               	.LBB235:
 4186               		.loc 2 276 0
 4187 0870 E5E8      		ldi r30,lo8(-123)
 4188 0872 EA95      	1:	dec r30
 4189 0874 01F4      		brne 1b
 4190 0876 0000      		nop
 4191 0878 00C0      		rjmp .L164
 4192               	.LVL437:
 4193               	.L254:
 4194               	.LBE235:
 4195               	.LBE234:
 657:main.c        **** 				_delay_us(50);
 658:main.c        **** 			}
 659:main.c        **** 			
 660:main.c        **** 			
 661:main.c        **** 			// Set address lines as outputs
 662:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4196               		.loc 3 662 0
 4197 087a 8FEF      		ldi r24,lo8(-1)
 4198               	.LVL438:
 4199 087c 84BB      		out 0x14,r24
 663:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4200               		.loc 3 663 0
 4201 087e 8ABB      		out 0x1a,r24
 664:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4202               		.loc 3 664 0
 4203 0880 87BB      		out 0x17,r24
 665:main.c        **** 			
 666:main.c        **** 			// Set length
 667:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 4204               		.loc 3 667 0
 4205 0882 4FE1      		ldi r20,lo8(31)
 4206 0884 50E0      		ldi r21,0
 4207 0886 C701      		movw r24,r14
 4208 0888 B601      		movw r22,r12
 4209 088a 00D0      		rcall gba_flash_write_bus_cycle
 4210               	.LVL439:
 4211 088c 00E0      		ldi r16,lo8(receivedBuffer)
 4212 088e 10E0      		ldi r17,hi8(receivedBuffer)
 4213 0890 4601      		movw r8,r12
 4214 0892 5701      		movw r10,r14
 4215               	.LVL440:
 4216               	.L166:
 4217               	.LBB236:
 4218               	.LBB237:
 668:main.c        **** 			
 669:main.c        **** 			// Write data
 670:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 671:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 672:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4219               		.loc 3 672 0 discriminator 3
 4220 0894 F801      		movw r30,r16
 4221 0896 4181      		ldd r20,Z+1
 4222 0898 50E0      		ldi r21,0
 4223 089a 542F      		mov r21,r20
 4224 089c 4427      		clr r20
 4225 089e 8081      		ld r24,Z
 4226 08a0 482B      		or r20,r24
 4227 08a2 C501      		movw r24,r10
 4228 08a4 B401      		movw r22,r8
 4229 08a6 00D0      		rcall gba_flash_write_bus_cycle
 4230               	.LVL441:
 673:main.c        **** 				address++;
 4231               		.loc 3 673 0 discriminator 3
 4232 08a8 FFEF      		ldi r31,-1
 4233 08aa 8F1A      		sub r8,r31
 4234 08ac 9F0A      		sbc r9,r31
 4235 08ae AF0A      		sbc r10,r31
 4236 08b0 BF0A      		sbc r11,r31
 4237               	.LVL442:
 4238 08b2 0E5F      		subi r16,-2
 4239 08b4 1F4F      		sbci r17,-1
 4240               	.LVL443:
 4241               	.LBE237:
 670:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4242               		.loc 3 670 0 discriminator 3
 4243 08b6 80E0      		ldi r24,lo8(receivedBuffer+64)
 4244 08b8 90E0      		ldi r25,hi8(receivedBuffer+64)
 4245 08ba 8017      		cp r24,r16
 4246 08bc 9107      		cpc r25,r17
 4247 08be 01F4      		brne .L166
 4248 08c0 90E2      		ldi r25,32
 4249 08c2 C90E      		add r12,r25
 4250 08c4 D11C      		adc r13,__zero_reg__
 4251 08c6 E11C      		adc r14,__zero_reg__
 4252 08c8 F11C      		adc r15,__zero_reg__
 4253               	.LBE236:
 674:main.c        **** 			}
 675:main.c        **** 			
 676:main.c        **** 			// Write buffer to flash
 677:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4254               		.loc 3 677 0
 4255 08ca 40ED      		ldi r20,lo8(-48)
 4256 08cc 50E0      		ldi r21,0
 4257 08ce C701      		movw r24,r14
 4258 08d0 B601      		movw r22,r12
 4259 08d2 00D0      		rcall gba_flash_write_bus_cycle
 4260               	.LVL444:
 4261               	.LBB238:
 4262               	.LBB239:
 4263               		.loc 2 276 0
 4264 08d4 EFE6      		ldi r30,lo8(879)
 4265 08d6 F3E0      		ldi r31,hi8(879)
 4266 08d8 3197      	1:	sbiw r30,1
 4267 08da 01F4      		brne 1b
 4268 08dc 00C0      		rjmp .
 4269 08de 0000      		nop
 4270               	.LVL445:
 4271               	.LBE239:
 4272               	.LBE238:
 678:main.c        **** 			_delay_us(440);
 679:main.c        **** 			
 680:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 681:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 4273               		.loc 3 681 0
 4274 08e0 C701      		movw r24,r14
 4275 08e2 B601      		movw r22,r12
 4276 08e4 00D0      		rcall gba_read_16bit_data
 4277               	.LVL446:
 4278               	.L167:
 682:main.c        **** 			while (dataVerify != 0x0080) {
 4279               		.loc 3 682 0
 4280 08e6 8038      		cpi r24,-128
 4281 08e8 9105      		cpc r25,__zero_reg__
 4282 08ea 01F0      		breq .L255
 683:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4283               		.loc 3 683 0
 4284 08ec C701      		movw r24,r14
 4285 08ee B601      		movw r22,r12
 4286 08f0 00D0      		rcall gba_read_16bit_data
 4287               	.LVL447:
 4288               	.LBB240:
 4289               	.LBB241:
 4290               		.loc 2 276 0
 4291 08f2 F5E8      		ldi r31,lo8(-123)
 4292 08f4 FA95      	1:	dec r31
 4293 08f6 01F4      		brne 1b
 4294 08f8 0000      		nop
 4295 08fa 00C0      		rjmp .L167
 4296               	.LVL448:
 4297               	.L255:
 4298               	.LBE241:
 4299               	.LBE240:
 684:main.c        **** 				_delay_us(50);
 685:main.c        **** 			}
 686:main.c        **** 			
 687:main.c        **** 			
 688:main.c        **** 			// Set address lines as outputs
 689:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4300               		.loc 3 689 0
 4301 08fc 8FEF      		ldi r24,lo8(-1)
 4302               	.LVL449:
 4303 08fe 84BB      		out 0x14,r24
 690:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4304               		.loc 3 690 0
 4305 0900 8ABB      		out 0x1a,r24
 691:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4306               		.loc 3 691 0
 4307 0902 87BB      		out 0x17,r24
 692:main.c        **** 			
 693:main.c        **** 			// Back to reading mode
 694:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 4308               		.loc 3 694 0
 4309 0904 4FEF      		ldi r20,lo8(-1)
 4310 0906 50E0      		ldi r21,0
 4311 0908 C701      		movw r24,r14
 4312 090a B601      		movw r22,r12
 4313 090c 00D0      		rcall gba_flash_write_bus_cycle
 4314               	.LVL450:
 4315               	.L240:
 695:main.c        **** 			
 696:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 4316               		.loc 3 696 0
 4317 090e 81E3      		ldi r24,lo8(49)
 4318 0910 00C0      		rjmp .L234
 4319               	.LVL451:
 4320               	.L163:
 4321               	.LBE231:
 697:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 698:main.c        **** 		}
 699:main.c        **** 		
 700:main.c        **** 		
 701:main.c        **** 		// ---------- General commands ----------
 702:main.c        **** 		// Set any pin as input/output
 703:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 704:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 4322               		.loc 3 704 0
 4323 0912 9934      		cpi r25,lo8(73)
 4324 0914 01F0      		breq .L169
 4325               		.loc 3 704 0 is_stmt 0 discriminator 1
 4326 0916 9F34      		cpi r25,lo8(79)
 4327 0918 01F0      		breq .+2
 4328 091a 00C0      		rjmp .L170
 4329               	.L169:
 4330               	.LBB242:
 705:main.c        **** 			char portChar = USART_Receive();
 4331               		.loc 3 705 0 is_stmt 1
 4332 091c 00D0      		rcall USART_Receive
 4333               	.LVL452:
 4334 091e 182F      		mov r17,r24
 4335               	.LVL453:
 706:main.c        **** 			usart_read_chars();
 4336               		.loc 3 706 0
 4337 0920 00D0      		rcall usart_read_chars
 4338               	.LVL454:
 707:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4339               		.loc 3 707 0
 4340 0922 40E1      		ldi r20,lo8(16)
 4341 0924 50E0      		ldi r21,0
 4342 0926 60E0      		ldi r22,0
 4343 0928 70E0      		ldi r23,0
 4344 092a 80E0      		ldi r24,lo8(receivedBuffer)
 4345 092c 90E0      		ldi r25,hi8(receivedBuffer)
 4346 092e 00D0      		rcall strtol
 4347               	.LVL455:
 708:main.c        **** 			
 709:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4348               		.loc 3 709 0
 4349 0930 939A      		sbi 0x12,3
 710:main.c        **** 			if (receivedChar == SET_INPUT) {
 4350               		.loc 3 710 0
 4351 0932 8091 0000 		lds r24,receivedChar
 4352 0936 8934      		cpi r24,lo8(73)
 4353 0938 01F4      		brne .L171
 711:main.c        **** 				if (portChar == 'A') {
 4354               		.loc 3 711 0
 4355 093a 1134      		cpi r17,lo8(65)
 4356 093c 01F4      		brne .L172
 712:main.c        **** 					DDRA &= ~(setValue);
 4357               		.loc 3 712 0
 4358 093e 8AB3      		in r24,0x1a
 4359 0940 6095      		com r22
 4360               	.LVL456:
 4361 0942 6823      		and r22,r24
 4362               	.LVL457:
 4363 0944 00C0      		rjmp .L242
 4364               	.LVL458:
 4365               	.L172:
 713:main.c        **** 				}
 714:main.c        **** 				else if (portChar == 'B') {
 4366               		.loc 3 714 0
 4367 0946 1234      		cpi r17,lo8(66)
 4368 0948 01F4      		brne .L174
 715:main.c        **** 					DDRB &= ~(setValue);
 4369               		.loc 3 715 0
 4370 094a 87B3      		in r24,0x17
 4371 094c 6095      		com r22
 4372               	.LVL459:
 4373 094e 6823      		and r22,r24
 4374               	.LVL460:
 4375 0950 00C0      		rjmp .L243
 4376               	.LVL461:
 4377               	.L174:
 716:main.c        **** 				}
 717:main.c        **** 				else if (portChar == 'C') {
 4378               		.loc 3 717 0
 4379 0952 1334      		cpi r17,lo8(67)
 4380 0954 01F4      		brne .L175
 718:main.c        **** 					DDRC &= ~(setValue);
 4381               		.loc 3 718 0
 4382 0956 84B3      		in r24,0x14
 4383 0958 6095      		com r22
 4384               	.LVL462:
 4385 095a 6823      		and r22,r24
 4386               	.LVL463:
 4387 095c 00C0      		rjmp .L248
 4388               	.LVL464:
 4389               	.L175:
 719:main.c        **** 				}
 720:main.c        **** 				else if (portChar == 'D') {
 4390               		.loc 3 720 0
 4391 095e 1434      		cpi r17,lo8(68)
 4392 0960 01F4      		brne .L176
 721:main.c        **** 					DDRD &= ~(setValue);
 4393               		.loc 3 721 0
 4394 0962 81B3      		in r24,0x11
 4395 0964 6095      		com r22
 4396               	.LVL465:
 4397 0966 6823      		and r22,r24
 4398               	.LVL466:
 4399 0968 00C0      		rjmp .L249
 4400               	.LVL467:
 4401               	.L176:
 722:main.c        **** 				}
 723:main.c        **** 				else if (portChar == 'E') {
 4402               		.loc 3 723 0
 4403 096a 1534      		cpi r17,lo8(69)
 4404 096c 01F0      		breq .+2
 4405 096e 00C0      		rjmp .L195
 724:main.c        **** 					DDRE &= ~(setValue);
 4406               		.loc 3 724 0
 4407 0970 86B1      		in r24,0x6
 4408 0972 6095      		com r22
 4409               	.LVL468:
 4410 0974 6823      		and r22,r24
 4411               	.LVL469:
 4412 0976 00C0      		rjmp .L250
 4413               	.LVL470:
 4414               	.L171:
 725:main.c        **** 				}
 726:main.c        **** 			}
 727:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 4415               		.loc 3 727 0
 4416 0978 8F34      		cpi r24,lo8(79)
 4417 097a 01F0      		breq .+2
 4418 097c 00C0      		rjmp .L195
 728:main.c        **** 				if (portChar == 'A') {
 4419               		.loc 3 728 0
 4420 097e 1134      		cpi r17,lo8(65)
 4421 0980 01F4      		brne .L177
 729:main.c        **** 					DDRA |= (setValue);
 4422               		.loc 3 729 0
 4423 0982 8AB3      		in r24,0x1a
 4424 0984 682B      		or r22,r24
 4425               	.LVL471:
 4426               	.L242:
 4427 0986 6ABB      		out 0x1a,r22
 4428 0988 00C0      		rjmp .L195
 4429               	.LVL472:
 4430               	.L177:
 730:main.c        **** 				}
 731:main.c        **** 				else if (portChar == 'B') {
 4431               		.loc 3 731 0
 4432 098a 1234      		cpi r17,lo8(66)
 4433 098c 01F4      		brne .L178
 732:main.c        **** 					DDRB |= (setValue);
 4434               		.loc 3 732 0
 4435 098e 87B3      		in r24,0x17
 4436 0990 682B      		or r22,r24
 4437               	.LVL473:
 4438               	.L243:
 4439 0992 67BB      		out 0x17,r22
 4440 0994 00C0      		rjmp .L195
 4441               	.LVL474:
 4442               	.L178:
 733:main.c        **** 				}
 734:main.c        **** 				else if (portChar == 'C') {
 4443               		.loc 3 734 0
 4444 0996 1334      		cpi r17,lo8(67)
 4445 0998 01F4      		brne .L179
 735:main.c        **** 					DDRC |= (setValue);
 4446               		.loc 3 735 0
 4447 099a 84B3      		in r24,0x14
 4448 099c 682B      		or r22,r24
 4449               	.LVL475:
 4450               	.L248:
 4451 099e 64BB      		out 0x14,r22
 4452 09a0 00C0      		rjmp .L195
 4453               	.LVL476:
 4454               	.L179:
 736:main.c        **** 				}
 737:main.c        **** 				else if (portChar == 'D') {
 4455               		.loc 3 737 0
 4456 09a2 1434      		cpi r17,lo8(68)
 4457 09a4 01F4      		brne .L180
 738:main.c        **** 					DDRD |= (setValue);
 4458               		.loc 3 738 0
 4459 09a6 81B3      		in r24,0x11
 4460 09a8 682B      		or r22,r24
 4461               	.LVL477:
 4462               	.L249:
 4463 09aa 61BB      		out 0x11,r22
 4464 09ac 00C0      		rjmp .L195
 4465               	.LVL478:
 4466               	.L180:
 739:main.c        **** 				}
 740:main.c        **** 				else if (portChar == 'E') {
 4467               		.loc 3 740 0
 4468 09ae 1534      		cpi r17,lo8(69)
 4469 09b0 01F0      		breq .+2
 4470 09b2 00C0      		rjmp .L195
 741:main.c        **** 					DDRE |= (setValue);
 4471               		.loc 3 741 0
 4472 09b4 86B1      		in r24,0x6
 4473 09b6 682B      		or r22,r24
 4474               	.LVL479:
 4475               	.L250:
 4476 09b8 66B9      		out 0x6,r22
 4477 09ba 00C0      		rjmp .L195
 4478               	.LVL480:
 4479               	.L170:
 4480               	.LBE242:
 742:main.c        **** 				}
 743:main.c        **** 			}
 744:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 745:main.c        **** 		}
 746:main.c        **** 		
 747:main.c        **** 		// Set pin output as low
 748:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 4481               		.loc 3 748 0
 4482 09bc 9C34      		cpi r25,lo8(76)
 4483 09be 01F4      		brne .L181
 4484               	.LBB243:
 749:main.c        **** 			char portChar = USART_Receive();			
 4485               		.loc 3 749 0
 4486 09c0 00D0      		rcall USART_Receive
 4487               	.LVL481:
 4488 09c2 182F      		mov r17,r24
 4489               	.LVL482:
 750:main.c        **** 			usart_read_chars();
 4490               		.loc 3 750 0
 4491 09c4 00D0      		rcall usart_read_chars
 4492               	.LVL483:
 751:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4493               		.loc 3 751 0
 4494 09c6 40E1      		ldi r20,lo8(16)
 4495 09c8 50E0      		ldi r21,0
 4496 09ca 60E0      		ldi r22,0
 4497 09cc 70E0      		ldi r23,0
 4498 09ce 80E0      		ldi r24,lo8(receivedBuffer)
 4499 09d0 90E0      		ldi r25,hi8(receivedBuffer)
 4500 09d2 00D0      		rcall strtol
 4501               	.LVL484:
 752:main.c        **** 			
 753:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4502               		.loc 3 753 0
 4503 09d4 939A      		sbi 0x12,3
 754:main.c        **** 			if (portChar == 'A') {
 4504               		.loc 3 754 0
 4505 09d6 1134      		cpi r17,lo8(65)
 4506 09d8 01F4      		brne .L182
 755:main.c        **** 				PORTA &= ~(setValue);
 4507               		.loc 3 755 0
 4508 09da 8BB3      		in r24,0x1b
 4509 09dc 6095      		com r22
 4510               	.LVL485:
 4511 09de 6823      		and r22,r24
 4512               	.LVL486:
 4513 09e0 00C0      		rjmp .L247
 4514               	.LVL487:
 4515               	.L182:
 756:main.c        **** 			}
 757:main.c        **** 			else if (portChar == 'B') {
 4516               		.loc 3 757 0
 4517 09e2 1234      		cpi r17,lo8(66)
 4518 09e4 01F4      		brne .L184
 758:main.c        **** 				PORTB &= ~(setValue);
 4519               		.loc 3 758 0
 4520 09e6 88B3      		in r24,0x18
 4521 09e8 6095      		com r22
 4522               	.LVL488:
 4523 09ea 6823      		and r22,r24
 4524               	.LVL489:
 4525 09ec 00C0      		rjmp .L246
 4526               	.LVL490:
 4527               	.L184:
 759:main.c        **** 			}
 760:main.c        **** 			else if (portChar == 'C') {
 4528               		.loc 3 760 0
 4529 09ee 1334      		cpi r17,lo8(67)
 4530 09f0 01F4      		brne .L185
 761:main.c        **** 				PORTC &= ~(setValue);
 4531               		.loc 3 761 0
 4532 09f2 85B3      		in r24,0x15
 4533 09f4 6095      		com r22
 4534               	.LVL491:
 4535 09f6 6823      		and r22,r24
 4536               	.LVL492:
 4537 09f8 00C0      		rjmp .L245
 4538               	.LVL493:
 4539               	.L185:
 762:main.c        **** 			}
 763:main.c        **** 			else if (portChar == 'D') {
 4540               		.loc 3 763 0
 4541 09fa 1434      		cpi r17,lo8(68)
 4542 09fc 01F4      		brne .L186
 764:main.c        **** 				PORTD &= ~(setValue);
 4543               		.loc 3 764 0
 4544 09fe 82B3      		in r24,0x12
 4545 0a00 6095      		com r22
 4546               	.LVL494:
 4547 0a02 6823      		and r22,r24
 4548               	.LVL495:
 4549 0a04 00C0      		rjmp .L244
 4550               	.LVL496:
 4551               	.L186:
 765:main.c        **** 			}
 766:main.c        **** 			else if (portChar == 'E') {
 4552               		.loc 3 766 0
 4553 0a06 1534      		cpi r17,lo8(69)
 4554 0a08 01F0      		breq .+2
 4555 0a0a 00C0      		rjmp .L195
 767:main.c        **** 				PORTE &= ~(setValue);
 4556               		.loc 3 767 0
 4557 0a0c 87B1      		in r24,0x7
 4558 0a0e 6095      		com r22
 4559               	.LVL497:
 4560 0a10 6823      		and r22,r24
 4561               	.LVL498:
 4562 0a12 00C0      		rjmp .L241
 4563               	.LVL499:
 4564               	.L181:
 4565               	.LBE243:
 768:main.c        **** 			}
 769:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 770:main.c        **** 		}
 771:main.c        **** 		
 772:main.c        **** 		// Set pin output as high
 773:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 4566               		.loc 3 773 0
 4567 0a14 9834      		cpi r25,lo8(72)
 4568 0a16 01F4      		brne .L187
 4569               	.LBB244:
 774:main.c        **** 			char portChar = USART_Receive();			
 4570               		.loc 3 774 0
 4571 0a18 00D0      		rcall USART_Receive
 4572               	.LVL500:
 4573 0a1a 182F      		mov r17,r24
 4574               	.LVL501:
 775:main.c        **** 			usart_read_chars();
 4575               		.loc 3 775 0
 4576 0a1c 00D0      		rcall usart_read_chars
 4577               	.LVL502:
 776:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4578               		.loc 3 776 0
 4579 0a1e 40E1      		ldi r20,lo8(16)
 4580 0a20 50E0      		ldi r21,0
 4581 0a22 60E0      		ldi r22,0
 4582 0a24 70E0      		ldi r23,0
 4583 0a26 80E0      		ldi r24,lo8(receivedBuffer)
 4584 0a28 90E0      		ldi r25,hi8(receivedBuffer)
 4585 0a2a 00D0      		rcall strtol
 4586               	.LVL503:
 777:main.c        **** 			
 778:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4587               		.loc 3 778 0
 4588 0a2c 939A      		sbi 0x12,3
 779:main.c        **** 			if (portChar == 'A') {
 4589               		.loc 3 779 0
 4590 0a2e 1134      		cpi r17,lo8(65)
 4591 0a30 01F4      		brne .L188
 780:main.c        **** 				PORTA |= (setValue);
 4592               		.loc 3 780 0
 4593 0a32 8BB3      		in r24,0x1b
 4594 0a34 682B      		or r22,r24
 4595               	.LVL504:
 4596               	.L247:
 4597 0a36 6BBB      		out 0x1b,r22
 4598 0a38 00C0      		rjmp .L195
 4599               	.LVL505:
 4600               	.L188:
 781:main.c        **** 			}
 782:main.c        **** 			else if (portChar == 'B') {
 4601               		.loc 3 782 0
 4602 0a3a 1234      		cpi r17,lo8(66)
 4603 0a3c 01F4      		brne .L190
 783:main.c        **** 				PORTB |= (setValue);
 4604               		.loc 3 783 0
 4605 0a3e 88B3      		in r24,0x18
 4606 0a40 682B      		or r22,r24
 4607               	.LVL506:
 4608               	.L246:
 4609 0a42 68BB      		out 0x18,r22
 4610 0a44 00C0      		rjmp .L195
 4611               	.LVL507:
 4612               	.L190:
 784:main.c        **** 			}
 785:main.c        **** 			else if (portChar == 'C') {
 4613               		.loc 3 785 0
 4614 0a46 1334      		cpi r17,lo8(67)
 4615 0a48 01F4      		brne .L191
 786:main.c        **** 				PORTC |= (setValue);
 4616               		.loc 3 786 0
 4617 0a4a 85B3      		in r24,0x15
 4618 0a4c 682B      		or r22,r24
 4619               	.LVL508:
 4620               	.L245:
 4621 0a4e 65BB      		out 0x15,r22
 4622 0a50 00C0      		rjmp .L195
 4623               	.LVL509:
 4624               	.L191:
 787:main.c        **** 			}
 788:main.c        **** 			else if (portChar == 'D') {
 4625               		.loc 3 788 0
 4626 0a52 1434      		cpi r17,lo8(68)
 4627 0a54 01F4      		brne .L192
 789:main.c        **** 				PORTD |= (setValue);
 4628               		.loc 3 789 0
 4629 0a56 82B3      		in r24,0x12
 4630 0a58 682B      		or r22,r24
 4631               	.LVL510:
 4632               	.L244:
 4633 0a5a 62BB      		out 0x12,r22
 4634 0a5c 00C0      		rjmp .L195
 4635               	.LVL511:
 4636               	.L192:
 790:main.c        **** 			}
 791:main.c        **** 			else if (portChar == 'E') {
 4637               		.loc 3 791 0
 4638 0a5e 1534      		cpi r17,lo8(69)
 4639 0a60 01F4      		brne .L195
 792:main.c        **** 				PORTE |= (setValue);
 4640               		.loc 3 792 0
 4641 0a62 87B1      		in r24,0x7
 4642 0a64 682B      		or r22,r24
 4643               	.LVL512:
 4644               	.L241:
 4645 0a66 67B9      		out 0x7,r22
 4646 0a68 00C0      		rjmp .L195
 4647               	.LVL513:
 4648               	.L187:
 4649               	.LBE244:
 793:main.c        **** 			}
 794:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 795:main.c        **** 		}
 796:main.c        **** 		
 797:main.c        **** 		// Read all pins of a PORT and return the value
 798:main.c        **** 		else if (receivedChar == READ_INPUT) {
 4650               		.loc 3 798 0
 4651 0a6a 9434      		cpi r25,lo8(68)
 4652 0a6c 01F4      		brne .L193
 4653               	.LBB245:
 799:main.c        **** 			char portChar = USART_Receive();			
 4654               		.loc 3 799 0
 4655 0a6e 00D0      		rcall USART_Receive
 4656               	.LVL514:
 800:main.c        **** 			
 801:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4657               		.loc 3 801 0
 4658 0a70 939A      		sbi 0x12,3
 802:main.c        **** 			if (portChar == 'A') {
 4659               		.loc 3 802 0
 4660 0a72 8134      		cpi r24,lo8(65)
 4661 0a74 01F4      		brne .L194
 803:main.c        **** 				USART_Transmit(PINA);
 4662               		.loc 3 803 0
 4663 0a76 89B3      		in r24,0x19
 4664               	.LVL515:
 4665 0a78 00C0      		rjmp .L234
 4666               	.LVL516:
 4667               	.L194:
 804:main.c        **** 			}
 805:main.c        **** 			else if (portChar == 'B') {
 4668               		.loc 3 805 0
 4669 0a7a 8234      		cpi r24,lo8(66)
 4670 0a7c 01F4      		brne .L196
 806:main.c        **** 				USART_Transmit(PINB);
 4671               		.loc 3 806 0
 4672 0a7e 86B3      		in r24,0x16
 4673               	.LVL517:
 4674 0a80 00C0      		rjmp .L234
 4675               	.LVL518:
 4676               	.L196:
 807:main.c        **** 			}
 808:main.c        **** 			else if (portChar == 'C') {
 4677               		.loc 3 808 0
 4678 0a82 8334      		cpi r24,lo8(67)
 4679 0a84 01F4      		brne .L197
 809:main.c        **** 				USART_Transmit(PINC);
 4680               		.loc 3 809 0
 4681 0a86 83B3      		in r24,0x13
 4682               	.LVL519:
 4683 0a88 00C0      		rjmp .L234
 4684               	.LVL520:
 4685               	.L197:
 810:main.c        **** 			}
 811:main.c        **** 			else if (portChar == 'D') {
 4686               		.loc 3 811 0
 4687 0a8a 8434      		cpi r24,lo8(68)
 4688 0a8c 01F4      		brne .L198
 812:main.c        **** 				USART_Transmit(PIND);
 4689               		.loc 3 812 0
 4690 0a8e 80B3      		in r24,0x10
 4691               	.LVL521:
 4692 0a90 00C0      		rjmp .L234
 4693               	.LVL522:
 4694               	.L198:
 813:main.c        **** 			}
 814:main.c        **** 			else if (portChar == 'E') {
 4695               		.loc 3 814 0
 4696 0a92 8534      		cpi r24,lo8(69)
 4697 0a94 01F4      		brne .L195
 815:main.c        **** 				USART_Transmit(PINE);
 4698               		.loc 3 815 0
 4699 0a96 85B1      		in r24,0x5
 4700               	.LVL523:
 4701               	.L234:
 4702 0a98 00D0      		rcall USART_Transmit
 4703               	.LVL524:
 4704               	.L195:
 816:main.c        **** 			}
 817:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 4705               		.loc 3 817 0
 4706 0a9a 9398      		cbi 0x12,3
 4707               	.LBE245:
 4708 0a9c 00C0      		rjmp .L93
 4709               	.LVL525:
 4710               	.L193:
 818:main.c        **** 		}
 819:main.c        **** 		
 820:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 821:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 4711               		.loc 3 821 0
 4712 0a9e 9D34      		cpi r25,lo8(77)
 4713 0aa0 01F4      		brne .L199
 4714               	.LBB246:
 822:main.c        **** 			char commonChar = USART_Receive();
 4715               		.loc 3 822 0
 4716 0aa2 00D0      		rcall USART_Receive
 4717               	.LVL526:
 823:main.c        **** 			if (commonChar == '1') {
 4718               		.loc 3 823 0
 4719 0aa4 8133      		cpi r24,lo8(49)
 4720 0aa6 01F4      		brne .L256
 824:main.c        **** 				resetCommonLines = 1;
 4721               		.loc 3 824 0
 4722 0aa8 91E0      		ldi r25,lo8(1)
 4723 0aaa 9983      		std Y+1,r25
 4724 0aac 00C0      		rjmp .L230
 4725               	.L256:
 825:main.c        **** 			}
 826:main.c        **** 			else if (commonChar == '0') {
 4726               		.loc 3 826 0
 4727 0aae 8033      		cpi r24,lo8(48)
 4728 0ab0 01F0      		breq .+2
 4729 0ab2 00C0      		rjmp .L93
 827:main.c        **** 				resetCommonLines = 0;
 4730               		.loc 3 827 0
 4731 0ab4 1982      		std Y+1,__zero_reg__
 4732 0ab6 00C0      		rjmp .L94
 4733               	.LVL527:
 4734               	.L199:
 4735               	.LBE246:
 828:main.c        **** 			}
 829:main.c        **** 		}
 830:main.c        **** 		
 831:main.c        **** 		// Send back the PCB version number
 832:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 4736               		.loc 3 832 0
 4737 0ab8 9836      		cpi r25,lo8(104)
 4738 0aba 01F4      		brne .L200
 833:main.c        **** 			USART_Transmit(PCB_VERSION);
 4739               		.loc 3 833 0
 4740 0abc 82E0      		ldi r24,lo8(2)
 4741               	.LVL528:
 4742 0abe 00C0      		rjmp .L231
 4743               	.LVL529:
 4744               	.L200:
 834:main.c        **** 		}
 835:main.c        **** 		
 836:main.c        **** 		// Send back the firmware version number
 837:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 4745               		.loc 3 837 0
 4746 0ac0 9635      		cpi r25,lo8(86)
 4747 0ac2 01F4      		brne .L201
 838:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 4748               		.loc 3 838 0
 4749 0ac4 8EE0      		ldi r24,lo8(14)
 4750               	.LVL530:
 4751               	.L231:
 4752 0ac6 00D0      		rcall USART_Transmit
 4753               	.LVL531:
 4754 0ac8 00C0      		rjmp .L93
 4755               	.LVL532:
 4756               	.L201:
 839:main.c        **** 		}
 840:main.c        **** 		
 841:main.c        **** 		// Reset the AVR if it matches the number
 842:main.c        **** 		else if (receivedChar == RESET_AVR) {
 4757               		.loc 3 842 0
 4758 0aca 9A32      		cpi r25,lo8(42)
 4759 0acc 01F0      		breq .+2
 4760 0ace 00C0      		rjmp .L93
 4761               	.LBB247:
 843:main.c        **** 			usart_read_chars();
 4762               		.loc 3 843 0
 4763 0ad0 00D0      		rcall usart_read_chars
 4764               	.LVL533:
 844:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 4765               		.loc 3 844 0
 4766 0ad2 40E1      		ldi r20,lo8(16)
 4767 0ad4 50E0      		ldi r21,0
 4768 0ad6 60E0      		ldi r22,0
 4769 0ad8 70E0      		ldi r23,0
 4770 0ada 80E0      		ldi r24,lo8(receivedBuffer)
 4771 0adc 90E0      		ldi r25,hi8(receivedBuffer)
 4772 0ade 00D0      		rcall strtol
 4773               	.LVL534:
 845:main.c        **** 			if (resetValue == RESET_VALUE) {
 4774               		.loc 3 845 0
 4775 0ae0 613E      		cpi r22,-31
 4776 0ae2 754E      		sbci r23,-27
 4777 0ae4 8740      		sbci r24,7
 4778 0ae6 9105      		cpc r25,__zero_reg__
 4779 0ae8 01F0      		breq .+2
 4780 0aea 00C0      		rjmp .L93
 846:main.c        **** 				// Clear watchdog flag
 847:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 4781               		.loc 3 847 0
 4782 0aec 84B7      		in r24,0x34
 4783 0aee 877F      		andi r24,lo8(-9)
 4784 0af0 84BF      		out 0x34,r24
 848:main.c        **** 				
 849:main.c        **** 				// Start timed sequence
 850:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 4785               		.loc 3 850 0
 4786 0af2 88E1      		ldi r24,lo8(24)
 4787 0af4 81BD      		out 0x21,r24
 851:main.c        **** 				
 852:main.c        **** 				// Reset in 250 ms
 853:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 4788               		.loc 3 853 0
 4789 0af6 9CE0      		ldi r25,lo8(12)
 4790 0af8 91BD      		out 0x21,r25
 4791               	.LVL535:
 4792               	.LBB248:
 4793               	.LBB249:
 4794               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 4795               		.loc 4 105 0
 4796 0afa 8FEF      		ldi r24,lo8(-1)
 4797 0afc 9FEF      		ldi r25,lo8(-1)
 4798               	/* #APP */
 4799               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 4800 0afe 0197      		1: sbiw r24,1
 4801 0b00 01F4      		brne 1b
 4802               	 ;  0 "" 2
 4803               	.LVL536:
 4804               	/* #NOAPP */
 4805 0b02 00C0      		rjmp .L93
 4806               	.LBE249:
 4807               	.LBE248:
 4808               	.LBE247:
 4809               		.cfi_endproc
 4810               	.LFE45:
 4812               	.global	lastBankAccessed
 4813               		.section .bss
 4816               	lastBankAccessed:
 4817 0000 00        		.zero	1
 4818               	.global	flashBank1CommandWrites
 4821               	flashBank1CommandWrites:
 4822 0001 00        		.zero	1
 4823               		.comm	flashWriteCycle,12,1
 4824               		.comm	flashWriteWePin,1,1
 4825               		.comm	flashChipIdBuffer,2,1
 4826               		.comm	eepromBuffer,8,1
 4827               		.comm	receivedChar,1,1
 4828               		.comm	receivedBuffer,256,1
 4829               		.text
 4830               	.Letext0:
 4831               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 4832               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1467   .text:0000040a gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1546   .text:0000043c gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1646   .text:000004a0 gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:4816   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1809   .text:00000534 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1875   .text:00000564 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:1999   .text:000005c4 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:2121   .text:00000620 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:2229   .text:00000676 setup
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:2344   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccTJKcRd.s:4821   .bss:00000001 flashBank1CommandWrites

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
